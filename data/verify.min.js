var verify = function(exports) {
    "use strict";
    var commonjsGlobal$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
        dayjs_min = {
            exports: {}
        },
        module;
    module = dayjs_min, module.exports = function() {
        var e = 1e3,
            t = 6e4,
            r = 36e5,
            n = "millisecond",
            s = "second",
            i = "minute",
            a = "hour",
            o = "day",
            l = "week",
            c = "month",
            h = "quarter",
            u = "year",
            d = "date",
            f = "Invalid Date",
            p = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            _ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            g = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
            },
            m = function(e, t, r) {
                var n = String(e);
                return !n || n.length >= t ? e : "" + Array(t + 1 - n.length).join(r) + e
            },
            A = {
                s: m,
                z: function(e) {
                    var t = -e.utcOffset(),
                        r = Math.abs(t),
                        n = Math.floor(r / 60),
                        s = r % 60;
                    return (t <= 0 ? "+" : "-") + m(n, 2, "0") + ":" + m(s, 2, "0")
                },
                m: function e(t, r) {
                    if (t.date() < r.date()) return -e(r, t);
                    var n = 12 * (r.year() - t.year()) + (r.month() - t.month()),
                        s = t.clone().add(n, c),
                        i = r - s < 0,
                        a = t.clone().add(n + (i ? -1 : 1), c);
                    return +(-(n + (r - s) / (i ? s - a : a - s)) || 0)
                },
                a: function(e) {
                    return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
                },
                p: function(e) {
                    return {
                        M: c,
                        y: u,
                        w: l,
                        d: o,
                        D: d,
                        h: a,
                        m: i,
                        s: s,
                        ms: n,
                        Q: h
                    } [e] || String(e || "").toLowerCase().replace(/s$/, "")
                },
                u: function(e) {
                    return void 0 === e
                }
            },
            y = "en",
            b = {};
        b[y] = g;
        var E = function(e) {
                return e instanceof w
            },
            v = function(e, t, r) {
                var n;
                if (!e) return y;
                if ("string" == typeof e) b[e] && (n = e), t && (b[e] = t, n = e);
                else {
                    var s = e.name;
                    b[s] = e, n = s
                }
                return !r && n && (y = n), n || !r && y
            },
            S = function(e, t) {
                if (E(e)) return e.clone();
                var r = "object" == typeof t ? t : {};
                return r.date = e, r.args = arguments, new w(r)
            },
            T = A;
        T.l = v, T.i = E, T.w = function(e, t) {
            return S(e, {
                locale: t.$L,
                utc: t.$u,
                x: t.$x,
                $offset: t.$offset
            })
        };
        var w = function() {
                function g(e) {
                    this.$L = v(e.locale, null, !0), this.parse(e)
                }
                var m = g.prototype;
                return m.parse = function(e) {
                    this.$d = function(e) {
                        var t = e.date,
                            r = e.utc;
                        if (null === t) return new Date(NaN);
                        if (T.u(t)) return new Date;
                        if (t instanceof Date) return new Date(t);
                        if ("string" == typeof t && !/Z$/i.test(t)) {
                            var n = t.match(p);
                            if (n) {
                                var s = n[2] - 1 || 0,
                                    i = (n[7] || "0").substring(0, 3);
                                return r ? new Date(Date.UTC(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, i)) : new Date(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, i)
                            }
                        }
                        return new Date(t)
                    }(e), this.$x = e.x || {}, this.init()
                }, m.init = function() {
                    var e = this.$d;
                    this.$y = e.getFullYear(), this.$M = e.getMonth(), this.$D = e.getDate(), this.$W = e.getDay(), this.$H = e.getHours(), this.$m = e.getMinutes(), this.$s = e.getSeconds(), this.$ms = e.getMilliseconds()
                }, m.$utils = function() {
                    return T
                }, m.isValid = function() {
                    return !(this.$d.toString() === f)
                }, m.isSame = function(e, t) {
                    var r = S(e);
                    return this.startOf(t) <= r && r <= this.endOf(t)
                }, m.isAfter = function(e, t) {
                    return S(e) < this.startOf(t)
                }, m.isBefore = function(e, t) {
                    return this.endOf(t) < S(e)
                }, m.$g = function(e, t, r) {
                    return T.u(e) ? this[t] : this.set(r, e)
                }, m.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }, m.valueOf = function() {
                    return this.$d.getTime()
                }, m.startOf = function(e, t) {
                    var r = this,
                        n = !!T.u(t) || t,
                        h = T.p(e),
                        f = function(e, t) {
                            var s = T.w(r.$u ? Date.UTC(r.$y, t, e) : new Date(r.$y, t, e), r);
                            return n ? s : s.endOf(o)
                        },
                        p = function(e, t) {
                            return T.w(r.toDate()[e].apply(r.toDate("s"), (n ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), r)
                        },
                        _ = this.$W,
                        g = this.$M,
                        m = this.$D,
                        A = "set" + (this.$u ? "UTC" : "");
                    switch (h) {
                        case u:
                            return n ? f(1, 0) : f(31, 11);
                        case c:
                            return n ? f(1, g) : f(0, g + 1);
                        case l:
                            var y = this.$locale().weekStart || 0,
                                b = (_ < y ? _ + 7 : _) - y;
                            return f(n ? m - b : m + (6 - b), g);
                        case o:
                        case d:
                            return p(A + "Hours", 0);
                        case a:
                            return p(A + "Minutes", 1);
                        case i:
                            return p(A + "Seconds", 2);
                        case s:
                            return p(A + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, m.endOf = function(e) {
                    return this.startOf(e, !1)
                }, m.$set = function(e, t) {
                    var r, l = T.p(e),
                        h = "set" + (this.$u ? "UTC" : ""),
                        f = (r = {}, r[o] = h + "Date", r[d] = h + "Date", r[c] = h + "Month", r[u] = h + "FullYear", r[a] = h + "Hours", r[i] = h + "Minutes", r[s] = h + "Seconds", r[n] = h + "Milliseconds", r)[l],
                        p = l === o ? this.$D + (t - this.$W) : t;
                    if (l === c || l === u) {
                        var _ = this.clone().set(d, 1);
                        _.$d[f](p), _.init(), this.$d = _.set(d, Math.min(this.$D, _.daysInMonth())).$d
                    } else f && this.$d[f](p);
                    return this.init(), this
                }, m.set = function(e, t) {
                    return this.clone().$set(e, t)
                }, m.get = function(e) {
                    return this[T.p(e)]()
                }, m.add = function(n, h) {
                    var d, f = this;
                    n = Number(n);
                    var p = T.p(h),
                        _ = function(e) {
                            var t = S(f);
                            return T.w(t.date(t.date() + Math.round(e * n)), f)
                        };
                    if (p === c) return this.set(c, this.$M + n);
                    if (p === u) return this.set(u, this.$y + n);
                    if (p === o) return _(1);
                    if (p === l) return _(7);
                    var g = (d = {}, d[i] = t, d[a] = r, d[s] = e, d)[p] || 1,
                        m = this.$d.getTime() + n * g;
                    return T.w(m, this)
                }, m.subtract = function(e, t) {
                    return this.add(-1 * e, t)
                }, m.format = function(e) {
                    var t = this,
                        r = this.$locale();
                    if (!this.isValid()) return r.invalidDate || f;
                    var n = e || "YYYY-MM-DDTHH:mm:ssZ",
                        s = T.z(this),
                        i = this.$H,
                        a = this.$m,
                        o = this.$M,
                        l = r.weekdays,
                        c = r.months,
                        h = function(e, r, s, i) {
                            return e && (e[r] || e(t, n)) || s[r].substr(0, i)
                        },
                        u = function(e) {
                            return T.s(i % 12 || 12, e, "0")
                        },
                        d = r.meridiem || function(e, t, r) {
                            var n = e < 12 ? "AM" : "PM";
                            return r ? n.toLowerCase() : n
                        },
                        p = {
                            YY: String(this.$y).slice(-2),
                            YYYY: this.$y,
                            M: o + 1,
                            MM: T.s(o + 1, 2, "0"),
                            MMM: h(r.monthsShort, o, c, 3),
                            MMMM: h(c, o),
                            D: this.$D,
                            DD: T.s(this.$D, 2, "0"),
                            d: String(this.$W),
                            dd: h(r.weekdaysMin, this.$W, l, 2),
                            ddd: h(r.weekdaysShort, this.$W, l, 3),
                            dddd: l[this.$W],
                            H: String(i),
                            HH: T.s(i, 2, "0"),
                            h: u(1),
                            hh: u(2),
                            a: d(i, a, !0),
                            A: d(i, a, !1),
                            m: String(a),
                            mm: T.s(a, 2, "0"),
                            s: String(this.$s),
                            ss: T.s(this.$s, 2, "0"),
                            SSS: T.s(this.$ms, 3, "0"),
                            Z: s
                        };
                    return n.replace(_, (function(e, t) {
                        return t || p[e] || s.replace(":", "")
                    }))
                }, m.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, m.diff = function(n, d, f) {
                    var p, _ = T.p(d),
                        g = S(n),
                        m = (g.utcOffset() - this.utcOffset()) * t,
                        A = this - g,
                        y = T.m(this, g);
                    return y = (p = {}, p[u] = y / 12, p[c] = y, p[h] = y / 3, p[l] = (A - m) / 6048e5, p[o] = (A - m) / 864e5, p[a] = A / r, p[i] = A / t, p[s] = A / e, p)[_] || A, f ? y : T.a(y)
                }, m.daysInMonth = function() {
                    return this.endOf(c).$D
                }, m.$locale = function() {
                    return b[this.$L]
                }, m.locale = function(e, t) {
                    if (!e) return this.$L;
                    var r = this.clone(),
                        n = v(e, t, !0);
                    return n && (r.$L = n), r
                }, m.clone = function() {
                    return T.w(this.$d, this)
                }, m.toDate = function() {
                    return new Date(this.valueOf())
                }, m.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }, m.toISOString = function() {
                    return this.$d.toISOString()
                }, m.toString = function() {
                    return this.$d.toUTCString()
                }, g
            }(),
            R = w.prototype;
        return S.prototype = R, [
            ["$ms", n],
            ["$s", s],
            ["$m", i],
            ["$H", a],
            ["$W", o],
            ["$M", c],
            ["$y", u],
            ["$D", d]
        ].forEach((function(e) {
            R[e[1]] = function(t) {
                return this.$g(t, e[0], e[1])
            }
        })), S.extend = function(e, t) {
            return e.$i || (e(t, w, S), e.$i = !0), S
        }, S.locale = v, S.isDayjs = E, S.unix = function(e) {
            return S(1e3 * e)
        }, S.en = b[y], S.Ls = b, S.p = {}, S
    }();
    var dayjs = dayjs_min.exports,
        utc$1 = {
            exports: {}
        };
    ! function(e, t) {
        e.exports = function() {
            var e = "minute",
                t = /[+-]\d\d(?::?\d\d)?/g,
                r = /([+-]|\d\d)/g;
            return function(n, s, i) {
                var a = s.prototype;
                i.utc = function(e) {
                    return new s({
                        date: e,
                        utc: !0,
                        args: arguments
                    })
                }, a.utc = function(t) {
                    var r = i(this.toDate(), {
                        locale: this.$L,
                        utc: !0
                    });
                    return t ? r.add(this.utcOffset(), e) : r
                }, a.local = function() {
                    return i(this.toDate(), {
                        locale: this.$L,
                        utc: !1
                    })
                };
                var o = a.parse;
                a.parse = function(e) {
                    e.utc && (this.$u = !0), this.$utils().u(e.$offset) || (this.$offset = e.$offset), o.call(this, e)
                };
                var l = a.init;
                a.init = function() {
                    if (this.$u) {
                        var e = this.$d;
                        this.$y = e.getUTCFullYear(), this.$M = e.getUTCMonth(), this.$D = e.getUTCDate(), this.$W = e.getUTCDay(), this.$H = e.getUTCHours(), this.$m = e.getUTCMinutes(), this.$s = e.getUTCSeconds(), this.$ms = e.getUTCMilliseconds()
                    } else l.call(this)
                };
                var c = a.utcOffset;
                a.utcOffset = function(n, s) {
                    var i = this.$utils().u;
                    if (i(n)) return this.$u ? 0 : i(this.$offset) ? c.call(this) : this.$offset;
                    if ("string" == typeof n && null === (n = function(e) {
                            void 0 === e && (e = "");
                            var n = e.match(t);
                            if (!n) return null;
                            var s = ("" + n[0]).match(r) || ["-", 0, 0],
                                i = s[0],
                                a = 60 * +s[1] + +s[2];
                            return 0 === a ? 0 : "+" === i ? a : -a
                        }(n))) return this;
                    var a = Math.abs(n) <= 16 ? 60 * n : n,
                        o = this;
                    if (s) return o.$offset = a, o.$u = 0 === n, o;
                    if (0 !== n) {
                        var l = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                        (o = this.local().add(a + l, e)).$offset = a, o.$x.$localOffset = l
                    } else o = this.utc();
                    return o
                };
                var h = a.format;
                a.format = function(e) {
                    var t = e || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
                    return h.call(this, t)
                }, a.valueOf = function() {
                    var e = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || (new Date).getTimezoneOffset());
                    return this.$d.valueOf() - 6e4 * e
                }, a.isUTC = function() {
                    return !!this.$u
                }, a.toISOString = function() {
                    return this.toDate().toISOString()
                }, a.toString = function() {
                    return this.toDate().toUTCString()
                };
                var u = a.toDate;
                a.toDate = function(e) {
                    return "s" === e && this.$offset ? i(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : u.call(this)
                };
                var d = a.diff;
                a.diff = function(e, t, r) {
                    if (e && this.$u === e.$u) return d.call(this, e, t, r);
                    var n = this.local(),
                        s = i(e).local();
                    return d.call(n, s, t, r)
                }
            }
        }()
    }(utc$1);
    var utc = utc$1.exports;
    class QrScanner {
        static hasCamera() {
            return QrScanner.listCameras(!1).then((e => !!e.length)).catch((() => !1))
        }
        static listCameras(e = !1) {
            if (!navigator.mediaDevices) return Promise.resolve([]);
            let t = null;
            return (e ? navigator.mediaDevices.getUserMedia({
                audio: !1,
                video: !0
            }).then((e => t = e)).catch((() => {})) : Promise.resolve()).then((() => navigator.mediaDevices.enumerateDevices())).then((e => e.filter((e => "videoinput" === e.kind)).map(((e, t) => ({
                id: e.deviceId,
                label: e.label || (0 === t ? "Default Camera" : `Camera ${t+1}`)
            }))))).finally((() => {
                if (t)
                    for (const e of t.getTracks()) e.stop(), t.removeTrack(e)
            }))
        }
        constructor(e, t, r = this._onDecodeError, n = this._calculateScanRegion, s = "environment") {
            this.$video = e, this.$canvas = document.createElement("canvas"), this._onDecode = t, this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE, this._preferredCamera = s, this._active = !1, this._paused = !1, this._flashOn = !1, "number" == typeof r ? (this._legacyCanvasSize = r, console.warn("You're using a deprecated version of the QrScanner constructor which will be removed in the future")) : this._onDecodeError = r, "number" == typeof n ? (this._legacyCanvasSize = n, console.warn("You're using a deprecated version of the QrScanner constructor which will be removed in the future")) : this._calculateScanRegion = n, this._scanRegion = this._calculateScanRegion(e), this._onPlay = this._onPlay.bind(this), this._onLoadedMetaData = this._onLoadedMetaData.bind(this), this._onVisibilityChange = this._onVisibilityChange.bind(this), e.disablePictureInPicture = !0, e.playsInline = !0, e.muted = !0;
            let i = !1;
            e.hidden && (e.hidden = !1, i = !0), document.body.contains(e) || (document.body.appendChild(e), i = !0), requestAnimationFrame((() => {
                const t = window.getComputedStyle(e);
                "none" === t.display && (e.style.setProperty("display", "block", "important"), i = !0), "visible" !== t.visibility && (e.style.setProperty("visibility", "visible", "important"), i = !0), i && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), e.style.opacity = 0, e.style.width = 0, e.style.height = 0)
            })), e.addEventListener("play", this._onPlay), e.addEventListener("loadedmetadata", this._onLoadedMetaData), document.addEventListener("visibilitychange", this._onVisibilityChange), this._qrEnginePromise = QrScanner.createQrEngine()
        }
        hasFlash() {
            let e = null;
            return (this.$video.srcObject ? Promise.resolve(this.$video.srcObject.getVideoTracks()[0]) : this._getCameraStream().then((({
                stream: t
            }) => (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), e = t, t.getVideoTracks()[0])))).then((e => "torch" in e.getSettings())).catch((() => !1)).finally((() => {
                if (e)
                    for (const t of e.getTracks()) t.stop(), e.removeTrack(t)
            }))
        }
        isFlashOn() {
            return this._flashOn
        }
        toggleFlash() {
            return this._flashOn ? this.turnFlashOff() : this.turnFlashOn()
        }
        turnFlashOn() {
            return this._flashOn ? Promise.resolve() : (this._flashOn = !0, !this._active || this._paused ? Promise.resolve() : this.hasFlash().then((e => e ? this.$video.srcObject.getVideoTracks()[0].applyConstraints({
                advanced: [{
                    torch: !0
                }]
            }) : Promise.reject("No flash available"))).catch((() => {
                throw this._flashOn = !1, e
            })))
        }
        turnFlashOff() {
            if (this._flashOn) return this._flashOn = !1, this._restartVideoStream()
        }
        destroy() {
            this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData), this.$video.removeEventListener("play", this._onPlay), document.removeEventListener("visibilitychange", this._onVisibilityChange), this.stop(), QrScanner._postWorkerMessage(this._qrEnginePromise, "close")
        }
        start() {
            return this._active && !this._paused ? Promise.resolve() : ("https:" !== window.location.protocol && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = !0, document.hidden ? Promise.resolve() : (this._paused = !1, this.$video.srcObject ? (this.$video.play(), Promise.resolve()) : this._getCameraStream().then((({
                stream: e,
                facingMode: t
            }) => {
                this.$video.srcObject = e, this.$video.play(), this._setVideoMirror(t), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch((() => {})))
            })).catch((e => {
                throw this._active = !1, e
            }))))
        }
        stop() {
            this.pause(), this._active = !1
        }
        pause(e = !1) {
            if (this._paused = !0, !this._active) return Promise.resolve(!0);
            this.$video.pause();
            const t = () => {
                const e = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];
                for (const t of e) t.stop(), this.$video.srcObject.removeTrack(t);
                this.$video.srcObject = null
            };
            return e ? (t(), Promise.resolve(!0)) : new Promise((e => setTimeout(e, 300))).then((() => !!this._paused && (t(), !0)))
        }
        setCamera(e) {
            return e === this._preferredCamera ? Promise.resolve() : (this._preferredCamera = e, this._restartVideoStream())
        }
        static scanImage(e, t = null, r = null, n = null, s = !1, i = !1) {
            const a = r instanceof Worker;
            let o = Promise.all([r || QrScanner.createQrEngine(), QrScanner._loadImage(e)]).then((([e, i]) => {
                let o;
                return r = e, [n, o] = this._drawToCanvas(i, t, n, s), r instanceof Worker ? (a || r.postMessage({
                    type: "inversionMode",
                    data: "both"
                }), new Promise(((e, t) => {
                    let s, i, a;
                    i = n => {
                        "qrResult" === n.data.type && (r.removeEventListener("message", i), r.removeEventListener("error", a), clearTimeout(s), null !== n.data.data ? e(n.data.data) : t(QrScanner.NO_QR_CODE_FOUND))
                    }, a = e => {
                        r.removeEventListener("message", i), r.removeEventListener("error", a), clearTimeout(s);
                        const n = e ? e.message || e : "Unknown Error";
                        t("Scanner error: " + n)
                    }, r.addEventListener("message", i), r.addEventListener("error", a), s = setTimeout((() => a("timeout")), 1e4);
                    const l = o.getImageData(0, 0, n.width, n.height);
                    r.postMessage({
                        type: "decode",
                        data: l
                    }, [l.data.buffer])
                }))) : new Promise(((e, t) => {
                    const s = setTimeout((() => t("Scanner error: timeout")), 1e4);
                    r.detect(n).then((r => {
                        r.length ? e(r[0].rawValue) : t(QrScanner.NO_QR_CODE_FOUND)
                    })).catch((e => t("Scanner error: " + (e.message || e)))).finally((() => clearTimeout(s)))
                }))
            }));
            return t && i && (o = o.catch((() => QrScanner.scanImage(e, null, r, n, s)))), o = o.finally((() => {
                a || QrScanner._postWorkerMessage(r, "close")
            })), o
        }
        setGrayscaleWeights(e, t, r, n = !0) {
            QrScanner._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
                red: e,
                green: t,
                blue: r,
                useIntegerApproximation: n
            })
        }
        setInversionMode(e) {
            QrScanner._postWorkerMessage(this._qrEnginePromise, "inversionMode", e)
        }
        static createQrEngine(e = QrScanner.WORKER_PATH) {
            return ("BarcodeDetector" in window && BarcodeDetector.getSupportedFormats ? BarcodeDetector.getSupportedFormats() : Promise.resolve([])).then((t => -1 !== t.indexOf("qr_code") ? new BarcodeDetector({
                formats: ["qr_code"]
            }) : new Worker(e)))
        }
        _onPlay() {
            this._scanRegion = this._calculateScanRegion(this.$video), this._scanFrame()
        }
        _onLoadedMetaData() {
            this._scanRegion = this._calculateScanRegion(this.$video)
        }
        _onVisibilityChange() {
            document.hidden ? this.pause() : this._active && this.start()
        }
        _calculateScanRegion(e) {
            const t = Math.min(e.videoWidth, e.videoHeight),
                r = Math.round(2 / 3 * t);
            return {
                x: Math.round((e.videoWidth - r) / 2),
                y: Math.round((e.videoHeight - r) / 2),
                width: r,
                height: r,
                downScaledWidth: this._legacyCanvasSize,
                downScaledHeight: this._legacyCanvasSize
            }
        }
        _scanFrame() {
            if (!this._active || this.$video.paused || this.$video.ended) return !1;
            requestAnimationFrame((() => {
                this.$video.readyState <= 1 ? this._scanFrame() : this._qrEnginePromise.then((e => QrScanner.scanImage(this.$video, this._scanRegion, e, this.$canvas))).then(this._onDecode, (e => {
                    if (!this._active) return; - 1 !== (e.message || e).indexOf("service unavailable") && (this._qrEnginePromise = QrScanner.createQrEngine()), this._onDecodeError(e)
                })).then((() => this._scanFrame()))
            }))
        }
        _onDecodeError(e) {
            e !== QrScanner.NO_QR_CODE_FOUND && console.log(e)
        }
        _getCameraStream() {
            if (!navigator.mediaDevices) return Promise.reject("Camera not found.");
            const e = "environment" === this._preferredCamera || "user" === this._preferredCamera ? "facingMode" : "deviceId",
                t = [{
                    width: {
                        min: 1024
                    }
                }, {
                    width: {
                        min: 768
                    }
                }, {}];
            return [...t.map((t => Object.assign({}, t, {
                [e]: {
                    exact: this._preferredCamera
                }
            }))), ...t].reduceRight(((e, t) => () => navigator.mediaDevices.getUserMedia({
                video: t,
                audio: !1
            }).then((e => ({
                stream: e,
                facingMode: this._getFacingMode(e) || (t.facingMode ? this._preferredCamera : "environment" === this._preferredCamera ? "user" : "environment")
            }))).catch(e)), (() => Promise.reject("Camera not found.")))()
        }
        _restartVideoStream() {
            const e = this._paused;
            return this.pause(!0).then((t => {
                if (t && !e && this._active) return this.start()
            }))
        }
        _setVideoMirror(e) {
            const t = "user" === e ? -1 : 1;
            this.$video.style.transform = "scaleX(" + t + ")"
        }
        _getFacingMode(e) {
            const t = e.getVideoTracks()[0];
            return t ? /rear|back|environment/i.test(t.label) ? "environment" : /front|user|face/i.test(t.label) ? "user" : null : null
        }
        static _drawToCanvas(e, t = null, r = null, n = !1) {
            r = r || document.createElement("canvas");
            const s = t && t.x ? t.x : 0,
                i = t && t.y ? t.y : 0,
                a = t && t.width ? t.width : e.width || e.videoWidth,
                o = t && t.height ? t.height : e.height || e.videoHeight;
            if (!n) {
                const e = t && t.downScaledWidth ? t.downScaledWidth : a,
                    n = t && t.downScaledHeight ? t.downScaledHeight : o;
                r.width !== e && (r.width = e), r.height !== n && (r.height = n)
            }
            const l = r.getContext("2d", {
                alpha: !1
            });
            return l.imageSmoothingEnabled = !1, l.drawImage(e, s, i, a, o, 0, 0, r.width, r.height), [r, l]
        }
        static _loadImage(e) {
            if (e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || window.ImageBitmap && e instanceof window.ImageBitmap || window.OffscreenCanvas && e instanceof window.OffscreenCanvas) return Promise.resolve(e);
            if (e instanceof Image) return QrScanner._awaitImageLoad(e).then((() => e));
            if (e instanceof File || e instanceof Blob || e instanceof URL || "string" == typeof e) {
                const t = new Image;
                return e instanceof File || e instanceof Blob ? t.src = URL.createObjectURL(e) : t.src = e, QrScanner._awaitImageLoad(t).then((() => ((e instanceof File || e instanceof Blob) && URL.revokeObjectURL(t.src), t)))
            }
            return Promise.reject("Unsupported image type.")
        }
        static _awaitImageLoad(e) {
            return new Promise(((t, r) => {
                if (e.complete && 0 !== e.naturalWidth) t();
                else {
                    let n, s;
                    n = () => {
                        e.removeEventListener("load", n), e.removeEventListener("error", s), t()
                    }, s = () => {
                        e.removeEventListener("load", n), e.removeEventListener("error", s), r("Image load error")
                    }, e.addEventListener("load", n), e.addEventListener("error", s)
                }
            }))
        }
        static _postWorkerMessage(e, t, r) {
            return Promise.resolve(e).then((e => {
                e instanceof Worker && e.postMessage({
                    type: t,
                    data: r
                })
            }))
        }
    }
    QrScanner.DEFAULT_CANVAS_SIZE = 400, QrScanner.NO_QR_CODE_FOUND = "No QR code found", QrScanner.WORKER_PATH = "qr-scanner-worker.min.js";
    var global$1 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined")
    }

    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined")
    }
    var cachedSetTimeout = defaultSetTimout,
        cachedClearTimeout = defaultClearTimeout;

    function runTimeout(e) {
        if (cachedSetTimeout === setTimeout) return setTimeout(e, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(e, 0);
        try {
            return cachedSetTimeout(e, 0)
        } catch (t) {
            try {
                return cachedSetTimeout.call(null, e, 0)
            } catch (t) {
                return cachedSetTimeout.call(this, e, 0)
            }
        }
    }

    function runClearTimeout(e) {
        if (cachedClearTimeout === clearTimeout) return clearTimeout(e);
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(e);
        try {
            return cachedClearTimeout(e)
        } catch (t) {
            try {
                return cachedClearTimeout.call(null, e)
            } catch (t) {
                return cachedClearTimeout.call(this, e)
            }
        }
    }
    "function" == typeof global$1.setTimeout && (cachedSetTimeout = setTimeout), "function" == typeof global$1.clearTimeout && (cachedClearTimeout = clearTimeout);
    var queue = [],
        draining = !1,
        currentQueue, queueIndex = -1;

    function cleanUpNextTick() {
        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
    }

    function drainQueue() {
        if (!draining) {
            var e = runTimeout(cleanUpNextTick);
            draining = !0;
            for (var t = queue.length; t;) {
                for (currentQueue = queue, queue = []; ++queueIndex < t;) currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, t = queue.length
            }
            currentQueue = null, draining = !1, runClearTimeout(e)
        }
    }

    function nextTick(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
        queue.push(new Item(e, t)), 1 !== queue.length || draining || runTimeout(drainQueue)
    }

    function Item(e, t) {
        this.fun = e, this.array = t
    }
    Item.prototype.run = function() {
        this.fun.apply(null, this.array)
    };
    var title = "browser",
        platform = "browser",
        browser = !0,
        env = {},
        argv = [],
        version = "",
        versions = {},
        release = {},
        config = {};

    function noop() {}
    var on = noop,
        addListener = noop,
        once = noop,
        off = noop,
        removeListener = noop,
        removeAllListeners = noop,
        emit = noop;

    function binding(e) {
        throw new Error("process.binding is not supported")
    }

    function cwd() {
        return "/"
    }

    function chdir(e) {
        throw new Error("process.chdir is not supported")
    }

    function umask() {
        return 0
    }
    var performance = global$1.performance || {},
        performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
            return (new Date).getTime()
        };

    function hrtime(e) {
        var t = .001 * performanceNow.call(performance),
            r = Math.floor(t),
            n = Math.floor(t % 1 * 1e9);
        return e && (r -= e[0], (n -= e[1]) < 0 && (r--, n += 1e9)), [r, n]
    }
    var startTime = new Date;

    function uptime() {
        return (new Date - startTime) / 1e3
    }
    var process$1 = {
            nextTick: nextTick,
            title: title,
            browser: browser,
            env: env,
            argv: argv,
            version: version,
            versions: versions,
            on: on,
            addListener: addListener,
            once: once,
            off: off,
            removeListener: removeListener,
            removeAllListeners: removeAllListeners,
            emit: emit,
            binding: binding,
            cwd: cwd,
            chdir: chdir,
            umask: umask,
            hrtime: hrtime,
            platform: platform,
            release: release,
            config: config,
            uptime: uptime
        },
        lookup = [],
        revLookup = [],
        Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array,
        inited = !1;

    function init() {
        inited = !0;
        for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, r = e.length; t < r; ++t) lookup[t] = e[t], revLookup[e.charCodeAt(t)] = t;
        revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63
    }

    function toByteArray(e) {
        var t, r, n, s, i, a;
        inited || init();
        var o = e.length;
        if (o % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        i = "=" === e[o - 2] ? 2 : "=" === e[o - 1] ? 1 : 0, a = new Arr(3 * o / 4 - i), n = i > 0 ? o - 4 : o;
        var l = 0;
        for (t = 0, r = 0; t < n; t += 4, r += 3) s = revLookup[e.charCodeAt(t)] << 18 | revLookup[e.charCodeAt(t + 1)] << 12 | revLookup[e.charCodeAt(t + 2)] << 6 | revLookup[e.charCodeAt(t + 3)], a[l++] = s >> 16 & 255, a[l++] = s >> 8 & 255, a[l++] = 255 & s;
        return 2 === i ? (s = revLookup[e.charCodeAt(t)] << 2 | revLookup[e.charCodeAt(t + 1)] >> 4, a[l++] = 255 & s) : 1 === i && (s = revLookup[e.charCodeAt(t)] << 10 | revLookup[e.charCodeAt(t + 1)] << 4 | revLookup[e.charCodeAt(t + 2)] >> 2, a[l++] = s >> 8 & 255, a[l++] = 255 & s), a
    }

    function tripletToBase64(e) {
        return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[63 & e]
    }

    function encodeChunk(e, t, r) {
        for (var n, s = [], i = t; i < r; i += 3) n = (e[i] << 16) + (e[i + 1] << 8) + e[i + 2], s.push(tripletToBase64(n));
        return s.join("")
    }

    function fromByteArray(e) {
        var t;
        inited || init();
        for (var r = e.length, n = r % 3, s = "", i = [], a = 16383, o = 0, l = r - n; o < l; o += a) i.push(encodeChunk(e, o, o + a > l ? l : o + a));
        return 1 === n ? (t = e[r - 1], s += lookup[t >> 2], s += lookup[t << 4 & 63], s += "==") : 2 === n && (t = (e[r - 2] << 8) + e[r - 1], s += lookup[t >> 10], s += lookup[t >> 4 & 63], s += lookup[t << 2 & 63], s += "="), i.push(s), i.join("")
    }

    function read(e, t, r, n, s) {
        var i, a, o = 8 * s - n - 1,
            l = (1 << o) - 1,
            c = l >> 1,
            h = -7,
            u = r ? s - 1 : 0,
            d = r ? -1 : 1,
            f = e[t + u];
        for (u += d, i = f & (1 << -h) - 1, f >>= -h, h += o; h > 0; i = 256 * i + e[t + u], u += d, h -= 8);
        for (a = i & (1 << -h) - 1, i >>= -h, h += n; h > 0; a = 256 * a + e[t + u], u += d, h -= 8);
        if (0 === i) i = 1 - c;
        else {
            if (i === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
            a += Math.pow(2, n), i -= c
        }
        return (f ? -1 : 1) * a * Math.pow(2, i - n)
    }

    function write(e, t, r, n, s, i) {
        var a, o, l, c = 8 * i - s - 1,
            h = (1 << c) - 1,
            u = h >> 1,
            d = 23 === s ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            f = n ? 0 : i - 1,
            p = n ? 1 : -1,
            _ = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = h) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t += a + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (a++, l /= 2), a + u >= h ? (o = 0, a = h) : a + u >= 1 ? (o = (t * l - 1) * Math.pow(2, s), a += u) : (o = t * Math.pow(2, u - 1) * Math.pow(2, s), a = 0)); s >= 8; e[r + f] = 255 & o, f += p, o /= 256, s -= 8);
        for (a = a << s | o, c += s; c > 0; e[r + f] = 255 & a, f += p, a /= 256, c -= 8);
        e[r + f - p] |= 128 * _
    }
    var toString$2 = {}.toString,
        isArray = Array.isArray || function(e) {
            return "[object Array]" == toString$2.call(e)
        },
        INSPECT_MAX_BYTES = 50;

    function kMaxLength() {
        return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
    }

    function createBuffer(e, t) {
        if (kMaxLength() < t) throw new RangeError("Invalid typed array length");
        return Buffer.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = Buffer.prototype : (null === e && (e = new Buffer(t)), e.length = t), e
    }

    function Buffer(e, t, r) {
        if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer)) return new Buffer(e, t, r);
        if ("number" == typeof e) {
            if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
            return allocUnsafe(this, e)
        }
        return from(this, e, t, r)
    }

    function from(e, t, r, n) {
        if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? fromArrayBuffer(e, t, r, n) : "string" == typeof t ? fromString(e, t, r) : fromObject(e, t)
    }

    function assertSize(e) {
        if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
        if (e < 0) throw new RangeError('"size" argument must not be negative')
    }

    function alloc(e, t, r, n) {
        return assertSize(t), t <= 0 ? createBuffer(e, t) : void 0 !== r ? "string" == typeof n ? createBuffer(e, t).fill(r, n) : createBuffer(e, t).fill(r) : createBuffer(e, t)
    }

    function allocUnsafe(e, t) {
        if (assertSize(t), e = createBuffer(e, t < 0 ? 0 : 0 | checked(t)), !Buffer.TYPED_ARRAY_SUPPORT)
            for (var r = 0; r < t; ++r) e[r] = 0;
        return e
    }

    function fromString(e, t, r) {
        if ("string" == typeof r && "" !== r || (r = "utf8"), !Buffer.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
        var n = 0 | byteLength(t, r),
            s = (e = createBuffer(e, n)).write(t, r);
        return s !== n && (e = e.slice(0, s)), e
    }

    function fromArrayLike(e, t) {
        var r = t.length < 0 ? 0 : 0 | checked(t.length);
        e = createBuffer(e, r);
        for (var n = 0; n < r; n += 1) e[n] = 255 & t[n];
        return e
    }

    function fromArrayBuffer(e, t, r, n) {
        if (t.byteLength, r < 0 || t.byteLength < r) throw new RangeError("'offset' is out of bounds");
        if (t.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
        return t = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n), Buffer.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = Buffer.prototype : e = fromArrayLike(e, t), e
    }

    function fromObject(e, t) {
        if (internalIsBuffer(t)) {
            var r = 0 | checked(t.length);
            return 0 === (e = createBuffer(e, r)).length || t.copy(e, 0, 0, r), e
        }
        if (t) {
            if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || isnan(t.length) ? createBuffer(e, 0) : fromArrayLike(e, t);
            if ("Buffer" === t.type && isArray(t.data)) return fromArrayLike(e, t.data)
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
    }

    function checked(e) {
        if (e >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        return 0 | e
    }

    function internalIsBuffer(e) {
        return !(null == e || !e._isBuffer)
    }

    function byteLength(e, t) {
        if (internalIsBuffer(e)) return e.length;
        if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
        "string" != typeof e && (e = "" + e);
        var r = e.length;
        if (0 === r) return 0;
        for (var n = !1;;) switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
                return r;
            case "utf8":
            case "utf-8":
            case void 0:
                return utf8ToBytes(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return 2 * r;
            case "hex":
                return r >>> 1;
            case "base64":
                return base64ToBytes(e).length;
            default:
                if (n) return utf8ToBytes(e).length;
                t = ("" + t).toLowerCase(), n = !0
        }
    }

    function slowToString(e, t, r) {
        var n = !1;
        if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
        if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
        if ((r >>>= 0) <= (t >>>= 0)) return "";
        for (e || (e = "utf8");;) switch (e) {
            case "hex":
                return hexSlice(this, t, r);
            case "utf8":
            case "utf-8":
                return utf8Slice(this, t, r);
            case "ascii":
                return asciiSlice(this, t, r);
            case "latin1":
            case "binary":
                return latin1Slice(this, t, r);
            case "base64":
                return base64Slice(this, t, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return utf16leSlice(this, t, r);
            default:
                if (n) throw new TypeError("Unknown encoding: " + e);
                e = (e + "").toLowerCase(), n = !0
        }
    }

    function swap(e, t, r) {
        var n = e[t];
        e[t] = e[r], e[r] = n
    }

    function bidirectionalIndexOf(e, t, r, n, s) {
        if (0 === e.length) return -1;
        if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = s ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
            if (s) return -1;
            r = e.length - 1
        } else if (r < 0) {
            if (!s) return -1;
            r = 0
        }
        if ("string" == typeof t && (t = Buffer.from(t, n)), internalIsBuffer(t)) return 0 === t.length ? -1 : arrayIndexOf(e, t, r, n, s);
        if ("number" == typeof t) return t &= 255, Buffer.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? s ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : arrayIndexOf(e, [t], r, n, s);
        throw new TypeError("val must be string, number or Buffer")
    }

    function arrayIndexOf(e, t, r, n, s) {
        var i, a = 1,
            o = e.length,
            l = t.length;
        if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
            if (e.length < 2 || t.length < 2) return -1;
            a = 2, o /= 2, l /= 2, r /= 2
        }

        function c(e, t) {
            return 1 === a ? e[t] : e.readUInt16BE(t * a)
        }
        if (s) {
            var h = -1;
            for (i = r; i < o; i++)
                if (c(e, i) === c(t, -1 === h ? 0 : i - h)) {
                    if (-1 === h && (h = i), i - h + 1 === l) return h * a
                } else -1 !== h && (i -= i - h), h = -1
        } else
            for (r + l > o && (r = o - l), i = r; i >= 0; i--) {
                for (var u = !0, d = 0; d < l; d++)
                    if (c(e, i + d) !== c(t, d)) {
                        u = !1;
                        break
                    } if (u) return i
            }
        return -1
    }

    function hexWrite(e, t, r, n) {
        r = Number(r) || 0;
        var s = e.length - r;
        n ? (n = Number(n)) > s && (n = s) : n = s;
        var i = t.length;
        if (i % 2 != 0) throw new TypeError("Invalid hex string");
        n > i / 2 && (n = i / 2);
        for (var a = 0; a < n; ++a) {
            var o = parseInt(t.substr(2 * a, 2), 16);
            if (isNaN(o)) return a;
            e[r + a] = o
        }
        return a
    }

    function utf8Write(e, t, r, n) {
        return blitBuffer(utf8ToBytes(t, e.length - r), e, r, n)
    }

    function asciiWrite(e, t, r, n) {
        return blitBuffer(asciiToBytes(t), e, r, n)
    }

    function latin1Write(e, t, r, n) {
        return asciiWrite(e, t, r, n)
    }

    function base64Write(e, t, r, n) {
        return blitBuffer(base64ToBytes(t), e, r, n)
    }

    function ucs2Write(e, t, r, n) {
        return blitBuffer(utf16leToBytes(t, e.length - r), e, r, n)
    }

    function base64Slice(e, t, r) {
        return 0 === t && r === e.length ? fromByteArray(e) : fromByteArray(e.slice(t, r))
    }

    function utf8Slice(e, t, r) {
        r = Math.min(e.length, r);
        for (var n = [], s = t; s < r;) {
            var i, a, o, l, c = e[s],
                h = null,
                u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
            if (s + u <= r) switch (u) {
                case 1:
                    c < 128 && (h = c);
                    break;
                case 2:
                    128 == (192 & (i = e[s + 1])) && (l = (31 & c) << 6 | 63 & i) > 127 && (h = l);
                    break;
                case 3:
                    i = e[s + 1], a = e[s + 2], 128 == (192 & i) && 128 == (192 & a) && (l = (15 & c) << 12 | (63 & i) << 6 | 63 & a) > 2047 && (l < 55296 || l > 57343) && (h = l);
                    break;
                case 4:
                    i = e[s + 1], a = e[s + 2], o = e[s + 3], 128 == (192 & i) && 128 == (192 & a) && 128 == (192 & o) && (l = (15 & c) << 18 | (63 & i) << 12 | (63 & a) << 6 | 63 & o) > 65535 && l < 1114112 && (h = l)
            }
            null === h ? (h = 65533, u = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n.push(h), s += u
        }
        return decodeCodePointsArray(n)
    }
    Buffer.TYPED_ARRAY_SUPPORT = void 0 === global$1.TYPED_ARRAY_SUPPORT || global$1.TYPED_ARRAY_SUPPORT, Buffer.poolSize = 8192, Buffer._augment = function(e) {
        return e.__proto__ = Buffer.prototype, e
    }, Buffer.from = function(e, t, r) {
        return from(null, e, t, r)
    }, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array), Buffer.alloc = function(e, t, r) {
        return alloc(null, e, t, r)
    }, Buffer.allocUnsafe = function(e) {
        return allocUnsafe(null, e)
    }, Buffer.allocUnsafeSlow = function(e) {
        return allocUnsafe(null, e)
    }, Buffer.isBuffer = isBuffer, Buffer.compare = function(e, t) {
        if (!internalIsBuffer(e) || !internalIsBuffer(t)) throw new TypeError("Arguments must be Buffers");
        if (e === t) return 0;
        for (var r = e.length, n = t.length, s = 0, i = Math.min(r, n); s < i; ++s)
            if (e[s] !== t[s]) {
                r = e[s], n = t[s];
                break
            } return r < n ? -1 : n < r ? 1 : 0
    }, Buffer.isEncoding = function(e) {
        switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, Buffer.concat = function(e, t) {
        if (!isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === e.length) return Buffer.alloc(0);
        var r;
        if (void 0 === t)
            for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
        var n = Buffer.allocUnsafe(t),
            s = 0;
        for (r = 0; r < e.length; ++r) {
            var i = e[r];
            if (!internalIsBuffer(i)) throw new TypeError('"list" argument must be an Array of Buffers');
            i.copy(n, s), s += i.length
        }
        return n
    }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
        var e = this.length;
        if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t = 0; t < e; t += 2) swap(this, t, t + 1);
        return this
    }, Buffer.prototype.swap32 = function() {
        var e = this.length;
        if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t = 0; t < e; t += 4) swap(this, t, t + 3), swap(this, t + 1, t + 2);
        return this
    }, Buffer.prototype.swap64 = function() {
        var e = this.length;
        if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t = 0; t < e; t += 8) swap(this, t, t + 7), swap(this, t + 1, t + 6), swap(this, t + 2, t + 5), swap(this, t + 3, t + 4);
        return this
    }, Buffer.prototype.toString = function() {
        var e = 0 | this.length;
        return 0 === e ? "" : 0 === arguments.length ? utf8Slice(this, 0, e) : slowToString.apply(this, arguments)
    }, Buffer.prototype.equals = function(e) {
        if (!internalIsBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e || 0 === Buffer.compare(this, e)
    }, Buffer.prototype.inspect = function() {
        var e = "",
            t = INSPECT_MAX_BYTES;
        return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">"
    }, Buffer.prototype.compare = function(e, t, r, n, s) {
        if (!internalIsBuffer(e)) throw new TypeError("Argument must be a Buffer");
        if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === s && (s = this.length), t < 0 || r > e.length || n < 0 || s > this.length) throw new RangeError("out of range index");
        if (n >= s && t >= r) return 0;
        if (n >= s) return -1;
        if (t >= r) return 1;
        if (this === e) return 0;
        for (var i = (s >>>= 0) - (n >>>= 0), a = (r >>>= 0) - (t >>>= 0), o = Math.min(i, a), l = this.slice(n, s), c = e.slice(t, r), h = 0; h < o; ++h)
            if (l[h] !== c[h]) {
                i = l[h], a = c[h];
                break
            } return i < a ? -1 : a < i ? 1 : 0
    }, Buffer.prototype.includes = function(e, t, r) {
        return -1 !== this.indexOf(e, t, r)
    }, Buffer.prototype.indexOf = function(e, t, r) {
        return bidirectionalIndexOf(this, e, t, r, !0)
    }, Buffer.prototype.lastIndexOf = function(e, t, r) {
        return bidirectionalIndexOf(this, e, t, r, !1)
    }, Buffer.prototype.write = function(e, t, r, n) {
        if (void 0 === t) n = "utf8", r = this.length, t = 0;
        else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;
        else {
            if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
        }
        var s = this.length - t;
        if ((void 0 === r || r > s) && (r = s), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        for (var i = !1;;) switch (n) {
            case "hex":
                return hexWrite(this, e, t, r);
            case "utf8":
            case "utf-8":
                return utf8Write(this, e, t, r);
            case "ascii":
                return asciiWrite(this, e, t, r);
            case "latin1":
            case "binary":
                return latin1Write(this, e, t, r);
            case "base64":
                return base64Write(this, e, t, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ucs2Write(this, e, t, r);
            default:
                if (i) throw new TypeError("Unknown encoding: " + n);
                n = ("" + n).toLowerCase(), i = !0
        }
    }, Buffer.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };
    var MAX_ARGUMENTS_LENGTH = 4096;

    function decodeCodePointsArray(e) {
        var t = e.length;
        if (t <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, e);
        for (var r = "", n = 0; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += MAX_ARGUMENTS_LENGTH));
        return r
    }

    function asciiSlice(e, t, r) {
        var n = "";
        r = Math.min(e.length, r);
        for (var s = t; s < r; ++s) n += String.fromCharCode(127 & e[s]);
        return n
    }

    function latin1Slice(e, t, r) {
        var n = "";
        r = Math.min(e.length, r);
        for (var s = t; s < r; ++s) n += String.fromCharCode(e[s]);
        return n
    }

    function hexSlice(e, t, r) {
        var n = e.length;
        (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
        for (var s = "", i = t; i < r; ++i) s += toHex(e[i]);
        return s
    }

    function utf16leSlice(e, t, r) {
        for (var n = e.slice(t, r), s = "", i = 0; i < n.length; i += 2) s += String.fromCharCode(n[i] + 256 * n[i + 1]);
        return s
    }

    function checkOffset(e, t, r) {
        if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
        if (e + t > r) throw new RangeError("Trying to access beyond buffer length")
    }

    function checkInt(e, t, r, n, s, i) {
        if (!internalIsBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t > s || t < i) throw new RangeError('"value" argument is out of bounds');
        if (r + n > e.length) throw new RangeError("Index out of range")
    }

    function objectWriteUInt16(e, t, r, n) {
        t < 0 && (t = 65535 + t + 1);
        for (var s = 0, i = Math.min(e.length - r, 2); s < i; ++s) e[r + s] = (t & 255 << 8 * (n ? s : 1 - s)) >>> 8 * (n ? s : 1 - s)
    }

    function objectWriteUInt32(e, t, r, n) {
        t < 0 && (t = 4294967295 + t + 1);
        for (var s = 0, i = Math.min(e.length - r, 4); s < i; ++s) e[r + s] = t >>> 8 * (n ? s : 3 - s) & 255
    }

    function checkIEEE754(e, t, r, n, s, i) {
        if (r + n > e.length) throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("Index out of range")
    }

    function writeFloat(e, t, r, n, s) {
        return s || checkIEEE754(e, t, r, 4), write(e, t, r, n, 23, 4), r + 4
    }

    function writeDouble(e, t, r, n, s) {
        return s || checkIEEE754(e, t, r, 8), write(e, t, r, n, 52, 8), r + 8
    }
    Buffer.prototype.slice = function(e, t) {
        var r, n = this.length;
        if ((e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), Buffer.TYPED_ARRAY_SUPPORT)(r = this.subarray(e, t)).__proto__ = Buffer.prototype;
        else {
            var s = t - e;
            r = new Buffer(s, void 0);
            for (var i = 0; i < s; ++i) r[i] = this[i + e]
        }
        return r
    }, Buffer.prototype.readUIntLE = function(e, t, r) {
        e |= 0, t |= 0, r || checkOffset(e, t, this.length);
        for (var n = this[e], s = 1, i = 0; ++i < t && (s *= 256);) n += this[e + i] * s;
        return n
    }, Buffer.prototype.readUIntBE = function(e, t, r) {
        e |= 0, t |= 0, r || checkOffset(e, t, this.length);
        for (var n = this[e + --t], s = 1; t > 0 && (s *= 256);) n += this[e + --t] * s;
        return n
    }, Buffer.prototype.readUInt8 = function(e, t) {
        return t || checkOffset(e, 1, this.length), this[e]
    }, Buffer.prototype.readUInt16LE = function(e, t) {
        return t || checkOffset(e, 2, this.length), this[e] | this[e + 1] << 8
    }, Buffer.prototype.readUInt16BE = function(e, t) {
        return t || checkOffset(e, 2, this.length), this[e] << 8 | this[e + 1]
    }, Buffer.prototype.readUInt32LE = function(e, t) {
        return t || checkOffset(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
    }, Buffer.prototype.readUInt32BE = function(e, t) {
        return t || checkOffset(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
    }, Buffer.prototype.readIntLE = function(e, t, r) {
        e |= 0, t |= 0, r || checkOffset(e, t, this.length);
        for (var n = this[e], s = 1, i = 0; ++i < t && (s *= 256);) n += this[e + i] * s;
        return n >= (s *= 128) && (n -= Math.pow(2, 8 * t)), n
    }, Buffer.prototype.readIntBE = function(e, t, r) {
        e |= 0, t |= 0, r || checkOffset(e, t, this.length);
        for (var n = t, s = 1, i = this[e + --n]; n > 0 && (s *= 256);) i += this[e + --n] * s;
        return i >= (s *= 128) && (i -= Math.pow(2, 8 * t)), i
    }, Buffer.prototype.readInt8 = function(e, t) {
        return t || checkOffset(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
    }, Buffer.prototype.readInt16LE = function(e, t) {
        t || checkOffset(e, 2, this.length);
        var r = this[e] | this[e + 1] << 8;
        return 32768 & r ? 4294901760 | r : r
    }, Buffer.prototype.readInt16BE = function(e, t) {
        t || checkOffset(e, 2, this.length);
        var r = this[e + 1] | this[e] << 8;
        return 32768 & r ? 4294901760 | r : r
    }, Buffer.prototype.readInt32LE = function(e, t) {
        return t || checkOffset(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
    }, Buffer.prototype.readInt32BE = function(e, t) {
        return t || checkOffset(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
    }, Buffer.prototype.readFloatLE = function(e, t) {
        return t || checkOffset(e, 4, this.length), read(this, e, !0, 23, 4)
    }, Buffer.prototype.readFloatBE = function(e, t) {
        return t || checkOffset(e, 4, this.length), read(this, e, !1, 23, 4)
    }, Buffer.prototype.readDoubleLE = function(e, t) {
        return t || checkOffset(e, 8, this.length), read(this, e, !0, 52, 8)
    }, Buffer.prototype.readDoubleBE = function(e, t) {
        return t || checkOffset(e, 8, this.length), read(this, e, !1, 52, 8)
    }, Buffer.prototype.writeUIntLE = function(e, t, r, n) {
        (e = +e, t |= 0, r |= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
        var s = 1,
            i = 0;
        for (this[t] = 255 & e; ++i < r && (s *= 256);) this[t + i] = e / s & 255;
        return t + r
    }, Buffer.prototype.writeUIntBE = function(e, t, r, n) {
        (e = +e, t |= 0, r |= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
        var s = r - 1,
            i = 1;
        for (this[t + s] = 255 & e; --s >= 0 && (i *= 256);) this[t + s] = e / i & 255;
        return t + r
    }, Buffer.prototype.writeUInt8 = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1
    }, Buffer.prototype.writeUInt16LE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : objectWriteUInt16(this, e, t, !0), t + 2
    }, Buffer.prototype.writeUInt16BE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : objectWriteUInt16(this, e, t, !1), t + 2
    }, Buffer.prototype.writeUInt32LE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : objectWriteUInt32(this, e, t, !0), t + 4
    }, Buffer.prototype.writeUInt32BE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : objectWriteUInt32(this, e, t, !1), t + 4
    }, Buffer.prototype.writeIntLE = function(e, t, r, n) {
        if (e = +e, t |= 0, !n) {
            var s = Math.pow(2, 8 * r - 1);
            checkInt(this, e, t, r, s - 1, -s)
        }
        var i = 0,
            a = 1,
            o = 0;
        for (this[t] = 255 & e; ++i < r && (a *= 256);) e < 0 && 0 === o && 0 !== this[t + i - 1] && (o = 1), this[t + i] = (e / a >> 0) - o & 255;
        return t + r
    }, Buffer.prototype.writeIntBE = function(e, t, r, n) {
        if (e = +e, t |= 0, !n) {
            var s = Math.pow(2, 8 * r - 1);
            checkInt(this, e, t, r, s - 1, -s)
        }
        var i = r - 1,
            a = 1,
            o = 0;
        for (this[t + i] = 255 & e; --i >= 0 && (a *= 256);) e < 0 && 0 === o && 0 !== this[t + i + 1] && (o = 1), this[t + i] = (e / a >> 0) - o & 255;
        return t + r
    }, Buffer.prototype.writeInt8 = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
    }, Buffer.prototype.writeInt16LE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : objectWriteUInt16(this, e, t, !0), t + 2
    }, Buffer.prototype.writeInt16BE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : objectWriteUInt16(this, e, t, !1), t + 2
    }, Buffer.prototype.writeInt32LE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : objectWriteUInt32(this, e, t, !0), t + 4
    }, Buffer.prototype.writeInt32BE = function(e, t, r) {
        return e = +e, t |= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : objectWriteUInt32(this, e, t, !1), t + 4
    }, Buffer.prototype.writeFloatLE = function(e, t, r) {
        return writeFloat(this, e, t, !0, r)
    }, Buffer.prototype.writeFloatBE = function(e, t, r) {
        return writeFloat(this, e, t, !1, r)
    }, Buffer.prototype.writeDoubleLE = function(e, t, r) {
        return writeDouble(this, e, t, !0, r)
    }, Buffer.prototype.writeDoubleBE = function(e, t, r) {
        return writeDouble(this, e, t, !1, r)
    }, Buffer.prototype.copy = function(e, t, r, n) {
        if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
        if (0 === e.length || 0 === this.length) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
        var s, i = n - r;
        if (this === e && r < t && t < n)
            for (s = i - 1; s >= 0; --s) e[s + t] = this[s + r];
        else if (i < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
            for (s = 0; s < i; ++s) e[s + t] = this[s + r];
        else Uint8Array.prototype.set.call(e, this.subarray(r, r + i), t);
        return i
    }, Buffer.prototype.fill = function(e, t, r, n) {
        if ("string" == typeof e) {
            if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === e.length) {
                var s = e.charCodeAt(0);
                s < 256 && (e = s)
            }
            if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
            if ("string" == typeof n && !Buffer.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
        } else "number" == typeof e && (e &= 255);
        if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
        if (r <= t) return this;
        var i;
        if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e)
            for (i = t; i < r; ++i) this[i] = e;
        else {
            var a = internalIsBuffer(e) ? e : utf8ToBytes(new Buffer(e, n).toString()),
                o = a.length;
            for (i = 0; i < r - t; ++i) this[i + t] = a[i % o]
        }
        return this
    };
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(e) {
        if ((e = stringtrim(e).replace(INVALID_BASE64_RE, "")).length < 2) return "";
        for (; e.length % 4 != 0;) e += "=";
        return e
    }

    function stringtrim(e) {
        return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
    }

    function toHex(e) {
        return e < 16 ? "0" + e.toString(16) : e.toString(16)
    }

    function utf8ToBytes(e, t) {
        var r;
        t = t || 1 / 0;
        for (var n = e.length, s = null, i = [], a = 0; a < n; ++a) {
            if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
                if (!s) {
                    if (r > 56319) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue
                    }
                    if (a + 1 === n) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue
                    }
                    s = r;
                    continue
                }
                if (r < 56320) {
                    (t -= 3) > -1 && i.push(239, 191, 189), s = r;
                    continue
                }
                r = 65536 + (s - 55296 << 10 | r - 56320)
            } else s && (t -= 3) > -1 && i.push(239, 191, 189);
            if (s = null, r < 128) {
                if ((t -= 1) < 0) break;
                i.push(r)
            } else if (r < 2048) {
                if ((t -= 2) < 0) break;
                i.push(r >> 6 | 192, 63 & r | 128)
            } else if (r < 65536) {
                if ((t -= 3) < 0) break;
                i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
            } else {
                if (!(r < 1114112)) throw new Error("Invalid code point");
                if ((t -= 4) < 0) break;
                i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
            }
        }
        return i
    }

    function asciiToBytes(e) {
        for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
        return t
    }

    function utf16leToBytes(e, t) {
        for (var r, n, s, i = [], a = 0; a < e.length && !((t -= 2) < 0); ++a) n = (r = e.charCodeAt(a)) >> 8, s = r % 256, i.push(s), i.push(n);
        return i
    }

    function base64ToBytes(e) {
        return toByteArray(base64clean(e))
    }

    function blitBuffer(e, t, r, n) {
        for (var s = 0; s < n && !(s + r >= t.length || s >= e.length); ++s) t[s + r] = e[s];
        return s
    }

    function isnan(e) {
        return e != e
    }

    function isBuffer(e) {
        return null != e && (!!e._isBuffer || isFastBuffer(e) || isSlowBuffer(e))
    }

    function isFastBuffer(e) {
        return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
    }

    function isSlowBuffer(e) {
        return "function" == typeof e.readFloatLE && "function" == typeof e.slice && isFastBuffer(e.slice(0, 0))
    }
    var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")
    }

    function unwrapExports(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }

    function createCommonjsModule(e, t) {
        return e(t = {
            exports: {}
        }, t.exports), t.exports
    }
    var require$$4 = {},
        pdf = createCommonjsModule((function(module, exports) {
            /**
             * @licstart The following is the entire license notice for the
             * Javascript code in this page
             *
             * Copyright 2020 Mozilla Foundation
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             *
             * @licend The above is the entire license notice for the
             * Javascript code in this page
             */
            var factory;
            factory = function() {
                return function(e) {
                    var t = {};

                    function r(n) {
                        if (t[n]) return t[n].exports;
                        var s = t[n] = {
                            i: n,
                            l: !1,
                            exports: {}
                        };
                        return e[n].call(s.exports, s, s.exports, r), s.l = !0, s.exports
                    }
                    return r.m = e, r.c = t, r.d = function(e, t, n) {
                        r.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: n
                        })
                    }, r.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }), Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }, r.t = function(e, t) {
                        if (1 & t && (e = r(e)), 8 & t) return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                        var n = Object.create(null);
                        if (r.r(n), Object.defineProperty(n, "default", {
                                enumerable: !0,
                                value: e
                            }), 2 & t && "string" != typeof e)
                            for (var s in e) r.d(n, s, function(t) {
                                return e[t]
                            }.bind(null, s));
                        return n
                    }, r.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        } : function() {
                            return e
                        };
                        return r.d(t, "a", t), t
                    }, r.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }, r.p = "", r(r.s = 0)
                }([function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), Object.defineProperty(t, "addLinkAttributes", {
                        enumerable: !0,
                        get: function() {
                            return n.addLinkAttributes
                        }
                    }), Object.defineProperty(t, "getFilenameFromUrl", {
                        enumerable: !0,
                        get: function() {
                            return n.getFilenameFromUrl
                        }
                    }), Object.defineProperty(t, "LinkTarget", {
                        enumerable: !0,
                        get: function() {
                            return n.LinkTarget
                        }
                    }), Object.defineProperty(t, "loadScript", {
                        enumerable: !0,
                        get: function() {
                            return n.loadScript
                        }
                    }), Object.defineProperty(t, "PDFDateString", {
                        enumerable: !0,
                        get: function() {
                            return n.PDFDateString
                        }
                    }), Object.defineProperty(t, "RenderingCancelledException", {
                        enumerable: !0,
                        get: function() {
                            return n.RenderingCancelledException
                        }
                    }), Object.defineProperty(t, "build", {
                        enumerable: !0,
                        get: function() {
                            return s.build
                        }
                    }), Object.defineProperty(t, "getDocument", {
                        enumerable: !0,
                        get: function() {
                            return s.getDocument
                        }
                    }), Object.defineProperty(t, "LoopbackPort", {
                        enumerable: !0,
                        get: function() {
                            return s.LoopbackPort
                        }
                    }), Object.defineProperty(t, "PDFDataRangeTransport", {
                        enumerable: !0,
                        get: function() {
                            return s.PDFDataRangeTransport
                        }
                    }), Object.defineProperty(t, "PDFWorker", {
                        enumerable: !0,
                        get: function() {
                            return s.PDFWorker
                        }
                    }), Object.defineProperty(t, "version", {
                        enumerable: !0,
                        get: function() {
                            return s.version
                        }
                    }), Object.defineProperty(t, "CMapCompressionType", {
                        enumerable: !0,
                        get: function() {
                            return i.CMapCompressionType
                        }
                    }), Object.defineProperty(t, "createObjectURL", {
                        enumerable: !0,
                        get: function() {
                            return i.createObjectURL
                        }
                    }), Object.defineProperty(t, "createPromiseCapability", {
                        enumerable: !0,
                        get: function() {
                            return i.createPromiseCapability
                        }
                    }), Object.defineProperty(t, "createValidAbsoluteUrl", {
                        enumerable: !0,
                        get: function() {
                            return i.createValidAbsoluteUrl
                        }
                    }), Object.defineProperty(t, "InvalidPDFException", {
                        enumerable: !0,
                        get: function() {
                            return i.InvalidPDFException
                        }
                    }), Object.defineProperty(t, "MissingPDFException", {
                        enumerable: !0,
                        get: function() {
                            return i.MissingPDFException
                        }
                    }), Object.defineProperty(t, "OPS", {
                        enumerable: !0,
                        get: function() {
                            return i.OPS
                        }
                    }), Object.defineProperty(t, "PasswordResponses", {
                        enumerable: !0,
                        get: function() {
                            return i.PasswordResponses
                        }
                    }), Object.defineProperty(t, "PermissionFlag", {
                        enumerable: !0,
                        get: function() {
                            return i.PermissionFlag
                        }
                    }), Object.defineProperty(t, "removeNullCharacters", {
                        enumerable: !0,
                        get: function() {
                            return i.removeNullCharacters
                        }
                    }), Object.defineProperty(t, "shadow", {
                        enumerable: !0,
                        get: function() {
                            return i.shadow
                        }
                    }), Object.defineProperty(t, "UnexpectedResponseException", {
                        enumerable: !0,
                        get: function() {
                            return i.UnexpectedResponseException
                        }
                    }), Object.defineProperty(t, "UNSUPPORTED_FEATURES", {
                        enumerable: !0,
                        get: function() {
                            return i.UNSUPPORTED_FEATURES
                        }
                    }), Object.defineProperty(t, "Util", {
                        enumerable: !0,
                        get: function() {
                            return i.Util
                        }
                    }), Object.defineProperty(t, "VerbosityLevel", {
                        enumerable: !0,
                        get: function() {
                            return i.VerbosityLevel
                        }
                    }), Object.defineProperty(t, "AnnotationLayer", {
                        enumerable: !0,
                        get: function() {
                            return a.AnnotationLayer
                        }
                    }), Object.defineProperty(t, "apiCompatibilityParams", {
                        enumerable: !0,
                        get: function() {
                            return o.apiCompatibilityParams
                        }
                    }), Object.defineProperty(t, "GlobalWorkerOptions", {
                        enumerable: !0,
                        get: function() {
                            return l.GlobalWorkerOptions
                        }
                    }), Object.defineProperty(t, "renderTextLayer", {
                        enumerable: !0,
                        get: function() {
                            return c.renderTextLayer
                        }
                    }), Object.defineProperty(t, "SVGGraphics", {
                        enumerable: !0,
                        get: function() {
                            return h.SVGGraphics
                        }
                    });
                    var n = r(1),
                        s = r(5),
                        i = r(2),
                        a = r(16),
                        o = r(7),
                        l = r(10),
                        c = r(17),
                        h = r(18); {
                        const {
                            isNodeJS: e
                        } = r(4);
                        if (e) {
                            const e = r(19).PDFNodeStream;
                            (0, s.setPDFNetworkStreamFactory)((t => new e(t)))
                        } else {
                            const e = r(22).PDFNetworkStream;
                            let t;
                            (0, n.isFetchSupported)() && (t = r(23).PDFFetchStream), (0, s.setPDFNetworkStreamFactory)((r => t && (0, n.isValidFetchUrl)(r.url) ? new t(r) : new e(r)))
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.addLinkAttributes = function(e, {
                        url: t,
                        target: r,
                        rel: i,
                        enabled: a = !0
                    } = {}) {
                        (0, n.assert)(t && "string" == typeof t, 'addLinkAttributes: A valid "url" parameter must provided.');
                        const o = (0, n.removeNullCharacters)(t);
                        a ? e.href = e.title = o : (e.href = "", e.title = `Disabled: ${o}`, e.onclick = () => !1);
                        let c = "";
                        switch (r) {
                            case l.NONE:
                                break;
                            case l.SELF:
                                c = "_self";
                                break;
                            case l.BLANK:
                                c = "_blank";
                                break;
                            case l.PARENT:
                                c = "_parent";
                                break;
                            case l.TOP:
                                c = "_top"
                        }
                        e.target = c, e.rel = "string" == typeof i ? i : s
                    }, t.getFilenameFromUrl = function(e) {
                        const t = e.indexOf("#"),
                            r = e.indexOf("?"),
                            n = Math.min(t > 0 ? t : e.length, r > 0 ? r : e.length);
                        return e.substring(e.lastIndexOf("/", n) + 1, n)
                    }, t.isFetchSupported = c, t.isValidFetchUrl = h, t.loadScript = function(e) {
                        return new Promise(((t, r) => {
                            const n = document.createElement("script");
                            n.src = e, n.onload = t, n.onerror = function() {
                                r(new Error(`Cannot load script at: ${n.src}`))
                            }, (document.head || document.documentElement).appendChild(n)
                        }))
                    }, t.deprecated = function(e) {
                        console.log("Deprecated API usage: " + e)
                    }, t.PDFDateString = t.StatTimer = t.DOMSVGFactory = t.DOMCMapReaderFactory = t.DOMCanvasFactory = t.DEFAULT_LINK_REL = t.LinkTarget = t.RenderingCancelledException = t.PageViewport = void 0;
                    var n = r(2);
                    const s = "noopener noreferrer nofollow";
                    t.DEFAULT_LINK_REL = s;
                    const i = "http://www.w3.org/2000/svg";
                    t.DOMCanvasFactory = class {
                        create(e, t) {
                            if (e <= 0 || t <= 0) throw new Error("Invalid canvas size");
                            const r = document.createElement("canvas"),
                                n = r.getContext("2d");
                            return r.width = e, r.height = t, {
                                canvas: r,
                                context: n
                            }
                        }
                        reset(e, t, r) {
                            if (!e.canvas) throw new Error("Canvas is not specified");
                            if (t <= 0 || r <= 0) throw new Error("Invalid canvas size");
                            e.canvas.width = t, e.canvas.height = r
                        }
                        destroy(e) {
                            if (!e.canvas) throw new Error("Canvas is not specified");
                            e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null
                        }
                    }, t.DOMCMapReaderFactory = class {
                        constructor({
                            baseUrl: e = null,
                            isCompressed: t = !1
                        }) {
                            this.baseUrl = e, this.isCompressed = t
                        }
                        async fetch({
                            name: e
                        }) {
                            if (!this.baseUrl) throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                            if (!e) throw new Error("CMap name must be specified.");
                            const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : ""),
                                r = this.isCompressed ? n.CMapCompressionType.BINARY : n.CMapCompressionType.NONE;
                            return c() && h(t, document.baseURI) ? fetch(t).then((async e => {
                                if (!e.ok) throw new Error(e.statusText);
                                let t;
                                return t = this.isCompressed ? new Uint8Array(await e.arrayBuffer()) : (0, n.stringToBytes)(await e.text()), {
                                    cMapData: t,
                                    compressionType: r
                                }
                            })).catch((e => {
                                throw new Error("Unable to load " + (this.isCompressed ? "binary " : "") + `CMap at: ${t}`)
                            })) : new Promise(((e, s) => {
                                const i = new XMLHttpRequest;
                                i.open("GET", t, !0), this.isCompressed && (i.responseType = "arraybuffer"), i.onreadystatechange = () => {
                                    if (i.readyState === XMLHttpRequest.DONE) {
                                        if (200 === i.status || 0 === i.status) {
                                            let t;
                                            if (this.isCompressed && i.response ? t = new Uint8Array(i.response) : !this.isCompressed && i.responseText && (t = (0, n.stringToBytes)(i.responseText)), t) return void e({
                                                cMapData: t,
                                                compressionType: r
                                            })
                                        }
                                        s(new Error(i.statusText))
                                    }
                                }, i.send(null)
                            })).catch((e => {
                                throw new Error("Unable to load " + (this.isCompressed ? "binary " : "") + `CMap at: ${t}`)
                            }))
                        }
                    }, t.DOMSVGFactory = class {
                        create(e, t) {
                            (0, n.assert)(e > 0 && t > 0, "Invalid SVG dimensions");
                            const r = document.createElementNS(i, "svg:svg");
                            return r.setAttribute("version", "1.1"), r.setAttribute("width", e + "px"), r.setAttribute("height", t + "px"), r.setAttribute("preserveAspectRatio", "none"), r.setAttribute("viewBox", "0 0 " + e + " " + t), r
                        }
                        createElement(e) {
                            return (0, n.assert)("string" == typeof e, "Invalid SVG element type"), document.createElementNS(i, e)
                        }
                    };
                    class a {
                        constructor({
                            viewBox: e,
                            scale: t,
                            rotation: r,
                            offsetX: n = 0,
                            offsetY: s = 0,
                            dontFlip: i = !1
                        }) {
                            this.viewBox = e, this.scale = t, this.rotation = r, this.offsetX = n, this.offsetY = s;
                            const a = (e[2] + e[0]) / 2,
                                o = (e[3] + e[1]) / 2;
                            let l, c, h, u, d, f, p, _;
                            switch (r = (r %= 360) < 0 ? r + 360 : r) {
                                case 180:
                                    l = -1, c = 0, h = 0, u = 1;
                                    break;
                                case 90:
                                    l = 0, c = 1, h = 1, u = 0;
                                    break;
                                case 270:
                                    l = 0, c = -1, h = -1, u = 0;
                                    break;
                                case 0:
                                    l = 1, c = 0, h = 0, u = -1;
                                    break;
                                default:
                                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.")
                            }
                            i && (h = -h, u = -u), 0 === l ? (d = Math.abs(o - e[1]) * t + n, f = Math.abs(a - e[0]) * t + s, p = Math.abs(e[3] - e[1]) * t, _ = Math.abs(e[2] - e[0]) * t) : (d = Math.abs(a - e[0]) * t + n, f = Math.abs(o - e[1]) * t + s, p = Math.abs(e[2] - e[0]) * t, _ = Math.abs(e[3] - e[1]) * t), this.transform = [l * t, c * t, h * t, u * t, d - l * t * a - h * t * o, f - c * t * a - u * t * o], this.width = p, this.height = _
                        }
                        clone({
                            scale: e = this.scale,
                            rotation: t = this.rotation,
                            offsetX: r = this.offsetX,
                            offsetY: n = this.offsetY,
                            dontFlip: s = !1
                        } = {}) {
                            return new a({
                                viewBox: this.viewBox.slice(),
                                scale: e,
                                rotation: t,
                                offsetX: r,
                                offsetY: n,
                                dontFlip: s
                            })
                        }
                        convertToViewportPoint(e, t) {
                            return n.Util.applyTransform([e, t], this.transform)
                        }
                        convertToViewportRectangle(e) {
                            const t = n.Util.applyTransform([e[0], e[1]], this.transform),
                                r = n.Util.applyTransform([e[2], e[3]], this.transform);
                            return [t[0], t[1], r[0], r[1]]
                        }
                        convertToPdfPoint(e, t) {
                            return n.Util.applyInverseTransform([e, t], this.transform)
                        }
                    }
                    t.PageViewport = a;
                    class o extends n.BaseException {
                        constructor(e, t) {
                            super(e), this.type = t
                        }
                    }
                    t.RenderingCancelledException = o;
                    const l = {
                        NONE: 0,
                        SELF: 1,
                        BLANK: 2,
                        PARENT: 3,
                        TOP: 4
                    };

                    function c() {
                        return "undefined" != typeof fetch && "undefined" != typeof Response && "body" in Response.prototype && "undefined" != typeof ReadableStream
                    }

                    function h(e, t) {
                        try {
                            const {
                                protocol: r
                            } = t ? new URL(e, t) : new URL(e);
                            return "http:" === r || "https:" === r
                        } catch (e) {
                            return !1
                        }
                    }
                    let u;
                    t.LinkTarget = l, t.StatTimer = class {
                        constructor() {
                            this.started = Object.create(null), this.times = []
                        }
                        time(e) {
                            e in this.started && (0, n.warn)(`Timer is already running for ${e}`), this.started[e] = Date.now()
                        }
                        timeEnd(e) {
                            e in this.started || (0, n.warn)(`Timer has not been started for ${e}`), this.times.push({
                                name: e,
                                start: this.started[e],
                                end: Date.now()
                            }), delete this.started[e]
                        }
                        toString() {
                            const e = [];
                            let t = 0;
                            for (const e of this.times) {
                                const r = e.name;
                                r.length > t && (t = r.length)
                            }
                            for (const r of this.times) {
                                const n = r.end - r.start;
                                e.push(`${r.name.padEnd(t)} ${n}ms\n`)
                            }
                            return e.join("")
                        }
                    }, t.PDFDateString = class {
                        static toDateObject(e) {
                            if (!e || !(0, n.isString)(e)) return null;
                            u || (u = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                            const t = u.exec(e);
                            if (!t) return null;
                            const r = parseInt(t[1], 10);
                            let s = parseInt(t[2], 10);
                            s = s >= 1 && s <= 12 ? s - 1 : 0;
                            let i = parseInt(t[3], 10);
                            i = i >= 1 && i <= 31 ? i : 1;
                            let a = parseInt(t[4], 10);
                            a = a >= 0 && a <= 23 ? a : 0;
                            let o = parseInt(t[5], 10);
                            o = o >= 0 && o <= 59 ? o : 0;
                            let l = parseInt(t[6], 10);
                            l = l >= 0 && l <= 59 ? l : 0;
                            const c = t[7] || "Z";
                            let h = parseInt(t[8], 10);
                            h = h >= 0 && h <= 23 ? h : 0;
                            let d = parseInt(t[9], 10) || 0;
                            return d = d >= 0 && d <= 59 ? d : 0, "-" === c ? (a += h, o += d) : "+" === c && (a -= h, o -= d), new Date(Date.UTC(r, s, i, a, o, l))
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.arrayByteLength = d, t.arraysToBytes = function(e) {
                        const t = e.length;
                        if (1 === t && e[0] instanceof Uint8Array) return e[0];
                        let r = 0;
                        for (let n = 0; n < t; n++) r += d(e[n]);
                        let n = 0;
                        const s = new Uint8Array(r);
                        for (let r = 0; r < t; r++) {
                            let t = e[r];
                            t instanceof Uint8Array || (t = "string" == typeof t ? u(t) : new Uint8Array(t));
                            const i = t.byteLength;
                            s.set(t, n), n += i
                        }
                        return s
                    }, t.assert = o, t.bytesToString = function(e) {
                        o(null !== e && "object" == typeof e && void 0 !== e.length, "Invalid argument for bytesToString");
                        const t = e.length,
                            r = 8192;
                        if (t < r) return String.fromCharCode.apply(null, e);
                        const n = [];
                        for (let s = 0; s < t; s += r) {
                            const i = Math.min(s + r, t),
                                a = e.subarray(s, i);
                            n.push(String.fromCharCode.apply(null, a))
                        }
                        return n.join("")
                    }, t.createPromiseCapability = function() {
                        const e = Object.create(null);
                        let t = !1;
                        return Object.defineProperty(e, "settled", {
                            get: () => t
                        }), e.promise = new Promise((function(r, n) {
                            e.resolve = function(e) {
                                t = !0, r(e)
                            }, e.reject = function(e) {
                                t = !0, n(e)
                            }
                        })), e
                    }, t.getVerbosityLevel = function() {
                        return s
                    }, t.info = function(e) {
                        s >= n.INFOS && console.log(`Info: ${e}`)
                    }, t.isArrayBuffer = function(e) {
                        return "object" == typeof e && null !== e && void 0 !== e.byteLength
                    }, t.isArrayEqual = function(e, t) {
                        return e.length === t.length && e.every((function(e, r) {
                            return e === t[r]
                        }))
                    }, t.isBool = function(e) {
                        return "boolean" == typeof e
                    }, t.isEmptyObj = function(e) {
                        for (const t in e) return !1;
                        return !0
                    }, t.isNum = function(e) {
                        return "number" == typeof e
                    }, t.isString = function(e) {
                        return "string" == typeof e
                    }, t.isSameOrigin = function(e, t) {
                        let r;
                        try {
                            if (r = new URL(e), !r.origin || "null" === r.origin) return !1
                        } catch (e) {
                            return !1
                        }
                        const n = new URL(t, r);
                        return r.origin === n.origin
                    }, t.createValidAbsoluteUrl = function(e, t) {
                        if (!e) return null;
                        try {
                            const r = t ? new URL(e, t) : new URL(e);
                            if (function(e) {
                                    if (!e) return !1;
                                    switch (e.protocol) {
                                        case "http:":
                                        case "https:":
                                        case "ftp:":
                                        case "mailto:":
                                        case "tel:":
                                            return !0;
                                        default:
                                            return !1
                                    }
                                }(r)) return r
                        } catch (e) {}
                        return null
                    }, t.removeNullCharacters = function(e) {
                        return "string" != typeof e ? (i("The argument for removeNullCharacters must be a string."), e) : e.replace(h, "")
                    }, t.setVerbosityLevel = function(e) {
                        Number.isInteger(e) && (s = e)
                    }, t.shadow = l, t.string32 = function(e) {
                        return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e)
                    }, t.stringToBytes = u, t.stringToPDFString = function(e) {
                        const t = e.length,
                            r = [];
                        if ("þ" === e[0] && "ÿ" === e[1])
                            for (let n = 2; n < t; n += 2) r.push(String.fromCharCode(e.charCodeAt(n) << 8 | e.charCodeAt(n + 1)));
                        else if ("ÿ" === e[0] && "þ" === e[1])
                            for (let n = 2; n < t; n += 2) r.push(String.fromCharCode(e.charCodeAt(n + 1) << 8 | e.charCodeAt(n)));
                        else
                            for (let n = 0; n < t; ++n) {
                                const t = m[e.charCodeAt(n)];
                                r.push(t ? String.fromCharCode(t) : e.charAt(n))
                            }
                        return r.join("")
                    }, t.stringToUTF8String = function(e) {
                        return decodeURIComponent(escape(e))
                    }, t.utf8StringToString = function(e) {
                        return unescape(encodeURIComponent(e))
                    }, t.warn = i, t.unreachable = a, t.IsEvalSupportedCached = t.IsLittleEndianCached = t.createObjectURL = t.FormatError = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.TextRenderingMode = t.StreamType = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.MissingPDFException = t.InvalidPDFException = t.AbortException = t.CMapCompressionType = t.ImageKind = t.FontType = t.AnnotationType = t.AnnotationStateModelType = t.AnnotationReviewState = t.AnnotationReplyType = t.AnnotationMarkedState = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationBorderStyleType = t.UNSUPPORTED_FEATURES = t.VerbosityLevel = t.OPS = t.IDENTITY_MATRIX = t.FONT_IDENTITY_MATRIX = t.BaseException = void 0, r(3), t.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0], t.FONT_IDENTITY_MATRIX = [.001, 0, 0, .001, 0, 0], t.PermissionFlag = {
                        PRINT: 4,
                        MODIFY_CONTENTS: 8,
                        COPY: 16,
                        MODIFY_ANNOTATIONS: 32,
                        FILL_INTERACTIVE_FORMS: 256,
                        COPY_FOR_ACCESSIBILITY: 512,
                        ASSEMBLE: 1024,
                        PRINT_HIGH_QUALITY: 2048
                    }, t.TextRenderingMode = {
                        FILL: 0,
                        STROKE: 1,
                        FILL_STROKE: 2,
                        INVISIBLE: 3,
                        FILL_ADD_TO_PATH: 4,
                        STROKE_ADD_TO_PATH: 5,
                        FILL_STROKE_ADD_TO_PATH: 6,
                        ADD_TO_PATH: 7,
                        FILL_STROKE_MASK: 3,
                        ADD_TO_PATH_FLAG: 4
                    }, t.ImageKind = {
                        GRAYSCALE_1BPP: 1,
                        RGB_24BPP: 2,
                        RGBA_32BPP: 3
                    }, t.AnnotationType = {
                        TEXT: 1,
                        LINK: 2,
                        FREETEXT: 3,
                        LINE: 4,
                        SQUARE: 5,
                        CIRCLE: 6,
                        POLYGON: 7,
                        POLYLINE: 8,
                        HIGHLIGHT: 9,
                        UNDERLINE: 10,
                        SQUIGGLY: 11,
                        STRIKEOUT: 12,
                        STAMP: 13,
                        CARET: 14,
                        INK: 15,
                        POPUP: 16,
                        FILEATTACHMENT: 17,
                        SOUND: 18,
                        MOVIE: 19,
                        WIDGET: 20,
                        SCREEN: 21,
                        PRINTERMARK: 22,
                        TRAPNET: 23,
                        WATERMARK: 24,
                        THREED: 25,
                        REDACT: 26
                    }, t.AnnotationStateModelType = {
                        MARKED: "Marked",
                        REVIEW: "Review"
                    }, t.AnnotationMarkedState = {
                        MARKED: "Marked",
                        UNMARKED: "Unmarked"
                    }, t.AnnotationReviewState = {
                        ACCEPTED: "Accepted",
                        REJECTED: "Rejected",
                        CANCELLED: "Cancelled",
                        COMPLETED: "Completed",
                        NONE: "None"
                    }, t.AnnotationReplyType = {
                        GROUP: "Group",
                        REPLY: "R"
                    }, t.AnnotationFlag = {
                        INVISIBLE: 1,
                        HIDDEN: 2,
                        PRINT: 4,
                        NOZOOM: 8,
                        NOROTATE: 16,
                        NOVIEW: 32,
                        READONLY: 64,
                        LOCKED: 128,
                        TOGGLENOVIEW: 256,
                        LOCKEDCONTENTS: 512
                    }, t.AnnotationFieldFlag = {
                        READONLY: 1,
                        REQUIRED: 2,
                        NOEXPORT: 4,
                        MULTILINE: 4096,
                        PASSWORD: 8192,
                        NOTOGGLETOOFF: 16384,
                        RADIO: 32768,
                        PUSHBUTTON: 65536,
                        COMBO: 131072,
                        EDIT: 262144,
                        SORT: 524288,
                        FILESELECT: 1048576,
                        MULTISELECT: 2097152,
                        DONOTSPELLCHECK: 4194304,
                        DONOTSCROLL: 8388608,
                        COMB: 16777216,
                        RICHTEXT: 33554432,
                        RADIOSINUNISON: 33554432,
                        COMMITONSELCHANGE: 67108864
                    }, t.AnnotationBorderStyleType = {
                        SOLID: 1,
                        DASHED: 2,
                        BEVELED: 3,
                        INSET: 4,
                        UNDERLINE: 5
                    }, t.StreamType = {
                        UNKNOWN: "UNKNOWN",
                        FLATE: "FLATE",
                        LZW: "LZW",
                        DCT: "DCT",
                        JPX: "JPX",
                        JBIG: "JBIG",
                        A85: "A85",
                        AHX: "AHX",
                        CCF: "CCF",
                        RLX: "RLX"
                    }, t.FontType = {
                        UNKNOWN: "UNKNOWN",
                        TYPE1: "TYPE1",
                        TYPE1C: "TYPE1C",
                        CIDFONTTYPE0: "CIDFONTTYPE0",
                        CIDFONTTYPE0C: "CIDFONTTYPE0C",
                        TRUETYPE: "TRUETYPE",
                        CIDFONTTYPE2: "CIDFONTTYPE2",
                        TYPE3: "TYPE3",
                        OPENTYPE: "OPENTYPE",
                        TYPE0: "TYPE0",
                        MMTYPE1: "MMTYPE1"
                    };
                    const n = {
                        ERRORS: 0,
                        WARNINGS: 1,
                        INFOS: 5
                    };
                    t.VerbosityLevel = n, t.CMapCompressionType = {
                        NONE: 0,
                        BINARY: 1,
                        STREAM: 2
                    }, t.OPS = {
                        dependency: 1,
                        setLineWidth: 2,
                        setLineCap: 3,
                        setLineJoin: 4,
                        setMiterLimit: 5,
                        setDash: 6,
                        setRenderingIntent: 7,
                        setFlatness: 8,
                        setGState: 9,
                        save: 10,
                        restore: 11,
                        transform: 12,
                        moveTo: 13,
                        lineTo: 14,
                        curveTo: 15,
                        curveTo2: 16,
                        curveTo3: 17,
                        closePath: 18,
                        rectangle: 19,
                        stroke: 20,
                        closeStroke: 21,
                        fill: 22,
                        eoFill: 23,
                        fillStroke: 24,
                        eoFillStroke: 25,
                        closeFillStroke: 26,
                        closeEOFillStroke: 27,
                        endPath: 28,
                        clip: 29,
                        eoClip: 30,
                        beginText: 31,
                        endText: 32,
                        setCharSpacing: 33,
                        setWordSpacing: 34,
                        setHScale: 35,
                        setLeading: 36,
                        setFont: 37,
                        setTextRenderingMode: 38,
                        setTextRise: 39,
                        moveText: 40,
                        setLeadingMoveText: 41,
                        setTextMatrix: 42,
                        nextLine: 43,
                        showText: 44,
                        showSpacedText: 45,
                        nextLineShowText: 46,
                        nextLineSetSpacingShowText: 47,
                        setCharWidth: 48,
                        setCharWidthAndBounds: 49,
                        setStrokeColorSpace: 50,
                        setFillColorSpace: 51,
                        setStrokeColor: 52,
                        setStrokeColorN: 53,
                        setFillColor: 54,
                        setFillColorN: 55,
                        setStrokeGray: 56,
                        setFillGray: 57,
                        setStrokeRGBColor: 58,
                        setFillRGBColor: 59,
                        setStrokeCMYKColor: 60,
                        setFillCMYKColor: 61,
                        shadingFill: 62,
                        beginInlineImage: 63,
                        beginImageData: 64,
                        endInlineImage: 65,
                        paintXObject: 66,
                        markPoint: 67,
                        markPointProps: 68,
                        beginMarkedContent: 69,
                        beginMarkedContentProps: 70,
                        endMarkedContent: 71,
                        beginCompat: 72,
                        endCompat: 73,
                        paintFormXObjectBegin: 74,
                        paintFormXObjectEnd: 75,
                        beginGroup: 76,
                        endGroup: 77,
                        beginAnnotations: 78,
                        endAnnotations: 79,
                        beginAnnotation: 80,
                        endAnnotation: 81,
                        paintJpegXObject: 82,
                        paintImageMaskXObject: 83,
                        paintImageMaskXObjectGroup: 84,
                        paintImageXObject: 85,
                        paintInlineImageXObject: 86,
                        paintInlineImageXObjectGroup: 87,
                        paintImageXObjectRepeat: 88,
                        paintImageMaskXObjectRepeat: 89,
                        paintSolidColorImageMask: 90,
                        constructPath: 91
                    }, t.UNSUPPORTED_FEATURES = {
                        unknown: "unknown",
                        forms: "forms",
                        javaScript: "javaScript",
                        smask: "smask",
                        shadingPattern: "shadingPattern",
                        font: "font",
                        errorTilingPattern: "errorTilingPattern",
                        errorExtGState: "errorExtGState",
                        errorXObject: "errorXObject",
                        errorFontLoadType3: "errorFontLoadType3",
                        errorFontState: "errorFontState",
                        errorFontMissing: "errorFontMissing",
                        errorFontTranslate: "errorFontTranslate",
                        errorColorSpace: "errorColorSpace",
                        errorOperatorList: "errorOperatorList",
                        errorFontToUnicode: "errorFontToUnicode",
                        errorFontLoadNative: "errorFontLoadNative",
                        errorFontGetPath: "errorFontGetPath"
                    }, t.PasswordResponses = {
                        NEED_PASSWORD: 1,
                        INCORRECT_PASSWORD: 2
                    };
                    let s = n.WARNINGS;

                    function i(e) {
                        s >= n.WARNINGS && console.log(`Warning: ${e}`)
                    }

                    function a(e) {
                        throw new Error(e)
                    }

                    function o(e, t) {
                        e || a(t)
                    }

                    function l(e, t, r) {
                        return Object.defineProperty(e, t, {
                            value: r,
                            enumerable: !0,
                            configurable: !0,
                            writable: !1
                        }), r
                    }
                    const c = function() {
                        function e(t) {
                            this.constructor === e && a("Cannot initialize BaseException."), this.message = t, this.name = this.constructor.name
                        }
                        return e.prototype = new Error, e.constructor = e, e
                    }();
                    t.BaseException = c, t.PasswordException = class extends c {
                        constructor(e, t) {
                            super(e), this.code = t
                        }
                    }, t.UnknownErrorException = class extends c {
                        constructor(e, t) {
                            super(e), this.details = t
                        }
                    }, t.InvalidPDFException = class extends c {}, t.MissingPDFException = class extends c {}, t.UnexpectedResponseException = class extends c {
                        constructor(e, t) {
                            super(e), this.status = t
                        }
                    }, t.FormatError = class extends c {}, t.AbortException = class extends c {};
                    const h = /\x00/g;

                    function u(e) {
                        o("string" == typeof e, "Invalid argument for stringToBytes");
                        const t = e.length,
                            r = new Uint8Array(t);
                        for (let n = 0; n < t; ++n) r[n] = 255 & e.charCodeAt(n);
                        return r
                    }

                    function d(e) {
                        return void 0 !== e.length ? e.length : (o(void 0 !== e.byteLength, "arrayByteLength - invalid argument."), e.byteLength)
                    }
                    const f = {
                        get value() {
                            return l(this, "value", function() {
                                const e = new Uint8Array(4);
                                return e[0] = 1, 1 === new Uint32Array(e.buffer, 0, 1)[0]
                            }())
                        }
                    };
                    t.IsLittleEndianCached = f;
                    const p = {
                        get value() {
                            return l(this, "value", function() {
                                try {
                                    return new Function(""), !0
                                } catch (e) {
                                    return !1
                                }
                            }())
                        }
                    };
                    t.IsEvalSupportedCached = p;
                    const _ = ["rgb(", 0, ",", 0, ",", 0, ")"];
                    class g {
                        static makeCssRgb(e, t, r) {
                            return _[1] = e, _[3] = t, _[5] = r, _.join("")
                        }
                        static transform(e, t) {
                            return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]]
                        }
                        static applyTransform(e, t) {
                            return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]]
                        }
                        static applyInverseTransform(e, t) {
                            const r = t[0] * t[3] - t[1] * t[2];
                            return [(e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / r, (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / r]
                        }
                        static getAxialAlignedBoundingBox(e, t) {
                            const r = g.applyTransform(e, t),
                                n = g.applyTransform(e.slice(2, 4), t),
                                s = g.applyTransform([e[0], e[3]], t),
                                i = g.applyTransform([e[2], e[1]], t);
                            return [Math.min(r[0], n[0], s[0], i[0]), Math.min(r[1], n[1], s[1], i[1]), Math.max(r[0], n[0], s[0], i[0]), Math.max(r[1], n[1], s[1], i[1])]
                        }
                        static inverseTransform(e) {
                            const t = e[0] * e[3] - e[1] * e[2];
                            return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t]
                        }
                        static apply3dTransform(e, t) {
                            return [e[0] * t[0] + e[1] * t[1] + e[2] * t[2], e[3] * t[0] + e[4] * t[1] + e[5] * t[2], e[6] * t[0] + e[7] * t[1] + e[8] * t[2]]
                        }
                        static singularValueDecompose2dScale(e) {
                            const t = [e[0], e[2], e[1], e[3]],
                                r = e[0] * t[0] + e[1] * t[2],
                                n = e[0] * t[1] + e[1] * t[3],
                                s = e[2] * t[0] + e[3] * t[2],
                                i = e[2] * t[1] + e[3] * t[3],
                                a = (r + i) / 2,
                                o = Math.sqrt((r + i) * (r + i) - 4 * (r * i - s * n)) / 2,
                                l = a + o || 1,
                                c = a - o || 1;
                            return [Math.sqrt(l), Math.sqrt(c)]
                        }
                        static normalizeRect(e) {
                            const t = e.slice(0);
                            return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t
                        }
                        static intersect(e, t) {
                            function r(e, t) {
                                return e - t
                            }
                            const n = [e[0], e[2], t[0], t[2]].sort(r),
                                s = [e[1], e[3], t[1], t[3]].sort(r),
                                i = [];
                            return e = g.normalizeRect(e), t = g.normalizeRect(t), n[0] === e[0] && n[1] === t[0] || n[0] === t[0] && n[1] === e[0] ? (i[0] = n[1], i[2] = n[2], s[0] === e[1] && s[1] === t[1] || s[0] === t[1] && s[1] === e[1] ? (i[1] = s[1], i[3] = s[2], i) : null) : null
                        }
                    }
                    t.Util = g;
                    const m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364],
                        A = function() {
                            const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                            return function(t, r, n = !1) {
                                if (!n && URL.createObjectURL) {
                                    const e = new Blob([t], {
                                        type: r
                                    });
                                    return URL.createObjectURL(e)
                                }
                                let s = `data:${r};base64,`;
                                for (let r = 0, n = t.length; r < n; r += 3) {
                                    const i = 255 & t[r],
                                        a = 255 & t[r + 1],
                                        o = 255 & t[r + 2];
                                    s += e[i >> 2] + e[(3 & i) << 4 | a >> 4] + e[r + 1 < n ? (15 & a) << 2 | o >> 6 : 64] + e[r + 2 < n ? 63 & o : 64]
                                }
                                return s
                            }
                        }();
                    t.createObjectURL = A
                }, function(e, t, r) {
                    r(4)
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.isNodeJS = void 0;
                    const n = "object" == typeof process$1 && process$1 + "" == "[object process]" && !process$1.versions.nw && !process$1.versions.electron;
                    t.isNodeJS = n
                }, function(module, exports, __w_pdfjs_require__) {
                    Object.defineProperty(exports, "__esModule", {
                        value: !0
                    }), exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;
                    var _util = __w_pdfjs_require__(2),
                        _display_utils = __w_pdfjs_require__(1),
                        _font_loader = __w_pdfjs_require__(6),
                        _api_compatibility = __w_pdfjs_require__(7),
                        _canvas = __w_pdfjs_require__(8),
                        _worker_options = __w_pdfjs_require__(10),
                        _is_node = __w_pdfjs_require__(4),
                        _message_handler = __w_pdfjs_require__(11),
                        _metadata = __w_pdfjs_require__(12),
                        _transport_stream = __w_pdfjs_require__(14),
                        _webgl = __w_pdfjs_require__(15);
                    const DEFAULT_RANGE_CHUNK_SIZE = 65536,
                        RENDERING_CANCELLED_TIMEOUT = 100;
                    let createPDFNetworkStream;

                    function setPDFNetworkStreamFactory(e) {
                        createPDFNetworkStream = e
                    }

                    function getDocument(e) {
                        const t = new PDFDocumentLoadingTask;
                        let r;
                        if ("string" == typeof e) r = {
                            url: e
                        };
                        else if ((0, _util.isArrayBuffer)(e)) r = {
                            data: e
                        };
                        else if (e instanceof PDFDataRangeTransport) r = {
                            range: e
                        };
                        else {
                            if ("object" != typeof e) throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                            if (!e.url && !e.data && !e.range) throw new Error("Invalid parameter object: need either .data, .range or .url");
                            r = e
                        }
                        const n = Object.create(null);
                        let s = null,
                            i = null;
                        for (const e in r)
                            if ("url" !== e || "undefined" == typeof window)
                                if ("range" !== e)
                                    if ("worker" !== e)
                                        if ("data" !== e || r[e] instanceof Uint8Array) n[e] = r[e];
                                        else {
                                            const t = r[e];
                                            if ("string" == typeof t) n[e] = (0, _util.stringToBytes)(t);
                                            else if ("object" != typeof t || null === t || isNaN(t.length)) {
                                                if (!(0, _util.isArrayBuffer)(t)) throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                                                n[e] = new Uint8Array(t)
                                            } else n[e] = new Uint8Array(t)
                                        }
                        else i = r[e];
                        else s = r[e];
                        else n[e] = new URL(r[e], window.location).href;
                        if (n.rangeChunkSize = n.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE, n.CMapReaderFactory = n.CMapReaderFactory || _display_utils.DOMCMapReaderFactory, n.ignoreErrors = !0 !== n.stopAtErrors, n.fontExtraProperties = !0 === n.fontExtraProperties, n.pdfBug = !0 === n.pdfBug, Number.isInteger(n.maxImageSize) || (n.maxImageSize = -1), "boolean" != typeof n.isEvalSupported && (n.isEvalSupported = !0), "boolean" != typeof n.disableFontFace && (n.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || !1), "boolean" != typeof n.disableRange && (n.disableRange = !1), "boolean" != typeof n.disableStream && (n.disableStream = !1), "boolean" != typeof n.disableAutoFetch && (n.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(n.verbosity), !i) {
                            const e = {
                                verbosity: n.verbosity,
                                port: _worker_options.GlobalWorkerOptions.workerPort
                            };
                            i = e.port ? PDFWorker.fromPort(e) : new PDFWorker(e), t._worker = i
                        }
                        const a = t.docId;
                        return i.promise.then((function() {
                            if (t.destroyed) throw new Error("Loading aborted");
                            const e = _fetchDocument(i, n, s, a),
                                r = new Promise((function(e) {
                                    let t;
                                    s ? t = new _transport_stream.PDFDataTransportStream({
                                        length: n.length,
                                        initialData: n.initialData,
                                        progressiveDone: n.progressiveDone,
                                        disableRange: n.disableRange,
                                        disableStream: n.disableStream
                                    }, s) : n.data || (t = createPDFNetworkStream({
                                        url: n.url,
                                        length: n.length,
                                        httpHeaders: n.httpHeaders,
                                        withCredentials: n.withCredentials,
                                        rangeChunkSize: n.rangeChunkSize,
                                        disableRange: n.disableRange,
                                        disableStream: n.disableStream
                                    })), e(t)
                                }));
                            return Promise.all([e, r]).then((function([e, r]) {
                                if (t.destroyed) throw new Error("Loading aborted");
                                const s = new _message_handler.MessageHandler(a, e, i.port);
                                s.postMessageTransfers = i.postMessageTransfers;
                                const o = new WorkerTransport(s, t, r, n);
                                t._transport = o, s.send("Ready", null)
                            }))
                        })).catch(t._capability.reject), t
                    }

                    function _fetchDocument(e, t, r, n) {
                        return e.destroyed ? Promise.reject(new Error("Worker was destroyed")) : (r && (t.length = r.length, t.initialData = r.initialData, t.progressiveDone = r.progressiveDone), e.messageHandler.sendWithPromise("GetDocRequest", {
                            docId: n,
                            apiVersion: "2.5.207",
                            source: {
                                data: t.data,
                                url: t.url,
                                password: t.password,
                                disableAutoFetch: t.disableAutoFetch,
                                rangeChunkSize: t.rangeChunkSize,
                                length: t.length
                            },
                            maxImageSize: t.maxImageSize,
                            disableFontFace: t.disableFontFace,
                            postMessageTransfers: e.postMessageTransfers,
                            docBaseUrl: t.docBaseUrl,
                            ignoreErrors: t.ignoreErrors,
                            isEvalSupported: t.isEvalSupported,
                            fontExtraProperties: t.fontExtraProperties
                        }).then((function(t) {
                            if (e.destroyed) throw new Error("Worker was destroyed");
                            return t
                        })))
                    }
                    const PDFDocumentLoadingTask = function() {
                        let e = 0;
                        return class {
                            constructor() {
                                this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = "d" + e++, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null
                            }
                            get promise() {
                                return this._capability.promise
                            }
                            destroy() {
                                return this.destroyed = !0, (this._transport ? this._transport.destroy() : Promise.resolve()).then((() => {
                                    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null)
                                }))
                            }
                        }
                    }();
                    class PDFDataRangeTransport {
                        constructor(e, t, r = !1) {
                            this.length = e, this.initialData = t, this.progressiveDone = r, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)()
                        }
                        addRangeListener(e) {
                            this._rangeListeners.push(e)
                        }
                        addProgressListener(e) {
                            this._progressListeners.push(e)
                        }
                        addProgressiveReadListener(e) {
                            this._progressiveReadListeners.push(e)
                        }
                        addProgressiveDoneListener(e) {
                            this._progressiveDoneListeners.push(e)
                        }
                        onDataRange(e, t) {
                            for (const r of this._rangeListeners) r(e, t)
                        }
                        onDataProgress(e, t) {
                            this._readyCapability.promise.then((() => {
                                for (const r of this._progressListeners) r(e, t)
                            }))
                        }
                        onDataProgressiveRead(e) {
                            this._readyCapability.promise.then((() => {
                                for (const t of this._progressiveReadListeners) t(e)
                            }))
                        }
                        onDataProgressiveDone() {
                            this._readyCapability.promise.then((() => {
                                for (const e of this._progressiveDoneListeners) e()
                            }))
                        }
                        transportReady() {
                            this._readyCapability.resolve()
                        }
                        requestDataRange(e, t) {
                            (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange")
                        }
                        abort() {}
                    }
                    exports.PDFDataRangeTransport = PDFDataRangeTransport;
                    class PDFDocumentProxy {
                        constructor(e, t) {
                            this._pdfInfo = e, this._transport = t
                        }
                        get numPages() {
                            return this._pdfInfo.numPages
                        }
                        get fingerprint() {
                            return this._pdfInfo.fingerprint
                        }
                        getPage(e) {
                            return this._transport.getPage(e)
                        }
                        getPageIndex(e) {
                            return this._transport.getPageIndex(e)
                        }
                        getDestinations() {
                            return this._transport.getDestinations()
                        }
                        getDestination(e) {
                            return this._transport.getDestination(e)
                        }
                        getPageLabels() {
                            return this._transport.getPageLabels()
                        }
                        getPageLayout() {
                            return this._transport.getPageLayout()
                        }
                        getPageMode() {
                            return this._transport.getPageMode()
                        }
                        getViewerPreferences() {
                            return this._transport.getViewerPreferences()
                        }
                        getOpenAction() {
                            return this._transport.getOpenAction()
                        }
                        getOpenActionDestination() {
                            return (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead."), this.getOpenAction().then((function(e) {
                                return e && e.dest ? e.dest : null
                            }))
                        }
                        getAttachments() {
                            return this._transport.getAttachments()
                        }
                        getJavaScript() {
                            return this._transport.getJavaScript()
                        }
                        getOutline() {
                            return this._transport.getOutline()
                        }
                        getPermissions() {
                            return this._transport.getPermissions()
                        }
                        getMetadata() {
                            return this._transport.getMetadata()
                        }
                        getData() {
                            return this._transport.getData()
                        }
                        getDownloadInfo() {
                            return this._transport.downloadInfoCapability.promise
                        }
                        getStats() {
                            return this._transport.getStats()
                        }
                        cleanup() {
                            return this._transport.startCleanup()
                        }
                        destroy() {
                            return this.loadingTask.destroy()
                        }
                        get loadingParams() {
                            return this._transport.loadingParams
                        }
                        get loadingTask() {
                            return this._transport.loadingTask
                        }
                    }
                    exports.PDFDocumentProxy = PDFDocumentProxy;
                    class PDFPageProxy {
                        constructor(e, t, r, n = !1) {
                            this._pageIndex = e, this._pageInfo = t, this._transport = r, this._stats = n ? new _display_utils.StatTimer : null, this._pdfBug = n, this.commonObjs = r.commonObjs, this.objs = new PDFObjects, this.cleanupAfterRender = !1, this.pendingCleanup = !1, this.intentStates = Object.create(null), this.destroyed = !1
                        }
                        get pageNumber() {
                            return this._pageIndex + 1
                        }
                        get rotate() {
                            return this._pageInfo.rotate
                        }
                        get ref() {
                            return this._pageInfo.ref
                        }
                        get userUnit() {
                            return this._pageInfo.userUnit
                        }
                        get view() {
                            return this._pageInfo.view
                        }
                        getViewport({
                            scale: e,
                            rotation: t = this.rotate,
                            offsetX: r = 0,
                            offsetY: n = 0,
                            dontFlip: s = !1
                        } = {}) {
                            return new _display_utils.PageViewport({
                                viewBox: this.view,
                                scale: e,
                                rotation: t,
                                offsetX: r,
                                offsetY: n,
                                dontFlip: s
                            })
                        }
                        getAnnotations({
                            intent: e = null
                        } = {}) {
                            return this.annotationsPromise && this.annotationsIntent === e || (this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, e), this.annotationsIntent = e), this.annotationsPromise
                        }
                        render({
                            canvasContext: e,
                            viewport: t,
                            intent: r = "display",
                            enableWebGL: n = !1,
                            renderInteractiveForms: s = !1,
                            transform: i = null,
                            imageLayer: a = null,
                            canvasFactory: o = null,
                            background: l = null
                        }) {
                            this._stats && this._stats.time("Overall");
                            const c = "print" === r ? "print" : "display";
                            this.pendingCleanup = !1, this.intentStates[c] || (this.intentStates[c] = Object.create(null));
                            const h = this.intentStates[c];
                            h.streamReaderCancelTimeout && (clearTimeout(h.streamReaderCancelTimeout), h.streamReaderCancelTimeout = null);
                            const u = o || new _display_utils.DOMCanvasFactory,
                                d = new _webgl.WebGLContext({
                                    enable: n
                                });
                            h.displayReadyCapability || (h.displayReadyCapability = (0, _util.createPromiseCapability)(), h.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: !1
                            }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList({
                                pageIndex: this._pageIndex,
                                intent: c,
                                renderInteractiveForms: !0 === s
                            }));
                            const f = e => {
                                    const t = h.renderTasks.indexOf(p);
                                    t >= 0 && h.renderTasks.splice(t, 1), (this.cleanupAfterRender || "print" === c) && (this.pendingCleanup = !0), this._tryCleanup(), e ? (p.capability.reject(e), this._abortOperatorList({
                                        intentState: h,
                                        reason: e
                                    })) : p.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"))
                                },
                                p = new InternalRenderTask({
                                    callback: f,
                                    params: {
                                        canvasContext: e,
                                        viewport: t,
                                        transform: i,
                                        imageLayer: a,
                                        background: l
                                    },
                                    objs: this.objs,
                                    commonObjs: this.commonObjs,
                                    operatorList: h.operatorList,
                                    pageIndex: this._pageIndex,
                                    canvasFactory: u,
                                    webGLContext: d,
                                    useRequestAnimationFrame: "print" !== c,
                                    pdfBug: this._pdfBug
                                });
                            h.renderTasks || (h.renderTasks = []), h.renderTasks.push(p);
                            const _ = p.task;
                            return h.displayReadyCapability.promise.then((e => {
                                this.pendingCleanup ? f() : (this._stats && this._stats.time("Rendering"), p.initializeGraphics(e), p.operatorListChanged())
                            })).catch(f), _
                        }
                        getOperatorList() {
                            const e = "oplist";
                            this.intentStates.oplist || (this.intentStates.oplist = Object.create(null));
                            const t = this.intentStates.oplist;
                            let r;
                            return t.opListReadCapability || (r = {}, r.operatorListChanged = function() {
                                if (t.operatorList.lastChunk) {
                                    t.opListReadCapability.resolve(t.operatorList);
                                    const e = t.renderTasks.indexOf(r);
                                    e >= 0 && t.renderTasks.splice(e, 1)
                                }
                            }, t.opListReadCapability = (0, _util.createPromiseCapability)(), t.renderTasks = [], t.renderTasks.push(r), t.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: !1
                            }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList({
                                pageIndex: this._pageIndex,
                                intent: e
                            })), t.opListReadCapability.promise
                        }
                        streamTextContent({
                            normalizeWhitespace: e = !1,
                            disableCombineTextItems: t = !1
                        } = {}) {
                            return this._transport.messageHandler.sendWithStream("GetTextContent", {
                                pageIndex: this._pageIndex,
                                normalizeWhitespace: !0 === e,
                                combineTextItems: !0 !== t
                            }, {
                                highWaterMark: 100,
                                size: e => e.items.length
                            })
                        }
                        getTextContent(e = {}) {
                            const t = this.streamTextContent(e);
                            return new Promise((function(e, r) {
                                const n = t.getReader(),
                                    s = {
                                        items: [],
                                        styles: Object.create(null)
                                    };
                                ! function t() {
                                    n.read().then((function({
                                        value: r,
                                        done: n
                                    }) {
                                        n ? e(s) : (Object.assign(s.styles, r.styles), s.items.push(...r.items), t())
                                    }), r)
                                }()
                            }))
                        }
                        _destroy() {
                            this.destroyed = !0, this._transport.pageCache[this._pageIndex] = null;
                            const e = [];
                            return Object.keys(this.intentStates).forEach((t => {
                                const r = this.intentStates[t];
                                this._abortOperatorList({
                                    intentState: r,
                                    reason: new Error("Page was destroyed."),
                                    force: !0
                                }), "oplist" !== t && r.renderTasks.forEach((function(t) {
                                    const r = t.capability.promise.catch((function() {}));
                                    e.push(r), t.cancel()
                                }))
                            })), this.objs.clear(), this.annotationsPromise = null, this.pendingCleanup = !1, Promise.all(e)
                        }
                        cleanup(e = !1) {
                            return this.pendingCleanup = !0, this._tryCleanup(e)
                        }
                        _tryCleanup(e = !1) {
                            return !(!this.pendingCleanup || Object.keys(this.intentStates).some((e => {
                                const t = this.intentStates[e];
                                return 0 !== t.renderTasks.length || !t.operatorList.lastChunk
                            })) || (Object.keys(this.intentStates).forEach((e => {
                                delete this.intentStates[e]
                            })), this.objs.clear(), this.annotationsPromise = null, e && this._stats && (this._stats = new _display_utils.StatTimer), this.pendingCleanup = !1, 0))
                        }
                        _startRenderPage(e, t) {
                            const r = this.intentStates[t];
                            r && (this._stats && this._stats.timeEnd("Page Request"), r.displayReadyCapability && r.displayReadyCapability.resolve(e))
                        }
                        _renderPageChunk(e, t) {
                            for (let r = 0, n = e.length; r < n; r++) t.operatorList.fnArray.push(e.fnArray[r]), t.operatorList.argsArray.push(e.argsArray[r]);
                            t.operatorList.lastChunk = e.lastChunk;
                            for (let e = 0; e < t.renderTasks.length; e++) t.renderTasks[e].operatorListChanged();
                            e.lastChunk && this._tryCleanup()
                        }
                        _pumpOperatorList(e) {
                            (0, _util.assert)(e.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                            const t = this._transport.messageHandler.sendWithStream("GetOperatorList", e).getReader(),
                                r = this.intentStates[e.intent];
                            r.streamReader = t;
                            const n = () => {
                                t.read().then((({
                                    value: e,
                                    done: t
                                }) => {
                                    t ? r.streamReader = null : this._transport.destroyed || (this._renderPageChunk(e, r), n())
                                }), (e => {
                                    if (r.streamReader = null, !this._transport.destroyed) {
                                        if (r.operatorList) {
                                            r.operatorList.lastChunk = !0;
                                            for (let e = 0; e < r.renderTasks.length; e++) r.renderTasks[e].operatorListChanged();
                                            this._tryCleanup()
                                        }
                                        if (r.displayReadyCapability) r.displayReadyCapability.reject(e);
                                        else {
                                            if (!r.opListReadCapability) throw e;
                                            r.opListReadCapability.reject(e)
                                        }
                                    }
                                }))
                            };
                            n()
                        }
                        _abortOperatorList({
                            intentState: e,
                            reason: t,
                            force: r = !1
                        }) {
                            if ((0, _util.assert)(t instanceof Error || "object" == typeof t && null !== t, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.'), e.streamReader) {
                                if (!r) {
                                    if (0 !== e.renderTasks.length) return;
                                    if (t instanceof _display_utils.RenderingCancelledException) return void(e.streamReaderCancelTimeout = setTimeout((() => {
                                        this._abortOperatorList({
                                            intentState: e,
                                            reason: t,
                                            force: !0
                                        }), e.streamReaderCancelTimeout = null
                                    }), RENDERING_CANCELLED_TIMEOUT))
                                }
                                e.streamReader.cancel(new _util.AbortException(t && t.message)), e.streamReader = null, this._transport.destroyed || (Object.keys(this.intentStates).some((t => this.intentStates[t] === e && (delete this.intentStates[t], !0))), this.cleanup())
                            }
                        }
                        get stats() {
                            return this._stats
                        }
                    }
                    exports.PDFPageProxy = PDFPageProxy;
                    class LoopbackPort {
                        constructor(e = !0) {
                            this._listeners = [], this._defer = e, this._deferred = Promise.resolve(void 0)
                        }
                        postMessage(e, t) {
                            if (!this._defer) return void this._listeners.forEach((t => {
                                t.call(this, {
                                    data: e
                                })
                            }));
                            const r = new WeakMap,
                                n = {
                                    data: function e(n) {
                                        if ("object" != typeof n || null === n) return n;
                                        if (r.has(n)) return r.get(n);
                                        let s, i;
                                        if ((s = n.buffer) && (0, _util.isArrayBuffer)(s)) return i = t && t.includes(s) ? new n.constructor(s, n.byteOffset, n.byteLength) : new n.constructor(n), r.set(n, i), i;
                                        i = Array.isArray(n) ? [] : {}, r.set(n, i);
                                        for (const t in n) {
                                            let r, s = n;
                                            for (; !(r = Object.getOwnPropertyDescriptor(s, t));) s = Object.getPrototypeOf(s);
                                            if (void 0 !== r.value)
                                                if ("function" != typeof r.value) i[t] = e(r.value);
                                                else if (n.hasOwnProperty && n.hasOwnProperty(t)) throw new Error(`LoopbackPort.postMessage - cannot clone: ${n[t]}`)
                                        }
                                        return i
                                    }(e)
                                };
                            this._deferred.then((() => {
                                this._listeners.forEach((e => {
                                    e.call(this, n)
                                }))
                            }))
                        }
                        addEventListener(e, t) {
                            this._listeners.push(t)
                        }
                        removeEventListener(e, t) {
                            const r = this._listeners.indexOf(t);
                            this._listeners.splice(r, 1)
                        }
                        terminate() {
                            this._listeners.length = 0
                        }
                    }
                    exports.LoopbackPort = LoopbackPort;
                    const PDFWorker = function PDFWorkerClosure() {
                        const pdfWorkerPorts = new WeakMap;
                        let isWorkerDisabled = !1,
                            fallbackWorkerSrc, nextFakeWorkerId = 0,
                            fakeWorkerCapability;
                        if (_is_node.isNodeJS && "function" == typeof commonjsRequire) isWorkerDisabled = !0, fallbackWorkerSrc = "./pdf.worker.js";
                        else if ("object" == typeof document && "currentScript" in document) {
                            const e = document.currentScript && document.currentScript.src;
                            e && (fallbackWorkerSrc = e.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"))
                        }

                        function getWorkerSrc() {
                            if (_worker_options.GlobalWorkerOptions.workerSrc) return _worker_options.GlobalWorkerOptions.workerSrc;
                            if (void 0 !== fallbackWorkerSrc) return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), fallbackWorkerSrc;
                            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.')
                        }

                        function getMainThreadWorkerMessageHandler() {
                            let e;
                            try {
                                e = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler
                            } catch (e) {}
                            return e || null
                        }

                        function setupFakeWorkerGlobal() {
                            if (fakeWorkerCapability) return fakeWorkerCapability.promise;
                            fakeWorkerCapability = (0, _util.createPromiseCapability)();
                            const loader = async function() {
                                const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                                if (mainWorkerMessageHandler) return mainWorkerMessageHandler;
                                if (_is_node.isNodeJS && "function" == typeof commonjsRequire) {
                                    const worker = eval("require")(getWorkerSrc());
                                    return worker.WorkerMessageHandler
                                }
                                return await (0, _display_utils.loadScript)(getWorkerSrc()), window.pdfjsWorker.WorkerMessageHandler
                            };
                            return loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject), fakeWorkerCapability.promise
                        }

                        function createCDNWrapper(e) {
                            const t = "importScripts('" + e + "');";
                            return URL.createObjectURL(new Blob([t]))
                        }
                        class PDFWorker {
                            constructor({
                                name: e = null,
                                port: t = null,
                                verbosity: r = (0, _util.getVerbosityLevel)()
                            } = {}) {
                                if (t && pdfWorkerPorts.has(t)) throw new Error("Cannot use more than one PDFWorker per port");
                                if (this.name = e, this.destroyed = !1, this.postMessageTransfers = !0, this.verbosity = r, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, t) return pdfWorkerPorts.set(t, this), void this._initializeFromPort(t);
                                this._initialize()
                            }
                            get promise() {
                                return this._readyCapability.promise
                            }
                            get port() {
                                return this._port
                            }
                            get messageHandler() {
                                return this._messageHandler
                            }
                            _initializeFromPort(e) {
                                this._port = e, this._messageHandler = new _message_handler.MessageHandler("main", "worker", e), this._messageHandler.on("ready", (function() {})), this._readyCapability.resolve()
                            }
                            _initialize() {
                                if ("undefined" != typeof Worker && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                                    let e = getWorkerSrc();
                                    try {
                                        (0, _util.isSameOrigin)(window.location.href, e) || (e = createCDNWrapper(new URL(e, window.location).href));
                                        const t = new Worker(e),
                                            r = new _message_handler.MessageHandler("main", "worker", t),
                                            n = () => {
                                                t.removeEventListener("error", s), r.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker()
                                            },
                                            s = () => {
                                                this._webWorker || n()
                                            };
                                        t.addEventListener("error", s), r.on("test", (e => {
                                            t.removeEventListener("error", s), this.destroyed ? n() : e ? (this._messageHandler = r, this._port = t, this._webWorker = t, e.supportTransfers || (this.postMessageTransfers = !1), this._readyCapability.resolve(), r.send("configure", {
                                                verbosity: this.verbosity
                                            })) : (this._setupFakeWorker(), r.destroy(), t.terminate())
                                        })), r.on("ready", (e => {
                                            if (t.removeEventListener("error", s), this.destroyed) n();
                                            else try {
                                                i()
                                            } catch (e) {
                                                this._setupFakeWorker()
                                            }
                                        }));
                                        const i = () => {
                                            const e = new Uint8Array([this.postMessageTransfers ? 255 : 0]);
                                            try {
                                                r.send("test", e, [e.buffer])
                                            } catch (t) {
                                                (0, _util.warn)("Cannot use postMessage transfers."), e[0] = 0, r.send("test", e)
                                            }
                                        };
                                        return void i()
                                    } catch (e) {
                                        (0, _util.info)("The worker has been disabled.")
                                    }
                                }
                                this._setupFakeWorker()
                            }
                            _setupFakeWorker() {
                                isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), isWorkerDisabled = !0), setupFakeWorkerGlobal().then((e => {
                                    if (this.destroyed) return void this._readyCapability.reject(new Error("Worker was destroyed"));
                                    const t = new LoopbackPort;
                                    this._port = t;
                                    const r = "fake" + nextFakeWorkerId++,
                                        n = new _message_handler.MessageHandler(r + "_worker", r, t);
                                    e.setup(n, t);
                                    const s = new _message_handler.MessageHandler(r, r + "_worker", t);
                                    this._messageHandler = s, this._readyCapability.resolve(), s.send("configure", {
                                        verbosity: this.verbosity
                                    })
                                })).catch((e => {
                                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`))
                                }))
                            }
                            destroy() {
                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), pdfWorkerPorts.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null)
                            }
                            static fromPort(e) {
                                if (!e || !e.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
                                return pdfWorkerPorts.has(e.port) ? pdfWorkerPorts.get(e.port) : new PDFWorker(e)
                            }
                            static getWorkerSrc() {
                                return getWorkerSrc()
                            }
                        }
                        return PDFWorker
                    }();
                    exports.PDFWorker = PDFWorker;
                    class WorkerTransport {
                        constructor(e, t, r, n) {
                            this.messageHandler = e, this.loadingTask = t, this.commonObjs = new PDFObjects, this.fontLoader = new _font_loader.FontLoader({
                                docId: t.docId,
                                onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
                            }), this._params = n, this.CMapReaderFactory = new n.CMapReaderFactory({
                                baseUrl: n.cMapUrl,
                                isCompressed: n.cMapPacked
                            }), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = r, this._fullReader = null, this._lastProgress = null, this.pageCache = [], this.pagePromises = [], this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler()
                        }
                        destroy() {
                            if (this.destroyCapability) return this.destroyCapability.promise;
                            this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                            const e = [];
                            this.pageCache.forEach((function(t) {
                                t && e.push(t._destroy())
                            })), this.pageCache.length = 0, this.pagePromises.length = 0;
                            const t = this.messageHandler.sendWithPromise("Terminate", null);
                            return e.push(t), Promise.all(e).then((() => {
                                this.fontLoader.clear(), this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve()
                            }), this.destroyCapability.reject), this.destroyCapability.promise
                        }
                        setupMessageHandler() {
                            const {
                                messageHandler: e,
                                loadingTask: t
                            } = this;
                            e.on("GetReader", ((e, t) => {
                                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = e => {
                                    this._lastProgress = {
                                        loaded: e.loaded,
                                        total: e.total
                                    }
                                }, t.onPull = () => {
                                    this._fullReader.read().then((function({
                                        value: e,
                                        done: r
                                    }) {
                                        r ? t.close() : ((0, _util.assert)((0, _util.isArrayBuffer)(e), "GetReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(e), 1, [e]))
                                    })).catch((e => {
                                        t.error(e)
                                    }))
                                }, t.onCancel = e => {
                                    this._fullReader.cancel(e)
                                }
                            })), e.on("ReaderHeadersReady", (e => {
                                const r = (0, _util.createPromiseCapability)(),
                                    n = this._fullReader;
                                return n.headersReady.then((() => {
                                    n.isStreamingSupported && n.isRangeSupported || (this._lastProgress && t.onProgress && t.onProgress(this._lastProgress), n.onProgress = e => {
                                        t.onProgress && t.onProgress({
                                            loaded: e.loaded,
                                            total: e.total
                                        })
                                    }), r.resolve({
                                        isStreamingSupported: n.isStreamingSupported,
                                        isRangeSupported: n.isRangeSupported,
                                        contentLength: n.contentLength
                                    })
                                }), r.reject), r.promise
                            })), e.on("GetRangeReader", ((e, t) => {
                                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                                const r = this._networkStream.getRangeReader(e.begin, e.end);
                                r ? (t.onPull = () => {
                                    r.read().then((function({
                                        value: e,
                                        done: r
                                    }) {
                                        r ? t.close() : ((0, _util.assert)((0, _util.isArrayBuffer)(e), "GetRangeReader - expected an ArrayBuffer."), t.enqueue(new Uint8Array(e), 1, [e]))
                                    })).catch((e => {
                                        t.error(e)
                                    }))
                                }, t.onCancel = e => {
                                    r.cancel(e)
                                }) : t.close()
                            })), e.on("GetDoc", (({
                                pdfInfo: e
                            }) => {
                                this._numPages = e.numPages, t._capability.resolve(new PDFDocumentProxy(e, this))
                            })), e.on("DocException", (function(e) {
                                let r;
                                switch (e.name) {
                                    case "PasswordException":
                                        r = new _util.PasswordException(e.message, e.code);
                                        break;
                                    case "InvalidPDFException":
                                        r = new _util.InvalidPDFException(e.message);
                                        break;
                                    case "MissingPDFException":
                                        r = new _util.MissingPDFException(e.message);
                                        break;
                                    case "UnexpectedResponseException":
                                        r = new _util.UnexpectedResponseException(e.message, e.status);
                                        break;
                                    case "UnknownErrorException":
                                        r = new _util.UnknownErrorException(e.message, e.details)
                                }
                                t._capability.reject(r)
                            })), e.on("PasswordRequest", (e => {
                                if (this._passwordCapability = (0, _util.createPromiseCapability)(), t.onPassword) {
                                    const r = e => {
                                        this._passwordCapability.resolve({
                                            password: e
                                        })
                                    };
                                    try {
                                        t.onPassword(r, e.code)
                                    } catch (e) {
                                        this._passwordCapability.reject(e)
                                    }
                                } else this._passwordCapability.reject(new _util.PasswordException(e.message, e.code));
                                return this._passwordCapability.promise
                            })), e.on("DataLoaded", (e => {
                                t.onProgress && t.onProgress({
                                    loaded: e.length,
                                    total: e.length
                                }), this.downloadInfoCapability.resolve(e)
                            })), e.on("StartRenderPage", (e => {
                                this.destroyed || this.pageCache[e.pageIndex]._startRenderPage(e.transparency, e.intent)
                            })), e.on("commonobj", (t => {
                                if (this.destroyed) return;
                                const [r, n, s] = t;
                                if (!this.commonObjs.has(r)) switch (n) {
                                    case "Font":
                                        const t = this._params;
                                        if ("error" in s) {
                                            const e = s.error;
                                            (0, _util.warn)(`Error during font loading: ${e}`), this.commonObjs.resolve(r, e);
                                            break
                                        }
                                        let i = null;
                                        t.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled && (i = {
                                            registerFont(e, t) {
                                                globalThis.FontInspector.fontAdded(e, t)
                                            }
                                        });
                                        const a = new _font_loader.FontFaceObject(s, {
                                            isEvalSupported: t.isEvalSupported,
                                            disableFontFace: t.disableFontFace,
                                            ignoreErrors: t.ignoreErrors,
                                            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                                            fontRegistry: i
                                        });
                                        this.fontLoader.bind(a).catch((t => e.sendWithPromise("FontFallback", {
                                            id: r
                                        }))).finally((() => {
                                            !t.fontExtraProperties && a.data && (a.data = null), this.commonObjs.resolve(r, a)
                                        }));
                                        break;
                                    case "FontPath":
                                    case "FontType3Res":
                                    case "Image":
                                        this.commonObjs.resolve(r, s);
                                        break;
                                    default:
                                        throw new Error(`Got unknown common object type ${n}`)
                                }
                            })), e.on("obj", (e => {
                                if (this.destroyed) return;
                                const [t, r, n, s] = e, i = this.pageCache[r];
                                if (!i.objs.has(t)) switch (n) {
                                    case "Image":
                                        i.objs.resolve(t, s);
                                        const e = 8e6;
                                        s && "data" in s && s.data.length > e && (i.cleanupAfterRender = !0);
                                        break;
                                    default:
                                        throw new Error(`Got unknown object type ${n}`)
                                }
                            })), e.on("DocProgress", (e => {
                                this.destroyed || t.onProgress && t.onProgress({
                                    loaded: e.loaded,
                                    total: e.total
                                })
                            })), e.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), e.on("FetchBuiltInCMap", ((e, t) => {
                                if (this.destroyed) return void t.error(new Error("Worker was destroyed"));
                                let r = !1;
                                t.onPull = () => {
                                    r ? t.close() : (r = !0, this.CMapReaderFactory.fetch(e).then((function(e) {
                                        t.enqueue(e, 1, [e.cMapData.buffer])
                                    })).catch((function(e) {
                                        t.error(e)
                                    })))
                                }
                            }))
                        }
                        _onUnsupportedFeature({
                            featureId: e
                        }) {
                            this.destroyed || this.loadingTask.onUnsupportedFeature && this.loadingTask.onUnsupportedFeature(e)
                        }
                        getData() {
                            return this.messageHandler.sendWithPromise("GetData", null)
                        }
                        getPage(e) {
                            if (!Number.isInteger(e) || e <= 0 || e > this._numPages) return Promise.reject(new Error("Invalid page request"));
                            const t = e - 1;
                            if (t in this.pagePromises) return this.pagePromises[t];
                            const r = this.messageHandler.sendWithPromise("GetPage", {
                                pageIndex: t
                            }).then((e => {
                                if (this.destroyed) throw new Error("Transport destroyed");
                                const r = new PDFPageProxy(t, e, this, this._params.pdfBug);
                                return this.pageCache[t] = r, r
                            }));
                            return this.pagePromises[t] = r, r
                        }
                        getPageIndex(e) {
                            return this.messageHandler.sendWithPromise("GetPageIndex", {
                                ref: e
                            }).catch((function(e) {
                                return Promise.reject(new Error(e))
                            }))
                        }
                        getAnnotations(e, t) {
                            return this.messageHandler.sendWithPromise("GetAnnotations", {
                                pageIndex: e,
                                intent: t
                            })
                        }
                        getDestinations() {
                            return this.messageHandler.sendWithPromise("GetDestinations", null)
                        }
                        getDestination(e) {
                            return "string" != typeof e ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                                id: e
                            })
                        }
                        getPageLabels() {
                            return this.messageHandler.sendWithPromise("GetPageLabels", null)
                        }
                        getPageLayout() {
                            return this.messageHandler.sendWithPromise("GetPageLayout", null)
                        }
                        getPageMode() {
                            return this.messageHandler.sendWithPromise("GetPageMode", null)
                        }
                        getViewerPreferences() {
                            return this.messageHandler.sendWithPromise("GetViewerPreferences", null)
                        }
                        getOpenAction() {
                            return this.messageHandler.sendWithPromise("GetOpenAction", null)
                        }
                        getAttachments() {
                            return this.messageHandler.sendWithPromise("GetAttachments", null)
                        }
                        getJavaScript() {
                            return this.messageHandler.sendWithPromise("GetJavaScript", null)
                        }
                        getOutline() {
                            return this.messageHandler.sendWithPromise("GetOutline", null)
                        }
                        getPermissions() {
                            return this.messageHandler.sendWithPromise("GetPermissions", null)
                        }
                        getMetadata() {
                            return this.messageHandler.sendWithPromise("GetMetadata", null).then((e => ({
                                info: e[0],
                                metadata: e[1] ? new _metadata.Metadata(e[1]) : null,
                                contentDispositionFilename: this._fullReader ? this._fullReader.filename : null
                            })))
                        }
                        getStats() {
                            return this.messageHandler.sendWithPromise("GetStats", null)
                        }
                        startCleanup() {
                            return this.messageHandler.sendWithPromise("Cleanup", null).then((() => {
                                for (let e = 0, t = this.pageCache.length; e < t; e++) {
                                    const t = this.pageCache[e];
                                    if (t && !t.cleanup()) throw new Error(`startCleanup: Page ${e+1} is currently rendering.`)
                                }
                                this.commonObjs.clear(), this.fontLoader.clear()
                            }))
                        }
                        get loadingParams() {
                            const e = this._params;
                            return (0, _util.shadow)(this, "loadingParams", {
                                disableAutoFetch: e.disableAutoFetch,
                                disableFontFace: e.disableFontFace
                            })
                        }
                    }
                    class PDFObjects {
                        constructor() {
                            this._objs = Object.create(null)
                        }
                        _ensureObj(e) {
                            return this._objs[e] ? this._objs[e] : this._objs[e] = {
                                capability: (0, _util.createPromiseCapability)(),
                                data: null,
                                resolved: !1
                            }
                        }
                        get(e, t = null) {
                            if (t) return this._ensureObj(e).capability.promise.then(t), null;
                            const r = this._objs[e];
                            if (!r || !r.resolved) throw new Error(`Requesting object that isn't resolved yet ${e}.`);
                            return r.data
                        }
                        has(e) {
                            const t = this._objs[e];
                            return !!t && t.resolved
                        }
                        resolve(e, t) {
                            const r = this._ensureObj(e);
                            r.resolved = !0, r.data = t, r.capability.resolve(t)
                        }
                        clear() {
                            this._objs = Object.create(null)
                        }
                    }
                    class RenderTask {
                        constructor(e) {
                            this._internalRenderTask = e, this.onContinue = null
                        }
                        get promise() {
                            return this._internalRenderTask.capability.promise
                        }
                        cancel() {
                            this._internalRenderTask.cancel()
                        }
                    }
                    const InternalRenderTask = function() {
                            const e = new WeakSet;
                            return class {
                                constructor({
                                    callback: e,
                                    params: t,
                                    objs: r,
                                    commonObjs: n,
                                    operatorList: s,
                                    pageIndex: i,
                                    canvasFactory: a,
                                    webGLContext: o,
                                    useRequestAnimationFrame: l = !1,
                                    pdfBug: c = !1
                                }) {
                                    this.callback = e, this.params = t, this.objs = r, this.commonObjs = n, this.operatorListIdx = null, this.operatorList = s, this._pageIndex = i, this.canvasFactory = a, this.webGLContext = o, this._pdfBug = c, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = !0 === l && "undefined" != typeof window, this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas
                                }
                                initializeGraphics(t = !1) {
                                    if (this.cancelled) return;
                                    if (this._canvas) {
                                        if (e.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                                        e.add(this._canvas)
                                    }
                                    this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
                                    const {
                                        canvasContext: r,
                                        viewport: n,
                                        transform: s,
                                        imageLayer: i,
                                        background: a
                                    } = this.params;
                                    this.gfx = new _canvas.CanvasGraphics(r, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, i), this.gfx.beginDrawing({
                                        transform: s,
                                        viewport: n,
                                        transparency: t,
                                        background: a
                                    }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback()
                                }
                                cancel(t = null) {
                                    this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && e.delete(this._canvas), this.callback(t || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex+1}`, "canvas"))
                                }
                                operatorListChanged() {
                                    this.graphicsReady ? (this.stepper && this.stepper.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound)
                                }
                                _continue() {
                                    this.running = !0, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext())
                                }
                                _scheduleNext() {
                                    this._useRequestAnimationFrame ? window.requestAnimationFrame((() => {
                                        this._nextBound().catch(this.cancel.bind(this))
                                    })) : Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this))
                                }
                                async _next() {
                                    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && e.delete(this._canvas), this.callback())))
                                }
                            }
                        }(),
                        version = "2.5.207";
                    exports.version = version;
                    const build = "0974d605";
                    exports.build = build
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.FontLoader = t.FontFaceObject = void 0;
                    var n = r(2);
                    class s {
                        constructor({
                            docId: e,
                            onUnsupportedFeature: t
                        }) {
                            this.constructor === s && (0, n.unreachable)("Cannot initialize BaseFontLoader."), this.docId = e, this._onUnsupportedFeature = t, this.nativeFontFaces = [], this.styleElement = null
                        }
                        addNativeFontFace(e) {
                            this.nativeFontFaces.push(e), document.fonts.add(e)
                        }
                        insertRule(e) {
                            let t = this.styleElement;
                            t || (t = this.styleElement = document.createElement("style"), t.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, document.documentElement.getElementsByTagName("head")[0].appendChild(t));
                            const r = t.sheet;
                            r.insertRule(e, r.cssRules.length)
                        }
                        clear() {
                            this.nativeFontFaces.forEach((function(e) {
                                document.fonts.delete(e)
                            })), this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null)
                        }
                        async bind(e) {
                            if (e.attached || e.missingFile) return;
                            if (e.attached = !0, this.isFontLoadingAPISupported) {
                                const t = e.createNativeFontFace();
                                if (t) {
                                    this.addNativeFontFace(t);
                                    try {
                                        await t.loaded
                                    } catch (r) {
                                        throw this._onUnsupportedFeature({
                                            featureId: n.UNSUPPORTED_FEATURES.errorFontLoadNative
                                        }), (0, n.warn)(`Failed to load font '${t.family}': '${r}'.`), e.disableFontFace = !0, r
                                    }
                                }
                                return
                            }
                            const t = e.createFontFaceRule();
                            if (t) {
                                if (this.insertRule(t), this.isSyncFontLoadingSupported) return;
                                await new Promise((r => {
                                    const n = this._queueLoadingCallback(r);
                                    this._prepareFontLoadEvent([t], [e], n)
                                }))
                            }
                        }
                        _queueLoadingCallback(e) {
                            (0, n.unreachable)("Abstract method `_queueLoadingCallback`.")
                        }
                        get isFontLoadingAPISupported() {
                            const e = "undefined" != typeof document && !!document.fonts;
                            return (0, n.shadow)(this, "isFontLoadingAPISupported", e)
                        }
                        get isSyncFontLoadingSupported() {
                            (0, n.unreachable)("Abstract method `isSyncFontLoadingSupported`.")
                        }
                        get _loadTestFont() {
                            (0, n.unreachable)("Abstract method `_loadTestFont`.")
                        }
                        _prepareFontLoadEvent(e, t, r) {
                            (0, n.unreachable)("Abstract method `_prepareFontLoadEvent`.")
                        }
                    }
                    let i;
                    t.FontLoader = i, t.FontLoader = i = class extends s {
                        constructor(e) {
                            super(e), this.loadingContext = {
                                requests: [],
                                nextRequestId: 0
                            }, this.loadTestFontId = 0
                        }
                        get isSyncFontLoadingSupported() {
                            let e = !1;
                            if ("undefined" == typeof navigator) e = !0;
                            else {
                                const t = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                                t && t[1] >= 14 && (e = !0)
                            }
                            return (0, n.shadow)(this, "isSyncFontLoadingSupported", e)
                        }
                        _queueLoadingCallback(e) {
                            const t = this.loadingContext,
                                r = {
                                    id: "pdfjs-font-loading-" + t.nextRequestId++,
                                    done: !1,
                                    complete: function() {
                                        for ((0, n.assert)(!r.done, "completeRequest() cannot be called twice."), r.done = !0; t.requests.length > 0 && t.requests[0].done;) {
                                            const e = t.requests.shift();
                                            setTimeout(e.callback, 0)
                                        }
                                    },
                                    callback: e
                                };
                            return t.requests.push(r), r
                        }
                        get _loadTestFont() {
                            return (0, n.shadow)(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="))
                        }
                        _prepareFontLoadEvent(e, t, r) {
                            function s(e, t) {
                                return e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | 255 & e.charCodeAt(t + 3)
                            }

                            function i(e, t, r, n) {
                                return e.substring(0, t) + n + e.substring(t + r)
                            }
                            let a, o;
                            const l = document.createElement("canvas");
                            l.width = 1, l.height = 1;
                            const c = l.getContext("2d");
                            let h = 0;
                            const u = `lt${Date.now()}${this.loadTestFontId++}`;
                            let d = this._loadTestFont;
                            d = i(d, 976, u.length, u);
                            const f = 1482184792;
                            let p = s(d, 16);
                            for (a = 0, o = u.length - 3; a < o; a += 4) p = p - f + s(u, a) | 0;
                            a < u.length && (p = p - f + s(u + "XXX", a) | 0), d = i(d, 16, 4, (0, n.string32)(p));
                            const _ = `@font-face {font-family:"${u}";src:url(data:font/opentype;base64,${btoa(d)});}`;
                            this.insertRule(_);
                            const g = [];
                            for (a = 0, o = t.length; a < o; a++) g.push(t[a].loadedName);
                            g.push(u);
                            const m = document.createElement("div");
                            for (m.style.visibility = "hidden", m.style.width = m.style.height = "10px", m.style.position = "absolute", m.style.top = m.style.left = "0px", a = 0, o = g.length; a < o; ++a) {
                                const e = document.createElement("span");
                                e.textContent = "Hi", e.style.fontFamily = g[a], m.appendChild(e)
                            }
                            document.body.appendChild(m),
                                function e(t, r) {
                                    if (h++, h > 30) return (0, n.warn)("Load test font never loaded."), void r();
                                    c.font = "30px " + t, c.fillText(".", 0, 20), c.getImageData(0, 0, 1, 1).data[3] > 0 ? r() : setTimeout(e.bind(null, t, r))
                                }(u, (function() {
                                    document.body.removeChild(m), r.complete()
                                }))
                        }
                    }, t.FontFaceObject = class {
                        constructor(e, {
                            isEvalSupported: t = !0,
                            disableFontFace: r = !1,
                            ignoreErrors: n = !1,
                            onUnsupportedFeature: s = null,
                            fontRegistry: i = null
                        }) {
                            this.compiledGlyphs = Object.create(null);
                            for (const t in e) this[t] = e[t];
                            this.isEvalSupported = !1 !== t, this.disableFontFace = !0 === r, this.ignoreErrors = !0 === n, this._onUnsupportedFeature = s, this.fontRegistry = i
                        }
                        createNativeFontFace() {
                            if (!this.data || this.disableFontFace) return null;
                            const e = new FontFace(this.loadedName, this.data, {});
                            return this.fontRegistry && this.fontRegistry.registerFont(this), e
                        }
                        createFontFaceRule() {
                            if (!this.data || this.disableFontFace) return null;
                            const e = (0, n.bytesToString)(new Uint8Array(this.data)),
                                t = `url(data:${this.mimetype};base64,${btoa(e)});`,
                                r = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
                            return this.fontRegistry && this.fontRegistry.registerFont(this, t), r
                        }
                        getPathGenerator(e, t) {
                            if (void 0 !== this.compiledGlyphs[t]) return this.compiledGlyphs[t];
                            let r, s;
                            try {
                                r = e.get(this.loadedName + "_path_" + t)
                            } catch (e) {
                                if (!this.ignoreErrors) throw e;
                                return this._onUnsupportedFeature && this._onUnsupportedFeature({
                                    featureId: n.UNSUPPORTED_FEATURES.errorFontGetPath
                                }), (0, n.warn)(`getPathGenerator - ignoring character: "${e}".`), this.compiledGlyphs[t] = function(e, t) {}
                            }
                            if (this.isEvalSupported && n.IsEvalSupportedCached.value) {
                                let e, n = "";
                                for (let t = 0, i = r.length; t < i; t++) s = r[t], e = void 0 !== s.args ? s.args.join(",") : "", n += "c." + s.cmd + "(" + e + ");\n";
                                return this.compiledGlyphs[t] = new Function("c", "size", n)
                            }
                            return this.compiledGlyphs[t] = function(e, t) {
                                for (let n = 0, i = r.length; n < i; n++) s = r[n], "scale" === s.cmd && (s.args = [t, -t]), e[s.cmd].apply(e, s.args)
                            }
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.apiCompatibilityParams = void 0;
                    var n = r(4);
                    const s = Object.create(null);
                    n.isNodeJS && (s.disableFontFace = !0);
                    const i = Object.freeze(s);
                    t.apiCompatibilityParams = i
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.CanvasGraphics = void 0;
                    var n = r(2),
                        s = r(9),
                        i = 4096,
                        a = .65,
                        o = 16;

                    function l(e) {
                        e.mozCurrentTransform || (e._originalSave = e.save, e._originalRestore = e.restore, e._originalRotate = e.rotate, e._originalScale = e.scale, e._originalTranslate = e.translate, e._originalTransform = e.transform, e._originalSetTransform = e.setTransform, e._transformMatrix = e._transformMatrix || [1, 0, 0, 1, 0, 0], e._transformStack = [], Object.defineProperty(e, "mozCurrentTransform", {
                            get: function() {
                                return this._transformMatrix
                            }
                        }), Object.defineProperty(e, "mozCurrentTransformInverse", {
                            get: function() {
                                var e = this._transformMatrix,
                                    t = e[0],
                                    r = e[1],
                                    n = e[2],
                                    s = e[3],
                                    i = e[4],
                                    a = e[5],
                                    o = t * s - r * n,
                                    l = r * n - t * s;
                                return [s / o, r / l, n / l, t / o, (s * i - n * a) / l, (r * i - t * a) / o]
                            }
                        }), e.save = function() {
                            var e = this._transformMatrix;
                            this._transformStack.push(e), this._transformMatrix = e.slice(0, 6), this._originalSave()
                        }, e.restore = function() {
                            var e = this._transformStack.pop();
                            e && (this._transformMatrix = e, this._originalRestore())
                        }, e.translate = function(e, t) {
                            var r = this._transformMatrix;
                            r[4] = r[0] * e + r[2] * t + r[4], r[5] = r[1] * e + r[3] * t + r[5], this._originalTranslate(e, t)
                        }, e.scale = function(e, t) {
                            var r = this._transformMatrix;
                            r[0] = r[0] * e, r[1] = r[1] * e, r[2] = r[2] * t, r[3] = r[3] * t, this._originalScale(e, t)
                        }, e.transform = function(t, r, n, s, i, a) {
                            var o = this._transformMatrix;
                            this._transformMatrix = [o[0] * t + o[2] * r, o[1] * t + o[3] * r, o[0] * n + o[2] * s, o[1] * n + o[3] * s, o[0] * i + o[2] * a + o[4], o[1] * i + o[3] * a + o[5]], e._originalTransform(t, r, n, s, i, a)
                        }, e.setTransform = function(t, r, n, s, i, a) {
                            this._transformMatrix = [t, r, n, s, i, a], e._originalSetTransform(t, r, n, s, i, a)
                        }, e.rotate = function(e) {
                            var t = Math.cos(e),
                                r = Math.sin(e),
                                n = this._transformMatrix;
                            this._transformMatrix = [n[0] * t + n[2] * r, n[1] * t + n[3] * r, n[0] * -r + n[2] * t, n[1] * -r + n[3] * t, n[4], n[5]], this._originalRotate(e)
                        })
                    }
                    var c = function() {
                            function e(e) {
                                this.canvasFactory = e, this.cache = Object.create(null)
                            }
                            return e.prototype = {
                                getCanvas: function(e, t, r, n) {
                                    var s;
                                    return void 0 !== this.cache[e] ? (s = this.cache[e], this.canvasFactory.reset(s, t, r), s.context.setTransform(1, 0, 0, 1, 0, 0)) : (s = this.canvasFactory.create(t, r), this.cache[e] = s), n && l(s.context), s
                                },
                                clear() {
                                    for (var e in this.cache) {
                                        var t = this.cache[e];
                                        this.canvasFactory.destroy(t), delete this.cache[e]
                                    }
                                }
                            }, e
                        }(),
                        h = function() {
                            function e() {
                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = n.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = n.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.resumeSMaskCtx = null
                            }
                            return e.prototype = {
                                clone: function() {
                                    return Object.create(this)
                                },
                                setCurrentPoint: function(e, t) {
                                    this.x = e, this.y = t
                                }
                            }, e
                        }(),
                        u = function() {
                            function e(e, t, r, n, s, i) {
                                this.ctx = e, this.current = new h, this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = r, this.canvasFactory = n, this.webGLContext = s, this.imageLayer = i, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.cachedCanvases = new c(this.canvasFactory), e && l(e), this._cachedGetSinglePixelWidth = null
                            }

                            function t(e, t) {
                                if ("undefined" != typeof ImageData && t instanceof ImageData) e.putImageData(t, 0, 0);
                                else {
                                    var r, s, i, a, l, c = t.height,
                                        h = t.width,
                                        u = c % o,
                                        d = (c - u) / o,
                                        f = 0 === u ? d : d + 1,
                                        p = e.createImageData(h, o),
                                        _ = 0,
                                        g = t.data,
                                        m = p.data;
                                    if (t.kind === n.ImageKind.GRAYSCALE_1BPP) {
                                        var A = g.byteLength,
                                            y = new Uint32Array(m.buffer, 0, m.byteLength >> 2),
                                            b = y.length,
                                            E = h + 7 >> 3,
                                            v = 4294967295,
                                            S = n.IsLittleEndianCached.value ? 4278190080 : 255;
                                        for (s = 0; s < f; s++) {
                                            for (a = s < d ? o : u, r = 0, i = 0; i < a; i++) {
                                                for (var T = A - _, w = 0, R = T > E ? h : 8 * T - 7, C = -8 & R, I = 0, x = 0; w < C; w += 8) x = g[_++], y[r++] = 128 & x ? v : S, y[r++] = 64 & x ? v : S, y[r++] = 32 & x ? v : S, y[r++] = 16 & x ? v : S, y[r++] = 8 & x ? v : S, y[r++] = 4 & x ? v : S, y[r++] = 2 & x ? v : S, y[r++] = 1 & x ? v : S;
                                                for (; w < R; w++) 0 === I && (x = g[_++], I = 128), y[r++] = x & I ? v : S, I >>= 1
                                            }
                                            for (; r < b;) y[r++] = 0;
                                            e.putImageData(p, 0, s * o)
                                        }
                                    } else if (t.kind === n.ImageKind.RGBA_32BPP) {
                                        for (i = 0, l = h * o * 4, s = 0; s < d; s++) m.set(g.subarray(_, _ + l)), _ += l, e.putImageData(p, 0, i), i += o;
                                        s < f && (l = h * u * 4, m.set(g.subarray(_, _ + l)), e.putImageData(p, 0, i))
                                    } else {
                                        if (t.kind !== n.ImageKind.RGB_24BPP) throw new Error(`bad image kind: ${t.kind}`);
                                        for (l = h * (a = o), s = 0; s < f; s++) {
                                            for (s >= d && (l = h * (a = u)), r = 0, i = l; i--;) m[r++] = g[_++], m[r++] = g[_++], m[r++] = g[_++], m[r++] = 255;
                                            e.putImageData(p, 0, s * o)
                                        }
                                    }
                                }
                            }

                            function r(e, t) {
                                for (var r = t.height, n = t.width, s = r % o, i = (r - s) / o, a = 0 === s ? i : i + 1, l = e.createImageData(n, o), c = 0, h = t.data, u = l.data, d = 0; d < a; d++) {
                                    for (var f = d < i ? o : s, p = 3, _ = 0; _ < f; _++)
                                        for (var g = 0, m = 0; m < n; m++) {
                                            if (!g) {
                                                var A = h[c++];
                                                g = 128
                                            }
                                            u[p] = A & g ? 0 : 255, p += 4, g >>= 1
                                        }
                                    e.putImageData(l, 0, d * o)
                                }
                            }

                            function u(e, t) {
                                for (var r = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"], n = 0, s = r.length; n < s; n++) {
                                    var i = r[n];
                                    void 0 !== e[i] && (t[i] = e[i])
                                }
                                void 0 !== e.setLineDash && (t.setLineDash(e.getLineDash()), t.lineDashOffset = e.lineDashOffset)
                            }

                            function d(e) {
                                e.strokeStyle = "#000000", e.fillStyle = "#000000", e.fillRule = "nonzero", e.globalAlpha = 1, e.lineWidth = 1, e.lineCap = "butt", e.lineJoin = "miter", e.miterLimit = 10, e.globalCompositeOperation = "source-over", e.font = "10px sans-serif", void 0 !== e.setLineDash && (e.setLineDash([]), e.lineDashOffset = 0)
                            }

                            function f(e, t, r, n) {
                                for (var s = e.length, i = 3; i < s; i += 4) {
                                    var a = e[i];
                                    if (0 === a) e[i - 3] = t, e[i - 2] = r, e[i - 1] = n;
                                    else if (a < 255) {
                                        var o = 255 - a;
                                        e[i - 3] = e[i - 3] * a + t * o >> 8, e[i - 2] = e[i - 2] * a + r * o >> 8, e[i - 1] = e[i - 1] * a + n * o >> 8
                                    }
                                }
                            }

                            function p(e, t, r) {
                                for (var n = e.length, s = 3; s < n; s += 4) {
                                    var i = r ? r[e[s]] : e[s];
                                    t[s] = t[s] * i * .00392156862745098 | 0
                                }
                            }

                            function _(e, t, r) {
                                for (var n = e.length, s = 3; s < n; s += 4) {
                                    var i = 77 * e[s - 3] + 152 * e[s - 2] + 28 * e[s - 1];
                                    t[s] = r ? t[s] * r[i >> 8] >> 8 : t[s] * i >> 16
                                }
                            }

                            function g(e, t, r, n) {
                                var s = t.canvas,
                                    i = t.context;
                                e.setTransform(t.scaleX, 0, 0, t.scaleY, t.offsetX, t.offsetY);
                                var a = t.backdrop || null;
                                if (!t.transferMap && n.isEnabled) {
                                    const i = n.composeSMask({
                                        layer: r.canvas,
                                        mask: s,
                                        properties: {
                                            subtype: t.subtype,
                                            backdrop: a
                                        }
                                    });
                                    return e.setTransform(1, 0, 0, 1, 0, 0), void e.drawImage(i, t.offsetX, t.offsetY)
                                }! function(e, t, r, n, s, i, a) {
                                    var o, l = !!i,
                                        c = l ? i[0] : 0,
                                        h = l ? i[1] : 0,
                                        u = l ? i[2] : 0;
                                    o = "Luminosity" === s ? _ : p;
                                    for (var d = Math.min(n, Math.ceil(1048576 / r)), g = 0; g < n; g += d) {
                                        var m = Math.min(d, n - g),
                                            A = e.getImageData(0, g, r, m),
                                            y = t.getImageData(0, g, r, m);
                                        l && f(A.data, c, h, u), o(A.data, y.data, a), e.putImageData(y, 0, g)
                                    }
                                }(i, r, s.width, s.height, t.subtype, a, t.transferMap), e.drawImage(s, 0, 0)
                            }
                            var m = ["butt", "round", "square"],
                                A = ["miter", "round", "bevel"],
                                y = {},
                                b = {};
                            for (var E in e.prototype = {
                                    beginDrawing({
                                        transform: e,
                                        viewport: t,
                                        transparency: r = !1,
                                        background: n = null
                                    }) {
                                        var s = this.ctx.canvas.width,
                                            i = this.ctx.canvas.height;
                                        if (this.ctx.save(), this.ctx.fillStyle = n || "rgb(255, 255, 255)", this.ctx.fillRect(0, 0, s, i), this.ctx.restore(), r) {
                                            var a = this.cachedCanvases.getCanvas("transparent", s, i, !0);
                                            this.compositeCtx = this.ctx, this.transparentCanvas = a.canvas, this.ctx = a.context, this.ctx.save(), this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform)
                                        }
                                        this.ctx.save(), d(this.ctx), e && this.ctx.transform.apply(this.ctx, e), this.ctx.transform.apply(this.ctx, t.transform), this.baseTransform = this.ctx.mozCurrentTransform.slice(), this.imageLayer && this.imageLayer.beginLayout()
                                    },
                                    executeOperatorList: function(e, t, r, s) {
                                        var i = e.argsArray,
                                            a = e.fnArray,
                                            o = t || 0,
                                            l = i.length;
                                        if (l === o) return o;
                                        for (var c, h = l - o > 10 && "function" == typeof r, u = h ? Date.now() + 15 : 0, d = 0, f = this.commonObjs, p = this.objs;;) {
                                            if (void 0 !== s && o === s.nextBreakPoint) return s.breakIt(o, r), o;
                                            if ((c = a[o]) !== n.OPS.dependency) this[c].apply(this, i[o]);
                                            else
                                                for (const e of i[o]) {
                                                    const t = e.startsWith("g_") ? f : p;
                                                    if (!t.has(e)) return t.get(e, r), o
                                                }
                                            if (++o === l) return o;
                                            if (h && ++d > 10) {
                                                if (Date.now() > u) return r(), o;
                                                d = 0
                                            }
                                        }
                                    },
                                    endDrawing: function() {
                                        null !== this.current.activeSMask && this.endSMaskGroup(), this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null), this.cachedCanvases.clear(), this.webGLContext.clear(), this.imageLayer && this.imageLayer.endLayout()
                                    },
                                    setLineWidth: function(e) {
                                        this.current.lineWidth = e, this.ctx.lineWidth = e
                                    },
                                    setLineCap: function(e) {
                                        this.ctx.lineCap = m[e]
                                    },
                                    setLineJoin: function(e) {
                                        this.ctx.lineJoin = A[e]
                                    },
                                    setMiterLimit: function(e) {
                                        this.ctx.miterLimit = e
                                    },
                                    setDash: function(e, t) {
                                        var r = this.ctx;
                                        void 0 !== r.setLineDash && (r.setLineDash(e), r.lineDashOffset = t)
                                    },
                                    setRenderingIntent(e) {},
                                    setFlatness(e) {},
                                    setGState: function(e) {
                                        for (var t = 0, r = e.length; t < r; t++) {
                                            var n = e[t],
                                                s = n[0],
                                                i = n[1];
                                            switch (s) {
                                                case "LW":
                                                    this.setLineWidth(i);
                                                    break;
                                                case "LC":
                                                    this.setLineCap(i);
                                                    break;
                                                case "LJ":
                                                    this.setLineJoin(i);
                                                    break;
                                                case "ML":
                                                    this.setMiterLimit(i);
                                                    break;
                                                case "D":
                                                    this.setDash(i[0], i[1]);
                                                    break;
                                                case "RI":
                                                    this.setRenderingIntent(i);
                                                    break;
                                                case "FL":
                                                    this.setFlatness(i);
                                                    break;
                                                case "Font":
                                                    this.setFont(i[0], i[1]);
                                                    break;
                                                case "CA":
                                                    this.current.strokeAlpha = n[1];
                                                    break;
                                                case "ca":
                                                    this.current.fillAlpha = n[1], this.ctx.globalAlpha = n[1];
                                                    break;
                                                case "BM":
                                                    this.ctx.globalCompositeOperation = i;
                                                    break;
                                                case "SMask":
                                                    this.current.activeSMask && (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask ? this.suspendSMaskGroup() : this.endSMaskGroup()), this.current.activeSMask = i ? this.tempSMask : null, this.current.activeSMask && this.beginSMaskGroup(), this.tempSMask = null
                                            }
                                        }
                                    },
                                    beginSMaskGroup: function() {
                                        var e = this.current.activeSMask,
                                            t = e.canvas.width,
                                            r = e.canvas.height,
                                            n = "smaskGroupAt" + this.groupLevel,
                                            s = this.cachedCanvases.getCanvas(n, t, r, !0),
                                            i = this.ctx,
                                            a = i.mozCurrentTransform;
                                        this.ctx.save();
                                        var o = s.context;
                                        o.scale(1 / e.scaleX, 1 / e.scaleY), o.translate(-e.offsetX, -e.offsetY), o.transform.apply(o, a), e.startTransformInverse = o.mozCurrentTransformInverse, u(i, o), this.ctx = o, this.setGState([
                                            ["BM", "source-over"],
                                            ["ca", 1],
                                            ["CA", 1]
                                        ]), this.groupStack.push(i), this.groupLevel++
                                    },
                                    suspendSMaskGroup: function() {
                                        var e = this.ctx;
                                        this.groupLevel--, this.ctx = this.groupStack.pop(), g(this.ctx, this.current.activeSMask, e, this.webGLContext), this.ctx.restore(), this.ctx.save(), u(e, this.ctx), this.current.resumeSMaskCtx = e;
                                        var t = n.Util.transform(this.current.activeSMask.startTransformInverse, e.mozCurrentTransform);
                                        this.ctx.transform.apply(this.ctx, t), e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, e.canvas.width, e.canvas.height), e.restore()
                                    },
                                    resumeSMaskGroup: function() {
                                        var e = this.current.resumeSMaskCtx,
                                            t = this.ctx;
                                        this.ctx = e, this.groupStack.push(t), this.groupLevel++
                                    },
                                    endSMaskGroup: function() {
                                        var e = this.ctx;
                                        this.groupLevel--, this.ctx = this.groupStack.pop(), g(this.ctx, this.current.activeSMask, e, this.webGLContext), this.ctx.restore(), u(e, this.ctx);
                                        var t = n.Util.transform(this.current.activeSMask.startTransformInverse, e.mozCurrentTransform);
                                        this.ctx.transform.apply(this.ctx, t)
                                    },
                                    save: function() {
                                        this.ctx.save();
                                        var e = this.current;
                                        this.stateStack.push(e), this.current = e.clone(), this.current.resumeSMaskCtx = null
                                    },
                                    restore: function() {
                                        this.current.resumeSMaskCtx && this.resumeSMaskGroup(), null === this.current.activeSMask || 0 !== this.stateStack.length && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask || this.endSMaskGroup(), 0 !== this.stateStack.length && (this.current = this.stateStack.pop(), this.ctx.restore(), this.pendingClip = null, this._cachedGetSinglePixelWidth = null)
                                    },
                                    transform: function(e, t, r, n, s, i) {
                                        this.ctx.transform(e, t, r, n, s, i), this._cachedGetSinglePixelWidth = null
                                    },
                                    constructPath: function(e, t) {
                                        for (var r = this.ctx, s = this.current, i = s.x, a = s.y, o = 0, l = 0, c = e.length; o < c; o++) switch (0 | e[o]) {
                                            case n.OPS.rectangle:
                                                i = t[l++], a = t[l++];
                                                var h = t[l++],
                                                    u = t[l++];
                                                0 === h && (h = this.getSinglePixelWidth()), 0 === u && (u = this.getSinglePixelWidth());
                                                var d = i + h,
                                                    f = a + u;
                                                this.ctx.moveTo(i, a), this.ctx.lineTo(d, a), this.ctx.lineTo(d, f), this.ctx.lineTo(i, f), this.ctx.lineTo(i, a), this.ctx.closePath();
                                                break;
                                            case n.OPS.moveTo:
                                                i = t[l++], a = t[l++], r.moveTo(i, a);
                                                break;
                                            case n.OPS.lineTo:
                                                i = t[l++], a = t[l++], r.lineTo(i, a);
                                                break;
                                            case n.OPS.curveTo:
                                                i = t[l + 4], a = t[l + 5], r.bezierCurveTo(t[l], t[l + 1], t[l + 2], t[l + 3], i, a), l += 6;
                                                break;
                                            case n.OPS.curveTo2:
                                                r.bezierCurveTo(i, a, t[l], t[l + 1], t[l + 2], t[l + 3]), i = t[l + 2], a = t[l + 3], l += 4;
                                                break;
                                            case n.OPS.curveTo3:
                                                i = t[l + 2], a = t[l + 3], r.bezierCurveTo(t[l], t[l + 1], i, a, i, a), l += 4;
                                                break;
                                            case n.OPS.closePath:
                                                r.closePath()
                                        }
                                        s.setCurrentPoint(i, a)
                                    },
                                    closePath: function() {
                                        this.ctx.closePath()
                                    },
                                    stroke: function(e) {
                                        e = void 0 === e || e;
                                        var t = this.ctx,
                                            r = this.current.strokeColor;
                                        if (t.globalAlpha = this.current.strokeAlpha, r && r.hasOwnProperty("type") && "Pattern" === r.type) {
                                            t.save();
                                            const e = t.mozCurrentTransform,
                                                s = n.Util.singularValueDecompose2dScale(e)[0];
                                            t.strokeStyle = r.getPattern(t, this), t.lineWidth = Math.max(this.getSinglePixelWidth() * a, this.current.lineWidth * s), t.stroke(), t.restore()
                                        } else t.lineWidth = Math.max(this.getSinglePixelWidth() * a, this.current.lineWidth), t.stroke();
                                        e && this.consumePath(), t.globalAlpha = this.current.fillAlpha
                                    },
                                    closeStroke: function() {
                                        this.closePath(), this.stroke()
                                    },
                                    fill: function(e) {
                                        e = void 0 === e || e;
                                        var t = this.ctx,
                                            r = this.current.fillColor,
                                            n = !1;
                                        this.current.patternFill && (t.save(), this.baseTransform && t.setTransform.apply(t, this.baseTransform), t.fillStyle = r.getPattern(t, this), n = !0), this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill(), n && t.restore(), e && this.consumePath()
                                    },
                                    eoFill: function() {
                                        this.pendingEOFill = !0, this.fill()
                                    },
                                    fillStroke: function() {
                                        this.fill(!1), this.stroke(!1), this.consumePath()
                                    },
                                    eoFillStroke: function() {
                                        this.pendingEOFill = !0, this.fillStroke()
                                    },
                                    closeFillStroke: function() {
                                        this.closePath(), this.fillStroke()
                                    },
                                    closeEOFillStroke: function() {
                                        this.pendingEOFill = !0, this.closePath(), this.fillStroke()
                                    },
                                    endPath: function() {
                                        this.consumePath()
                                    },
                                    clip: function() {
                                        this.pendingClip = y
                                    },
                                    eoClip: function() {
                                        this.pendingClip = b
                                    },
                                    beginText: function() {
                                        this.current.textMatrix = n.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0
                                    },
                                    endText: function() {
                                        var e = this.pendingTextPaths,
                                            t = this.ctx;
                                        if (void 0 !== e) {
                                            t.save(), t.beginPath();
                                            for (var r = 0; r < e.length; r++) {
                                                var n = e[r];
                                                t.setTransform.apply(t, n.transform), t.translate(n.x, n.y), n.addToPath(t, n.fontSize)
                                            }
                                            t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths
                                        } else t.beginPath()
                                    },
                                    setCharSpacing: function(e) {
                                        this.current.charSpacing = e
                                    },
                                    setWordSpacing: function(e) {
                                        this.current.wordSpacing = e
                                    },
                                    setHScale: function(e) {
                                        this.current.textHScale = e / 100
                                    },
                                    setLeading: function(e) {
                                        this.current.leading = -e
                                    },
                                    setFont: function(e, t) {
                                        var r = this.commonObjs.get(e),
                                            s = this.current;
                                        if (!r) throw new Error(`Can't find font for ${e}`);
                                        if (s.fontMatrix = r.fontMatrix ? r.fontMatrix : n.FONT_IDENTITY_MATRIX, 0 !== s.fontMatrix[0] && 0 !== s.fontMatrix[3] || (0, n.warn)("Invalid font matrix for font " + e), t < 0 ? (t = -t, s.fontDirection = -1) : s.fontDirection = 1, this.current.font = r, this.current.fontSize = t, r.isType3Font) return;
                                        var i = r.loadedName || "sans-serif";
                                        let a = "normal";
                                        r.black ? a = "900" : r.bold && (a = "bold");
                                        var o = r.italic ? "italic" : "normal",
                                            l = `"${i}", ${r.fallbackName}`;
                                        let c = t;
                                        t < 16 ? c = 16 : t > 100 && (c = 100), this.current.fontSizeScale = t / c, this.ctx.font = `${o} ${a} ${c}px ${l}`
                                    },
                                    setTextRenderingMode: function(e) {
                                        this.current.textRenderingMode = e
                                    },
                                    setTextRise: function(e) {
                                        this.current.textRise = e
                                    },
                                    moveText: function(e, t) {
                                        this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t
                                    },
                                    setLeadingMoveText: function(e, t) {
                                        this.setLeading(-t), this.moveText(e, t)
                                    },
                                    setTextMatrix: function(e, t, r, n, s, i) {
                                        this.current.textMatrix = [e, t, r, n, s, i], this.current.textMatrixScale = Math.sqrt(e * e + t * t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0
                                    },
                                    nextLine: function() {
                                        this.moveText(0, this.current.leading)
                                    },
                                    paintChar(e, t, r, s) {
                                        var i = this.ctx,
                                            a = this.current,
                                            o = a.font,
                                            l = a.textRenderingMode,
                                            c = a.fontSize / a.fontSizeScale,
                                            h = l & n.TextRenderingMode.FILL_STROKE_MASK,
                                            u = !!(l & n.TextRenderingMode.ADD_TO_PATH_FLAG);
                                        const d = a.patternFill && !o.missingFile;
                                        var f;
                                        (o.disableFontFace || u || d) && (f = o.getPathGenerator(this.commonObjs, e)), o.disableFontFace || d ? (i.save(), i.translate(t, r), i.beginPath(), f(i, c), s && i.setTransform.apply(i, s), h !== n.TextRenderingMode.FILL && h !== n.TextRenderingMode.FILL_STROKE || i.fill(), h !== n.TextRenderingMode.STROKE && h !== n.TextRenderingMode.FILL_STROKE || i.stroke(), i.restore()) : (h !== n.TextRenderingMode.FILL && h !== n.TextRenderingMode.FILL_STROKE || i.fillText(e, t, r), h !== n.TextRenderingMode.STROKE && h !== n.TextRenderingMode.FILL_STROKE || i.strokeText(e, t, r)), u && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                                            transform: i.mozCurrentTransform,
                                            x: t,
                                            y: r,
                                            fontSize: c,
                                            addToPath: f
                                        })
                                    },
                                    get isFontSubpixelAAEnabled() {
                                        const {
                                            context: e
                                        } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                                        e.scale(1.5, 1), e.fillText("I", 0, 10);
                                        for (var t = e.getImageData(0, 0, 10, 10).data, r = !1, s = 3; s < t.length; s += 4)
                                            if (t[s] > 0 && t[s] < 255) {
                                                r = !0;
                                                break
                                            } return (0, n.shadow)(this, "isFontSubpixelAAEnabled", r)
                                    },
                                    showText: function(e) {
                                        var t = this.current,
                                            r = t.font;
                                        if (r.isType3Font) return this.showType3Text(e);
                                        var s = t.fontSize;
                                        if (0 === s) return;
                                        var i = this.ctx,
                                            o = t.fontSizeScale,
                                            l = t.charSpacing,
                                            c = t.wordSpacing,
                                            h = t.fontDirection,
                                            u = t.textHScale * h,
                                            d = e.length,
                                            f = r.vertical,
                                            p = f ? 1 : -1,
                                            _ = r.defaultVMetrics,
                                            g = s * t.fontMatrix[0],
                                            m = t.textRenderingMode === n.TextRenderingMode.FILL && !r.disableFontFace && !t.patternFill;
                                        let A;
                                        if (i.save(), t.patternFill) {
                                            i.save();
                                            const e = t.fillColor.getPattern(i, this);
                                            A = i.mozCurrentTransform, i.restore(), i.fillStyle = e
                                        }
                                        i.transform.apply(i, t.textMatrix), i.translate(t.x, t.y + t.textRise), h > 0 ? i.scale(u, -1) : i.scale(u, 1);
                                        var y = t.lineWidth,
                                            b = t.textMatrixScale;
                                        if (0 === b || 0 === y) {
                                            var E = t.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK;
                                            E !== n.TextRenderingMode.STROKE && E !== n.TextRenderingMode.FILL_STROKE || (this._cachedGetSinglePixelWidth = null, y = this.getSinglePixelWidth() * a)
                                        } else y /= b;
                                        1 !== o && (i.scale(o, o), y /= o), i.lineWidth = y;
                                        var v, S = 0;
                                        for (v = 0; v < d; ++v) {
                                            var T = e[v];
                                            if ((0, n.isNum)(T)) S += p * T * s / 1e3;
                                            else {
                                                var w, R, C, I, x, O, k, N = !1,
                                                    L = (T.isSpace ? c : 0) + l,
                                                    P = T.fontChar,
                                                    D = T.accent,
                                                    M = T.width;
                                                if (f ? (x = T.vmetric || _, O = -(O = T.vmetric ? x[1] : .5 * M) * g, k = x[2] * g, M = x ? -x[0] : M, w = O / o, R = (S + k) / o) : (w = S / o, R = 0), r.remeasure && M > 0) {
                                                    var $ = 1e3 * i.measureText(P).width / s * o;
                                                    if (M < $ && this.isFontSubpixelAAEnabled) {
                                                        var F = M / $;
                                                        N = !0, i.save(), i.scale(F, 1), w /= F
                                                    } else M !== $ && (w += (M - $) / 2e3 * s / o)
                                                }(T.isInFont || r.missingFile) && (m && !D ? i.fillText(P, w, R) : (this.paintChar(P, w, R, A), D && (C = w + D.offset.x / o, I = R - D.offset.y / o, this.paintChar(D.fontChar, C, I, A)))), S += f ? M * g - L * h : M * g + L * h, N && i.restore()
                                            }
                                        }
                                        f ? t.y -= S : t.x += S * u, i.restore()
                                    },
                                    showType3Text: function(e) {
                                        var t, r, s, i, a = this.ctx,
                                            o = this.current,
                                            l = o.font,
                                            c = o.fontSize,
                                            h = o.fontDirection,
                                            u = l.vertical ? 1 : -1,
                                            d = o.charSpacing,
                                            f = o.wordSpacing,
                                            p = o.textHScale * h,
                                            _ = o.fontMatrix || n.FONT_IDENTITY_MATRIX,
                                            g = e.length;
                                        if (o.textRenderingMode !== n.TextRenderingMode.INVISIBLE && 0 !== c) {
                                            for (this._cachedGetSinglePixelWidth = null, a.save(), a.transform.apply(a, o.textMatrix), a.translate(o.x, o.y), a.scale(p, h), t = 0; t < g; ++t)
                                                if (r = e[t], (0, n.isNum)(r)) i = u * r * c / 1e3, this.ctx.translate(i, 0), o.x += i * p;
                                                else {
                                                    var m = (r.isSpace ? f : 0) + d,
                                                        A = l.charProcOperatorList[r.operatorListId];
                                                    A ? (this.processingType3 = r, this.save(), a.scale(c, c), a.transform.apply(a, _), this.executeOperatorList(A), this.restore(), s = n.Util.applyTransform([r.width, 0], _)[0] * c + m, a.translate(s, 0), o.x += s * p) : (0, n.warn)(`Type3 character "${r.operatorListId}" is not available.`)
                                                } a.restore(), this.processingType3 = null
                                        }
                                    },
                                    setCharWidth: function(e, t) {},
                                    setCharWidthAndBounds: function(e, t, r, n, s, i) {
                                        this.ctx.rect(r, n, s - r, i - n), this.clip(), this.endPath()
                                    },
                                    getColorN_Pattern: function(t) {
                                        var r;
                                        if ("TilingPattern" === t[0]) {
                                            var n = t[1],
                                                i = this.baseTransform || this.ctx.mozCurrentTransform.slice(),
                                                a = {
                                                    createCanvasGraphics: t => new e(t, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext)
                                                };
                                            r = new s.TilingPattern(t, n, this.ctx, a, i)
                                        } else r = (0, s.getShadingPatternFromIR)(t);
                                        return r
                                    },
                                    setStrokeColorN: function() {
                                        this.current.strokeColor = this.getColorN_Pattern(arguments)
                                    },
                                    setFillColorN: function() {
                                        this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0
                                    },
                                    setStrokeRGBColor: function(e, t, r) {
                                        var s = n.Util.makeCssRgb(e, t, r);
                                        this.ctx.strokeStyle = s, this.current.strokeColor = s
                                    },
                                    setFillRGBColor: function(e, t, r) {
                                        var s = n.Util.makeCssRgb(e, t, r);
                                        this.ctx.fillStyle = s, this.current.fillColor = s, this.current.patternFill = !1
                                    },
                                    shadingFill: function(e) {
                                        var t = this.ctx;
                                        this.save();
                                        var r = (0, s.getShadingPatternFromIR)(e);
                                        t.fillStyle = r.getPattern(t, this, !0);
                                        var i = t.mozCurrentTransformInverse;
                                        if (i) {
                                            var a = t.canvas,
                                                o = a.width,
                                                l = a.height,
                                                c = n.Util.applyTransform([0, 0], i),
                                                h = n.Util.applyTransform([0, l], i),
                                                u = n.Util.applyTransform([o, 0], i),
                                                d = n.Util.applyTransform([o, l], i),
                                                f = Math.min(c[0], h[0], u[0], d[0]),
                                                p = Math.min(c[1], h[1], u[1], d[1]),
                                                _ = Math.max(c[0], h[0], u[0], d[0]),
                                                g = Math.max(c[1], h[1], u[1], d[1]);
                                            this.ctx.fillRect(f, p, _ - f, g - p)
                                        } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                                        this.restore()
                                    },
                                    beginInlineImage: function() {
                                        (0, n.unreachable)("Should not call beginInlineImage")
                                    },
                                    beginImageData: function() {
                                        (0, n.unreachable)("Should not call beginImageData")
                                    },
                                    paintFormXObjectBegin: function(e, t) {
                                        if (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(e) && 6 === e.length && this.transform.apply(this, e), this.baseTransform = this.ctx.mozCurrentTransform, t) {
                                            var r = t[2] - t[0],
                                                n = t[3] - t[1];
                                            this.ctx.rect(t[0], t[1], r, n), this.clip(), this.endPath()
                                        }
                                    },
                                    paintFormXObjectEnd: function() {
                                        this.restore(), this.baseTransform = this.baseTransformStack.pop()
                                    },
                                    beginGroup: function(e) {
                                        this.save();
                                        var t = this.ctx;
                                        e.isolated || (0, n.info)("TODO: Support non-isolated groups."), e.knockout && (0, n.warn)("Knockout groups not supported.");
                                        var r = t.mozCurrentTransform;
                                        if (e.matrix && t.transform.apply(t, e.matrix), !e.bbox) throw new Error("Bounding box is required.");
                                        var s = n.Util.getAxialAlignedBoundingBox(e.bbox, t.mozCurrentTransform),
                                            a = [0, 0, t.canvas.width, t.canvas.height];
                                        s = n.Util.intersect(s, a) || [0, 0, 0, 0];
                                        var o = Math.floor(s[0]),
                                            l = Math.floor(s[1]),
                                            c = Math.max(Math.ceil(s[2]) - o, 1),
                                            h = Math.max(Math.ceil(s[3]) - l, 1),
                                            d = 1,
                                            f = 1;
                                        c > i && (d = c / i, c = i), h > i && (f = h / i, h = i);
                                        var p = "groupAt" + this.groupLevel;
                                        e.smask && (p += "_smask_" + this.smaskCounter++ % 2);
                                        var _ = this.cachedCanvases.getCanvas(p, c, h, !0),
                                            g = _.context;
                                        g.scale(1 / d, 1 / f), g.translate(-o, -l), g.transform.apply(g, r), e.smask ? this.smaskStack.push({
                                            canvas: _.canvas,
                                            context: g,
                                            offsetX: o,
                                            offsetY: l,
                                            scaleX: d,
                                            scaleY: f,
                                            subtype: e.smask.subtype,
                                            backdrop: e.smask.backdrop,
                                            transferMap: e.smask.transferMap || null,
                                            startTransformInverse: null
                                        }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(o, l), t.scale(d, f)), u(t, g), this.ctx = g, this.setGState([
                                            ["BM", "source-over"],
                                            ["ca", 1],
                                            ["CA", 1]
                                        ]), this.groupStack.push(t), this.groupLevel++, this.current.activeSMask = null
                                    },
                                    endGroup: function(e) {
                                        this.groupLevel--;
                                        var t = this.ctx;
                                        this.ctx = this.groupStack.pop(), void 0 !== this.ctx.imageSmoothingEnabled ? this.ctx.imageSmoothingEnabled = !1 : this.ctx.mozImageSmoothingEnabled = !1, e.smask ? this.tempSMask = this.smaskStack.pop() : this.ctx.drawImage(t.canvas, 0, 0), this.restore()
                                    },
                                    beginAnnotations: function() {
                                        this.save(), this.baseTransform && this.ctx.setTransform.apply(this.ctx, this.baseTransform)
                                    },
                                    endAnnotations: function() {
                                        this.restore()
                                    },
                                    beginAnnotation: function(e, t, r) {
                                        if (this.save(), d(this.ctx), this.current = new h, Array.isArray(e) && 4 === e.length) {
                                            var n = e[2] - e[0],
                                                s = e[3] - e[1];
                                            this.ctx.rect(e[0], e[1], n, s), this.clip(), this.endPath()
                                        }
                                        this.transform.apply(this, t), this.transform.apply(this, r)
                                    },
                                    endAnnotation: function() {
                                        this.restore()
                                    },
                                    paintImageMaskXObject: function(e) {
                                        var t = this.ctx,
                                            n = e.width,
                                            s = e.height,
                                            i = this.current.fillColor,
                                            a = this.current.patternFill,
                                            o = this.processingType3;
                                        if (o && void 0 === o.compiled && (o.compiled = n <= 1e3 && s <= 1e3 ? function(e) {
                                                var t, r, n, s, i = e.width,
                                                    a = e.height,
                                                    o = i + 1,
                                                    l = new Uint8Array(o * (a + 1)),
                                                    c = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
                                                    h = i + 7 & -8,
                                                    u = e.data,
                                                    d = new Uint8Array(h * a),
                                                    f = 0;
                                                for (t = 0, s = u.length; t < s; t++)
                                                    for (var p = 128, _ = u[t]; p > 0;) d[f++] = _ & p ? 0 : 255, p >>= 1;
                                                var g = 0;
                                                for (0 !== d[f = 0] && (l[0] = 1, ++g), r = 1; r < i; r++) d[f] !== d[f + 1] && (l[r] = d[f] ? 2 : 1, ++g), f++;
                                                for (0 !== d[f] && (l[r] = 2, ++g), t = 1; t < a; t++) {
                                                    n = t * o, d[(f = t * h) - h] !== d[f] && (l[n] = d[f] ? 1 : 8, ++g);
                                                    var m = (d[f] ? 4 : 0) + (d[f - h] ? 8 : 0);
                                                    for (r = 1; r < i; r++) c[m = (m >> 2) + (d[f + 1] ? 4 : 0) + (d[f - h + 1] ? 8 : 0)] && (l[n + r] = c[m], ++g), f++;
                                                    if (d[f - h] !== d[f] && (l[n + r] = d[f] ? 2 : 4, ++g), g > 1e3) return null
                                                }
                                                for (n = t * o, 0 !== d[f = h * (a - 1)] && (l[n] = 8, ++g), r = 1; r < i; r++) d[f] !== d[f + 1] && (l[n + r] = d[f] ? 4 : 8, ++g), f++;
                                                if (0 !== d[f] && (l[n + r] = 4, ++g), g > 1e3) return null;
                                                var A = new Int32Array([0, o, -1, 0, -o, 0, 0, 0, 1]),
                                                    y = [];
                                                for (t = 0; g && t <= a; t++) {
                                                    for (var b = t * o, E = b + i; b < E && !l[b];) b++;
                                                    if (b !== E) {
                                                        var v, S = [b % o, t],
                                                            T = l[b],
                                                            w = b;
                                                        do {
                                                            var R = A[T];
                                                            do {
                                                                b += R
                                                            } while (!l[b]);
                                                            5 !== (v = l[b]) && 10 !== v ? (T = v, l[b] = 0) : (T = v & 51 * T >> 4, l[b] &= T >> 2 | T << 2), S.push(b % o), S.push(b / o | 0), l[b] || --g
                                                        } while (w !== b);
                                                        y.push(S), --t
                                                    }
                                                }
                                                return function(e) {
                                                    e.save(), e.scale(1 / i, -1 / a), e.translate(0, -a), e.beginPath();
                                                    for (let r = 0, n = y.length; r < n; r++) {
                                                        var t = y[r];
                                                        e.moveTo(t[0], t[1]);
                                                        for (let r = 2, n = t.length; r < n; r += 2) e.lineTo(t[r], t[r + 1])
                                                    }
                                                    e.fill(), e.beginPath(), e.restore()
                                                }
                                            }({
                                                data: e.data,
                                                width: n,
                                                height: s
                                            }) : null), o && o.compiled) o.compiled(t);
                                        else {
                                            var l = this.cachedCanvases.getCanvas("maskCanvas", n, s),
                                                c = l.context;
                                            c.save(), r(c, e), c.globalCompositeOperation = "source-in", c.fillStyle = a ? i.getPattern(c, this) : i, c.fillRect(0, 0, n, s), c.restore(), this.paintInlineImageXObject(l.canvas)
                                        }
                                    },
                                    paintImageMaskXObjectRepeat: function(e, t, n, s) {
                                        var i = e.width,
                                            a = e.height,
                                            o = this.current.fillColor,
                                            l = this.current.patternFill,
                                            c = this.cachedCanvases.getCanvas("maskCanvas", i, a),
                                            h = c.context;
                                        h.save(), r(h, e), h.globalCompositeOperation = "source-in", h.fillStyle = l ? o.getPattern(h, this) : o, h.fillRect(0, 0, i, a), h.restore();
                                        for (var u = this.ctx, d = 0, f = s.length; d < f; d += 2) u.save(), u.transform(t, 0, 0, n, s[d], s[d + 1]), u.scale(1, -1), u.drawImage(c.canvas, 0, 0, i, a, 0, -1, 1, 1), u.restore()
                                    },
                                    paintImageMaskXObjectGroup: function(e) {
                                        for (var t = this.ctx, n = this.current.fillColor, s = this.current.patternFill, i = 0, a = e.length; i < a; i++) {
                                            var o = e[i],
                                                l = o.width,
                                                c = o.height,
                                                h = this.cachedCanvases.getCanvas("maskCanvas", l, c),
                                                u = h.context;
                                            u.save(), r(u, o), u.globalCompositeOperation = "source-in", u.fillStyle = s ? n.getPattern(u, this) : n, u.fillRect(0, 0, l, c), u.restore(), t.save(), t.transform.apply(t, o.transform), t.scale(1, -1), t.drawImage(h.canvas, 0, 0, l, c, 0, -1, 1, 1), t.restore()
                                        }
                                    },
                                    paintImageXObject: function(e) {
                                        const t = e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e);
                                        t ? this.paintInlineImageXObject(t) : (0, n.warn)("Dependent image isn't ready yet")
                                    },
                                    paintImageXObjectRepeat: function(e, t, r, s) {
                                        const i = e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e);
                                        if (i) {
                                            for (var a = i.width, o = i.height, l = [], c = 0, h = s.length; c < h; c += 2) l.push({
                                                transform: [t, 0, 0, r, s[c], s[c + 1]],
                                                x: 0,
                                                y: 0,
                                                w: a,
                                                h: o
                                            });
                                            this.paintInlineImageXObjectGroup(i, l)
                                        } else(0, n.warn)("Dependent image isn't ready yet")
                                    },
                                    paintInlineImageXObject: function(e) {
                                        var r = e.width,
                                            n = e.height,
                                            s = this.ctx;
                                        this.save(), s.scale(1 / r, -1 / n);
                                        var i, a, o = s.mozCurrentTransformInverse,
                                            l = o[0],
                                            c = o[1],
                                            h = Math.max(Math.sqrt(l * l + c * c), 1),
                                            u = o[2],
                                            d = o[3],
                                            f = Math.max(Math.sqrt(u * u + d * d), 1);
                                        if ("function" == typeof HTMLElement && e instanceof HTMLElement || !e.data) i = e;
                                        else {
                                            var p = (a = this.cachedCanvases.getCanvas("inlineImage", r, n)).context;
                                            t(p, e), i = a.canvas
                                        }
                                        for (var _ = r, g = n, m = "prescale1"; h > 2 && _ > 1 || f > 2 && g > 1;) {
                                            var A = _,
                                                y = g;
                                            h > 2 && _ > 1 && (h /= _ / (A = Math.ceil(_ / 2))), f > 2 && g > 1 && (f /= g / (y = Math.ceil(g / 2))), (p = (a = this.cachedCanvases.getCanvas(m, A, y)).context).clearRect(0, 0, A, y), p.drawImage(i, 0, 0, _, g, 0, 0, A, y), i = a.canvas, _ = A, g = y, m = "prescale1" === m ? "prescale2" : "prescale1"
                                        }
                                        if (s.drawImage(i, 0, 0, _, g, 0, -n, r, n), this.imageLayer) {
                                            var b = this.getCanvasPosition(0, -n);
                                            this.imageLayer.appendImage({
                                                imgData: e,
                                                left: b[0],
                                                top: b[1],
                                                width: r / o[0],
                                                height: n / o[3]
                                            })
                                        }
                                        this.restore()
                                    },
                                    paintInlineImageXObjectGroup: function(e, r) {
                                        var n = this.ctx,
                                            s = e.width,
                                            i = e.height,
                                            a = this.cachedCanvases.getCanvas("inlineImage", s, i);
                                        t(a.context, e);
                                        for (var o = 0, l = r.length; o < l; o++) {
                                            var c = r[o];
                                            if (n.save(), n.transform.apply(n, c.transform), n.scale(1, -1), n.drawImage(a.canvas, c.x, c.y, c.w, c.h, 0, -1, 1, 1), this.imageLayer) {
                                                var h = this.getCanvasPosition(c.x, c.y);
                                                this.imageLayer.appendImage({
                                                    imgData: e,
                                                    left: h[0],
                                                    top: h[1],
                                                    width: s,
                                                    height: i
                                                })
                                            }
                                            n.restore()
                                        }
                                    },
                                    paintSolidColorImageMask: function() {
                                        this.ctx.fillRect(0, 0, 1, 1)
                                    },
                                    paintXObject: function() {
                                        (0, n.warn)("Unsupported 'paintXObject' command.")
                                    },
                                    markPoint: function(e) {},
                                    markPointProps: function(e, t) {},
                                    beginMarkedContent: function(e) {},
                                    beginMarkedContentProps: function(e, t) {},
                                    endMarkedContent: function() {},
                                    beginCompat: function() {},
                                    endCompat: function() {},
                                    consumePath: function() {
                                        var e = this.ctx;
                                        this.pendingClip && (this.pendingClip === b ? e.clip("evenodd") : e.clip(), this.pendingClip = null), e.beginPath()
                                    },
                                    getSinglePixelWidth(e) {
                                        if (null === this._cachedGetSinglePixelWidth) {
                                            const e = this.ctx.mozCurrentTransformInverse;
                                            this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1], e[2] * e[2] + e[3] * e[3]))
                                        }
                                        return this._cachedGetSinglePixelWidth
                                    },
                                    getCanvasPosition: function(e, t) {
                                        var r = this.ctx.mozCurrentTransform;
                                        return [r[0] * e + r[2] * t + r[4], r[1] * e + r[3] * t + r[5]]
                                    }
                                }, n.OPS) e.prototype[n.OPS[E]] = e.prototype[E];
                            return e
                        }();
                    t.CanvasGraphics = u
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.getShadingPatternFromIR = function(e) {
                        var t = s[e[0]];
                        if (!t) throw new Error(`Unknown IR type: ${e[0]}`);
                        return t.fromIR(e)
                    }, t.TilingPattern = void 0;
                    var n = r(2),
                        s = {};

                    function i(e, t) {
                        if (!t || "undefined" == typeof Path2D) return;
                        const r = t[2] - t[0],
                            n = t[3] - t[1],
                            s = new Path2D;
                        s.rect(t[0], t[1], r, n), e.clip(s)
                    }
                    s.RadialAxial = {
                        fromIR: function(e) {
                            var t = e[1],
                                r = e[2],
                                n = e[3],
                                s = e[4],
                                a = e[5],
                                o = e[6],
                                l = e[7];
                            return {
                                type: "Pattern",
                                getPattern: function(e) {
                                    var c;
                                    i(e, r), "axial" === t ? c = e.createLinearGradient(s[0], s[1], a[0], a[1]) : "radial" === t && (c = e.createRadialGradient(s[0], s[1], o, a[0], a[1], l));
                                    for (var h = 0, u = n.length; h < u; ++h) {
                                        var d = n[h];
                                        c.addColorStop(d[0], d[1])
                                    }
                                    return c
                                }
                            }
                        }
                    };
                    var a = function() {
                        function e(e, t, r, n, s, i, a, o) {
                            var l, c = t.coords,
                                h = t.colors,
                                u = e.data,
                                d = 4 * e.width;
                            c[r + 1] > c[n + 1] && (l = r, r = n, n = l, l = i, i = a, a = l), c[n + 1] > c[s + 1] && (l = n, n = s, s = l, l = a, a = o, o = l), c[r + 1] > c[n + 1] && (l = r, r = n, n = l, l = i, i = a, a = l);
                            var f = (c[r] + t.offsetX) * t.scaleX,
                                p = (c[r + 1] + t.offsetY) * t.scaleY,
                                _ = (c[n] + t.offsetX) * t.scaleX,
                                g = (c[n + 1] + t.offsetY) * t.scaleY,
                                m = (c[s] + t.offsetX) * t.scaleX,
                                A = (c[s + 1] + t.offsetY) * t.scaleY;
                            if (!(p >= A))
                                for (var y, b, E, v, S, T, w, R, C = h[i], I = h[i + 1], x = h[i + 2], O = h[a], k = h[a + 1], N = h[a + 2], L = h[o], P = h[o + 1], D = h[o + 2], M = Math.round(p), $ = Math.round(A), F = M; F <= $; F++) {
                                    if (F < g) {
                                        let e;
                                        e = F < p ? 0 : p === g ? 1 : (p - F) / (p - g), y = f - (f - _) * e, b = C - (C - O) * e, E = I - (I - k) * e, v = x - (x - N) * e
                                    } else {
                                        let e;
                                        e = F > A ? 1 : g === A ? 0 : (g - F) / (g - A), y = _ - (_ - m) * e, b = O - (O - L) * e, E = k - (k - P) * e, v = N - (N - D) * e
                                    }
                                    let e;
                                    e = F < p ? 0 : F > A ? 1 : (p - F) / (p - A), S = f - (f - m) * e, T = C - (C - L) * e, w = I - (I - P) * e, R = x - (x - D) * e;
                                    for (var U = Math.round(Math.min(y, S)), B = Math.round(Math.max(y, S)), H = d * F + 4 * U, j = U; j <= B; j++) e = (y - j) / (y - S), e < 0 ? e = 0 : e > 1 && (e = 1), u[H++] = b - (b - T) * e | 0, u[H++] = E - (E - w) * e | 0, u[H++] = v - (v - R) * e | 0, u[H++] = 255
                                }
                        }

                        function t(t, r, n) {
                            var s, i, a = r.coords,
                                o = r.colors;
                            switch (r.type) {
                                case "lattice":
                                    var l = r.verticesPerRow,
                                        c = Math.floor(a.length / l) - 1,
                                        h = l - 1;
                                    for (s = 0; s < c; s++)
                                        for (var u = s * l, d = 0; d < h; d++, u++) e(t, n, a[u], a[u + 1], a[u + l], o[u], o[u + 1], o[u + l]), e(t, n, a[u + l + 1], a[u + 1], a[u + l], o[u + l + 1], o[u + 1], o[u + l]);
                                    break;
                                case "triangles":
                                    for (s = 0, i = a.length; s < i; s += 3) e(t, n, a[s], a[s + 1], a[s + 2], o[s], o[s + 1], o[s + 2]);
                                    break;
                                default:
                                    throw new Error("illegal figure")
                            }
                        }
                        return function(e, r, n, s, i, a, o, l) {
                            var c, h, u, d, f = Math.floor(e[0]),
                                p = Math.floor(e[1]),
                                _ = Math.ceil(e[2]) - f,
                                g = Math.ceil(e[3]) - p,
                                m = Math.min(Math.ceil(Math.abs(_ * r[0] * 1.1)), 3e3),
                                A = Math.min(Math.ceil(Math.abs(g * r[1] * 1.1)), 3e3),
                                y = _ / m,
                                b = g / A,
                                E = {
                                    coords: n,
                                    colors: s,
                                    offsetX: -f,
                                    offsetY: -p,
                                    scaleX: 1 / y,
                                    scaleY: 1 / b
                                },
                                v = m + 4,
                                S = A + 4;
                            if (l.isEnabled) c = l.drawFigures({
                                width: m,
                                height: A,
                                backgroundColor: a,
                                figures: i,
                                context: E
                            }), (h = o.getCanvas("mesh", v, S, !1)).context.drawImage(c, 2, 2), c = h.canvas;
                            else {
                                var T = (h = o.getCanvas("mesh", v, S, !1)).context,
                                    w = T.createImageData(m, A);
                                if (a) {
                                    var R = w.data;
                                    for (u = 0, d = R.length; u < d; u += 4) R[u] = a[0], R[u + 1] = a[1], R[u + 2] = a[2], R[u + 3] = 255
                                }
                                for (u = 0; u < i.length; u++) t(w, i[u], E);
                                T.putImageData(w, 2, 2), c = h.canvas
                            }
                            return {
                                canvas: c,
                                offsetX: f - 2 * y,
                                offsetY: p - 2 * b,
                                scaleX: y,
                                scaleY: b
                            }
                        }
                    }();
                    s.Mesh = {
                        fromIR: function(e) {
                            var t = e[2],
                                r = e[3],
                                s = e[4],
                                o = e[5],
                                l = e[6],
                                c = e[7],
                                h = e[8];
                            return {
                                type: "Pattern",
                                getPattern: function(e, u, d) {
                                    var f;
                                    if (i(e, c), d) f = n.Util.singularValueDecompose2dScale(e.mozCurrentTransform);
                                    else if (f = n.Util.singularValueDecompose2dScale(u.baseTransform), l) {
                                        var p = n.Util.singularValueDecompose2dScale(l);
                                        f = [f[0] * p[0], f[1] * p[1]]
                                    }
                                    var _ = a(o, f, t, r, s, d ? null : h, u.cachedCanvases, u.webGLContext);
                                    return d || (e.setTransform.apply(e, u.baseTransform), l && e.transform.apply(e, l)), e.translate(_.offsetX, _.offsetY), e.scale(_.scaleX, _.scaleY), e.createPattern(_.canvas, "no-repeat")
                                }
                            }
                        }
                    }, s.Dummy = {
                        fromIR: function() {
                            return {
                                type: "Pattern",
                                getPattern: function() {
                                    return "hotpink"
                                }
                            }
                        }
                    };
                    var o = function() {
                        var e = 1,
                            t = 2;

                        function r(e, t, r, n, s) {
                            this.operatorList = e[2], this.matrix = e[3] || [1, 0, 0, 1, 0, 0], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.canvasGraphicsFactory = n, this.baseTransform = s, this.type = "Pattern", this.ctx = r
                        }
                        return r.prototype = {
                            createPatternCanvas: function(e) {
                                var t = this.operatorList,
                                    r = this.bbox,
                                    s = this.xstep,
                                    i = this.ystep,
                                    a = this.paintType,
                                    o = this.tilingType,
                                    l = this.color,
                                    c = this.canvasGraphicsFactory;
                                (0, n.info)("TilingType: " + o);
                                var h = r[0],
                                    u = r[1],
                                    d = r[2],
                                    f = r[3],
                                    p = n.Util.singularValueDecompose2dScale(this.matrix),
                                    _ = n.Util.singularValueDecompose2dScale(this.baseTransform),
                                    g = [p[0] * _[0], p[1] * _[1]],
                                    m = this.getSizeAndScale(s, this.ctx.canvas.width, g[0]),
                                    A = this.getSizeAndScale(i, this.ctx.canvas.height, g[1]),
                                    y = e.cachedCanvases.getCanvas("pattern", m.size, A.size, !0),
                                    b = y.context,
                                    E = c.createCanvasGraphics(b);
                                return E.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(E, a, l), E.transform(m.scale, 0, 0, A.scale, 0, 0), E.transform(1, 0, 0, 1, -h, -u), this.clipBbox(E, r, h, u, d, f), E.executeOperatorList(t), this.ctx.transform(1, 0, 0, 1, h, u), this.ctx.scale(1 / m.scale, 1 / A.scale), y.canvas
                            },
                            getSizeAndScale: function(e, t, r) {
                                e = Math.abs(e);
                                var n = Math.max(3e3, t),
                                    s = Math.ceil(e * r);
                                return s >= n ? s = n : r = s / e, {
                                    scale: r,
                                    size: s
                                }
                            },
                            clipBbox: function(e, t, r, n, s, i) {
                                if (Array.isArray(t) && 4 === t.length) {
                                    var a = s - r,
                                        o = i - n;
                                    e.ctx.rect(r, n, a, o), e.clip(), e.endPath()
                                }
                            },
                            setFillAndStrokeStyleToContext: function(r, s, i) {
                                const a = r.ctx,
                                    o = r.current;
                                switch (s) {
                                    case e:
                                        var l = this.ctx;
                                        a.fillStyle = l.fillStyle, a.strokeStyle = l.strokeStyle, o.fillColor = l.fillStyle, o.strokeColor = l.strokeStyle;
                                        break;
                                    case t:
                                        var c = n.Util.makeCssRgb(i[0], i[1], i[2]);
                                        a.fillStyle = c, a.strokeStyle = c, o.fillColor = c, o.strokeColor = c;
                                        break;
                                    default:
                                        throw new n.FormatError(`Unsupported paint type: ${s}`)
                                }
                            },
                            getPattern: function(e, t) {
                                (e = this.ctx).setTransform.apply(e, this.baseTransform), e.transform.apply(e, this.matrix);
                                var r = this.createPatternCanvas(t);
                                return e.createPattern(r, "repeat")
                            }
                        }, r
                    }();
                    t.TilingPattern = o
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.GlobalWorkerOptions = void 0;
                    const n = Object.create(null);
                    t.GlobalWorkerOptions = n, n.workerPort = void 0 === n.workerPort ? null : n.workerPort, n.workerSrc = void 0 === n.workerSrc ? "" : n.workerSrc
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.MessageHandler = void 0;
                    var n = r(2);
                    const s = 1,
                        i = 2,
                        a = 1,
                        o = 2,
                        l = 3,
                        c = 4,
                        h = 5,
                        u = 6,
                        d = 7,
                        f = 8;

                    function p(e) {
                        if ("object" != typeof e || null === e) return e;
                        switch (e.name) {
                            case "AbortException":
                                return new n.AbortException(e.message);
                            case "MissingPDFException":
                                return new n.MissingPDFException(e.message);
                            case "UnexpectedResponseException":
                                return new n.UnexpectedResponseException(e.message, e.status);
                            case "UnknownErrorException":
                                return new n.UnknownErrorException(e.message, e.details);
                            default:
                                return new n.UnknownErrorException(e.message, e.toString())
                        }
                    }
                    t.MessageHandler = class {
                        constructor(e, t, r) {
                            this.sourceName = e, this.targetName = t, this.comObj = r, this.callbackId = 1, this.streamId = 1, this.postMessageTransfers = !0, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), this._onComObjOnMessage = e => {
                                const t = e.data;
                                if (t.targetName !== this.sourceName) return;
                                if (t.stream) return void this._processStreamMessage(t);
                                if (t.callback) {
                                    const e = t.callbackId,
                                        r = this.callbackCapabilities[e];
                                    if (!r) throw new Error(`Cannot resolve callback ${e}`);
                                    if (delete this.callbackCapabilities[e], t.callback === s) r.resolve(t.data);
                                    else {
                                        if (t.callback !== i) throw new Error("Unexpected callback case");
                                        r.reject(p(t.reason))
                                    }
                                    return
                                }
                                const n = this.actionHandler[t.action];
                                if (!n) throw new Error(`Unknown action from worker: ${t.action}`);
                                if (t.callbackId) {
                                    const e = this.sourceName,
                                        a = t.sourceName;
                                    new Promise((function(e) {
                                        e(n(t.data))
                                    })).then((function(n) {
                                        r.postMessage({
                                            sourceName: e,
                                            targetName: a,
                                            callback: s,
                                            callbackId: t.callbackId,
                                            data: n
                                        })
                                    }), (function(n) {
                                        r.postMessage({
                                            sourceName: e,
                                            targetName: a,
                                            callback: i,
                                            callbackId: t.callbackId,
                                            reason: p(n)
                                        })
                                    }))
                                } else t.streamId ? this._createStreamSink(t) : n(t.data)
                            }, r.addEventListener("message", this._onComObjOnMessage)
                        }
                        on(e, t) {
                            const r = this.actionHandler;
                            if (r[e]) throw new Error(`There is already an actionName called "${e}"`);
                            r[e] = t
                        }
                        send(e, t, r) {
                            this._postMessage({
                                sourceName: this.sourceName,
                                targetName: this.targetName,
                                action: e,
                                data: t
                            }, r)
                        }
                        sendWithPromise(e, t, r) {
                            const s = this.callbackId++,
                                i = (0, n.createPromiseCapability)();
                            this.callbackCapabilities[s] = i;
                            try {
                                this._postMessage({
                                    sourceName: this.sourceName,
                                    targetName: this.targetName,
                                    action: e,
                                    callbackId: s,
                                    data: t
                                }, r)
                            } catch (e) {
                                i.reject(e)
                            }
                            return i.promise
                        }
                        sendWithStream(e, t, r, s) {
                            const i = this.streamId++,
                                o = this.sourceName,
                                l = this.targetName,
                                c = this.comObj;
                            return new ReadableStream({
                                start: r => {
                                    const a = (0, n.createPromiseCapability)();
                                    return this.streamControllers[i] = {
                                        controller: r,
                                        startCall: a,
                                        pullCall: null,
                                        cancelCall: null,
                                        isClosed: !1
                                    }, this._postMessage({
                                        sourceName: o,
                                        targetName: l,
                                        action: e,
                                        streamId: i,
                                        data: t,
                                        desiredSize: r.desiredSize
                                    }, s), a.promise
                                },
                                pull: e => {
                                    const t = (0, n.createPromiseCapability)();
                                    return this.streamControllers[i].pullCall = t, c.postMessage({
                                        sourceName: o,
                                        targetName: l,
                                        stream: u,
                                        streamId: i,
                                        desiredSize: e.desiredSize
                                    }), t.promise
                                },
                                cancel: e => {
                                    (0, n.assert)(e instanceof Error, "cancel must have a valid reason");
                                    const t = (0, n.createPromiseCapability)();
                                    return this.streamControllers[i].cancelCall = t, this.streamControllers[i].isClosed = !0, c.postMessage({
                                        sourceName: o,
                                        targetName: l,
                                        stream: a,
                                        streamId: i,
                                        reason: p(e)
                                    }), t.promise
                                }
                            }, r)
                        }
                        _createStreamSink(e) {
                            const t = this,
                                r = this.actionHandler[e.action],
                                s = e.streamId,
                                i = this.sourceName,
                                a = e.sourceName,
                                o = this.comObj,
                                u = {
                                    enqueue(e, r = 1, o) {
                                        if (this.isCancelled) return;
                                        const l = this.desiredSize;
                                        this.desiredSize -= r, l > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, n.createPromiseCapability)(), this.ready = this.sinkCapability.promise), t._postMessage({
                                            sourceName: i,
                                            targetName: a,
                                            stream: c,
                                            streamId: s,
                                            chunk: e
                                        }, o)
                                    },
                                    close() {
                                        this.isCancelled || (this.isCancelled = !0, o.postMessage({
                                            sourceName: i,
                                            targetName: a,
                                            stream: l,
                                            streamId: s
                                        }), delete t.streamSinks[s])
                                    },
                                    error(e) {
                                        (0, n.assert)(e instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, o.postMessage({
                                            sourceName: i,
                                            targetName: a,
                                            stream: h,
                                            streamId: s,
                                            reason: p(e)
                                        }))
                                    },
                                    sinkCapability: (0, n.createPromiseCapability)(),
                                    onPull: null,
                                    onCancel: null,
                                    isCancelled: !1,
                                    desiredSize: e.desiredSize,
                                    ready: null
                                };
                            u.sinkCapability.resolve(), u.ready = u.sinkCapability.promise, this.streamSinks[s] = u, new Promise((function(t) {
                                t(r(e.data, u))
                            })).then((function() {
                                o.postMessage({
                                    sourceName: i,
                                    targetName: a,
                                    stream: f,
                                    streamId: s,
                                    success: !0
                                })
                            }), (function(e) {
                                o.postMessage({
                                    sourceName: i,
                                    targetName: a,
                                    stream: f,
                                    streamId: s,
                                    reason: p(e)
                                })
                            }))
                        }
                        _processStreamMessage(e) {
                            const t = e.streamId,
                                r = this.sourceName,
                                s = e.sourceName,
                                i = this.comObj;
                            switch (e.stream) {
                                case f:
                                    e.success ? this.streamControllers[t].startCall.resolve() : this.streamControllers[t].startCall.reject(p(e.reason));
                                    break;
                                case d:
                                    e.success ? this.streamControllers[t].pullCall.resolve() : this.streamControllers[t].pullCall.reject(p(e.reason));
                                    break;
                                case u:
                                    if (!this.streamSinks[t]) {
                                        i.postMessage({
                                            sourceName: r,
                                            targetName: s,
                                            stream: d,
                                            streamId: t,
                                            success: !0
                                        });
                                        break
                                    }
                                    this.streamSinks[t].desiredSize <= 0 && e.desiredSize > 0 && this.streamSinks[t].sinkCapability.resolve(), this.streamSinks[t].desiredSize = e.desiredSize;
                                    const {
                                        onPull: _
                                    } = this.streamSinks[e.streamId];
                                    new Promise((function(e) {
                                        e(_ && _())
                                    })).then((function() {
                                        i.postMessage({
                                            sourceName: r,
                                            targetName: s,
                                            stream: d,
                                            streamId: t,
                                            success: !0
                                        })
                                    }), (function(e) {
                                        i.postMessage({
                                            sourceName: r,
                                            targetName: s,
                                            stream: d,
                                            streamId: t,
                                            reason: p(e)
                                        })
                                    }));
                                    break;
                                case c:
                                    if ((0, n.assert)(this.streamControllers[t], "enqueue should have stream controller"), this.streamControllers[t].isClosed) break;
                                    this.streamControllers[t].controller.enqueue(e.chunk);
                                    break;
                                case l:
                                    if ((0, n.assert)(this.streamControllers[t], "close should have stream controller"), this.streamControllers[t].isClosed) break;
                                    this.streamControllers[t].isClosed = !0, this.streamControllers[t].controller.close(), this._deleteStreamController(t);
                                    break;
                                case h:
                                    (0, n.assert)(this.streamControllers[t], "error should have stream controller"), this.streamControllers[t].controller.error(p(e.reason)), this._deleteStreamController(t);
                                    break;
                                case o:
                                    e.success ? this.streamControllers[t].cancelCall.resolve() : this.streamControllers[t].cancelCall.reject(p(e.reason)), this._deleteStreamController(t);
                                    break;
                                case a:
                                    if (!this.streamSinks[t]) break;
                                    const {
                                        onCancel: g
                                    } = this.streamSinks[e.streamId];
                                    new Promise((function(t) {
                                        t(g && g(p(e.reason)))
                                    })).then((function() {
                                        i.postMessage({
                                            sourceName: r,
                                            targetName: s,
                                            stream: o,
                                            streamId: t,
                                            success: !0
                                        })
                                    }), (function(e) {
                                        i.postMessage({
                                            sourceName: r,
                                            targetName: s,
                                            stream: o,
                                            streamId: t,
                                            reason: p(e)
                                        })
                                    })), this.streamSinks[t].sinkCapability.reject(p(e.reason)), this.streamSinks[t].isCancelled = !0, delete this.streamSinks[t];
                                    break;
                                default:
                                    throw new Error("Unexpected stream case")
                            }
                        }
                        async _deleteStreamController(e) {
                            await Promise.allSettled([this.streamControllers[e].startCall, this.streamControllers[e].pullCall, this.streamControllers[e].cancelCall].map((function(e) {
                                return e && e.promise
                            }))), delete this.streamControllers[e]
                        }
                        _postMessage(e, t) {
                            t && this.postMessageTransfers ? this.comObj.postMessage(e, t) : this.comObj.postMessage(e)
                        }
                        destroy() {
                            this.comObj.removeEventListener("message", this._onComObjOnMessage)
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.Metadata = void 0;
                    var n = r(2),
                        s = r(13);
                    t.Metadata = class {
                        constructor(e) {
                            (0, n.assert)("string" == typeof e, "Metadata: input is not a string"), e = this._repair(e);
                            const t = (new s.SimpleXMLParser).parseFromString(e);
                            this._metadataMap = new Map, t && this._parse(t)
                        }
                        _repair(e) {
                            return e.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, (function(e, t) {
                                const r = t.replace(/\\([0-3])([0-7])([0-7])/g, (function(e, t, r, n) {
                                    return String.fromCharCode(64 * t + 8 * r + 1 * n)
                                })).replace(/&(amp|apos|gt|lt|quot);/g, (function(e, t) {
                                    switch (t) {
                                        case "amp":
                                            return "&";
                                        case "apos":
                                            return "'";
                                        case "gt":
                                            return ">";
                                        case "lt":
                                            return "<";
                                        case "quot":
                                            return '"'
                                    }
                                    throw new Error(`_repair: ${t} isn't defined.`)
                                }));
                                let n = "";
                                for (let e = 0, t = r.length; e < t; e += 2) {
                                    const t = 256 * r.charCodeAt(e) + r.charCodeAt(e + 1);
                                    n += t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? String.fromCharCode(t) : "&#x" + (65536 + t).toString(16).substring(1) + ";"
                                }
                                return ">" + n
                            }))
                        }
                        _parse(e) {
                            let t = e.documentElement;
                            if ("rdf:rdf" !== t.nodeName.toLowerCase())
                                for (t = t.firstChild; t && "rdf:rdf" !== t.nodeName.toLowerCase();) t = t.nextSibling;
                            const r = t ? t.nodeName.toLowerCase() : null;
                            if (!t || "rdf:rdf" !== r || !t.hasChildNodes()) return;
                            const n = t.childNodes;
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e];
                                if ("rdf:description" === t.nodeName.toLowerCase())
                                    for (let e = 0, r = t.childNodes.length; e < r; e++)
                                        if ("#text" !== t.childNodes[e].nodeName.toLowerCase()) {
                                            const r = t.childNodes[e],
                                                n = r.nodeName.toLowerCase();
                                            this._metadataMap.set(n, r.textContent.trim())
                                        }
                            }
                        }
                        get(e) {
                            return this._metadataMap.has(e) ? this._metadataMap.get(e) : null
                        }
                        getAll() {
                            const e = Object.create(null);
                            for (const [t, r] of this._metadataMap) e[t] = r;
                            return e
                        }
                        has(e) {
                            return this._metadataMap.has(e)
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.SimpleXMLParser = void 0;
                    const n = 0,
                        s = -2,
                        i = -3,
                        a = -4,
                        o = -5,
                        l = -6,
                        c = -9;

                    function h(e, t) {
                        const r = e[t];
                        return " " === r || "\n" === r || "\r" === r || "\t" === r
                    }
                    class u {
                        constructor(e, t) {
                            this.nodeName = e, this.nodeValue = t, Object.defineProperty(this, "parentNode", {
                                value: null,
                                writable: !0
                            })
                        }
                        get firstChild() {
                            return this.childNodes && this.childNodes[0]
                        }
                        get nextSibling() {
                            const e = this.parentNode.childNodes;
                            if (!e) return;
                            const t = e.indexOf(this);
                            return -1 !== t ? e[t + 1] : void 0
                        }
                        get textContent() {
                            return this.childNodes ? this.childNodes.map((function(e) {
                                return e.textContent
                            })).join("") : this.nodeValue || ""
                        }
                        hasChildNodes() {
                            return this.childNodes && this.childNodes.length > 0
                        }
                    }
                    t.SimpleXMLParser = class extends class {
                        _resolveEntities(e) {
                            return e.replace(/&([^;]+);/g, ((e, t) => {
                                if ("#x" === t.substring(0, 2)) return String.fromCharCode(parseInt(t.substring(2), 16));
                                if ("#" === t.substring(0, 1)) return String.fromCharCode(parseInt(t.substring(1), 10));
                                switch (t) {
                                    case "lt":
                                        return "<";
                                    case "gt":
                                        return ">";
                                    case "amp":
                                        return "&";
                                    case "quot":
                                        return '"'
                                }
                                return this.onResolveEntity(t)
                            }))
                        }
                        _parseContent(e, t) {
                            const r = [];
                            let n = t;

                            function s() {
                                for (; n < e.length && h(e, n);) ++n
                            }
                            for (; n < e.length && !h(e, n) && ">" !== e[n] && "/" !== e[n];) ++n;
                            const i = e.substring(t, n);
                            for (s(); n < e.length && ">" !== e[n] && "/" !== e[n] && "?" !== e[n];) {
                                s();
                                let t = "",
                                    i = "";
                                for (; n < e.length && !h(e, n) && "=" !== e[n];) t += e[n], ++n;
                                if (s(), "=" !== e[n]) return null;
                                ++n, s();
                                const a = e[n];
                                if ('"' !== a && "'" !== a) return null;
                                const o = e.indexOf(a, ++n);
                                if (o < 0) return null;
                                i = e.substring(n, o), r.push({
                                    name: t,
                                    value: this._resolveEntities(i)
                                }), n = o + 1, s()
                            }
                            return {
                                name: i,
                                attributes: r,
                                parsed: n - t
                            }
                        }
                        _parseProcessingInstruction(e, t) {
                            let r = t;
                            for (; r < e.length && !h(e, r) && ">" !== e[r] && "/" !== e[r];) ++r;
                            const n = e.substring(t, r);
                            ! function() {
                                for (; r < e.length && h(e, r);) ++r
                            }();
                            const s = r;
                            for (; r < e.length && ("?" !== e[r] || ">" !== e[r + 1]);) ++r;
                            return {
                                name: n,
                                value: e.substring(s, r),
                                parsed: r - t
                            }
                        }
                        parseXml(e) {
                            let t = 0;
                            for (; t < e.length;) {
                                let r = t;
                                if ("<" === e[t]) {
                                    let t;
                                    switch (++r, e[r]) {
                                        case "/":
                                            if (++r, t = e.indexOf(">", r), t < 0) return void this.onError(c);
                                            this.onEndElement(e.substring(r, t)), r = t + 1;
                                            break;
                                        case "?":
                                            ++r;
                                            const n = this._parseProcessingInstruction(e, r);
                                            if ("?>" !== e.substring(r + n.parsed, r + n.parsed + 2)) return void this.onError(i);
                                            this.onPi(n.name, n.value), r += n.parsed + 2;
                                            break;
                                        case "!":
                                            if ("--" === e.substring(r + 1, r + 3)) {
                                                if (t = e.indexOf("--\x3e", r + 3), t < 0) return void this.onError(o);
                                                this.onComment(e.substring(r + 3, t)), r = t + 3
                                            } else if ("[CDATA[" === e.substring(r + 1, r + 8)) {
                                                if (t = e.indexOf("]]>", r + 8), t < 0) return void this.onError(s);
                                                this.onCdata(e.substring(r + 8, t)), r = t + 3
                                            } else {
                                                if ("DOCTYPE" !== e.substring(r + 1, r + 8)) return void this.onError(l); {
                                                    const n = e.indexOf("[", r + 8);
                                                    let s = !1;
                                                    if (t = e.indexOf(">", r + 8), t < 0) return void this.onError(a);
                                                    if (n > 0 && t > n) {
                                                        if (t = e.indexOf("]>", r + 8), t < 0) return void this.onError(a);
                                                        s = !0
                                                    }
                                                    const i = e.substring(r + 8, t + (s ? 1 : 0));
                                                    this.onDoctype(i), r = t + (s ? 2 : 1)
                                                }
                                            }
                                            break;
                                        default:
                                            const h = this._parseContent(e, r);
                                            if (null === h) return void this.onError(l);
                                            let u = !1;
                                            if ("/>" === e.substring(r + h.parsed, r + h.parsed + 2)) u = !0;
                                            else if (">" !== e.substring(r + h.parsed, r + h.parsed + 1)) return void this.onError(c);
                                            this.onBeginElement(h.name, h.attributes, u), r += h.parsed + (u ? 2 : 1)
                                    }
                                } else {
                                    for (; r < e.length && "<" !== e[r];) r++;
                                    const n = e.substring(t, r);
                                    this.onText(this._resolveEntities(n))
                                }
                                t = r
                            }
                        }
                        onResolveEntity(e) {
                            return `&${e};`
                        }
                        onPi(e, t) {}
                        onComment(e) {}
                        onCdata(e) {}
                        onDoctype(e) {}
                        onText(e) {}
                        onBeginElement(e, t, r) {}
                        onEndElement(e) {}
                        onError(e) {}
                    } {
                        constructor() {
                            super(), this._currentFragment = null, this._stack = null, this._errorCode = n
                        }
                        parseFromString(e) {
                            if (this._currentFragment = [], this._stack = [], this._errorCode = n, this.parseXml(e), this._errorCode !== n) return;
                            const [t] = this._currentFragment;
                            return t ? {
                                documentElement: t
                            } : void 0
                        }
                        onResolveEntity(e) {
                            switch (e) {
                                case "apos":
                                    return "'"
                            }
                            return super.onResolveEntity(e)
                        }
                        onText(e) {
                            if (function(e) {
                                    for (let t = 0, r = e.length; t < r; t++)
                                        if (!h(e, t)) return !1;
                                    return !0
                                }(e)) return;
                            const t = new u("#text", e);
                            this._currentFragment.push(t)
                        }
                        onCdata(e) {
                            const t = new u("#text", e);
                            this._currentFragment.push(t)
                        }
                        onBeginElement(e, t, r) {
                            const n = new u(e);
                            n.childNodes = [], this._currentFragment.push(n), r || (this._stack.push(this._currentFragment), this._currentFragment = n.childNodes)
                        }
                        onEndElement(e) {
                            this._currentFragment = this._stack.pop() || [];
                            const t = this._currentFragment[this._currentFragment.length - 1];
                            if (t)
                                for (let e = 0, r = t.childNodes.length; e < r; e++) t.childNodes[e].parentNode = t
                        }
                        onError(e) {
                            this._errorCode = e
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.PDFDataTransportStream = void 0;
                    var n = r(2);
                    t.PDFDataTransportStream = class {
                        constructor(e, t) {
                            (0, n.assert)(t, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = e.progressiveDone || !1;
                            const r = e.initialData;
                            if (r && r.length > 0) {
                                const e = new Uint8Array(r).buffer;
                                this._queuedChunks.push(e)
                            }
                            this._pdfDataRangeTransport = t, this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._contentLength = e.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener(((e, t) => {
                                this._onReceiveData({
                                    begin: e,
                                    chunk: t
                                })
                            })), this._pdfDataRangeTransport.addProgressListener(((e, t) => {
                                this._onProgress({
                                    loaded: e,
                                    total: t
                                })
                            })), this._pdfDataRangeTransport.addProgressiveReadListener((e => {
                                this._onReceiveData({
                                    chunk: e
                                })
                            })), this._pdfDataRangeTransport.addProgressiveDoneListener((() => {
                                this._onProgressiveDone()
                            })), this._pdfDataRangeTransport.transportReady()
                        }
                        _onReceiveData(e) {
                            const t = new Uint8Array(e.chunk).buffer;
                            if (void 0 === e.begin) this._fullRequestReader ? this._fullRequestReader._enqueue(t) : this._queuedChunks.push(t);
                            else {
                                const r = this._rangeReaders.some((function(r) {
                                    return r._begin === e.begin && (r._enqueue(t), !0)
                                }));
                                (0, n.assert)(r, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.")
                            }
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        _onProgress(e) {
                            if (void 0 === e.total) {
                                const t = this._rangeReaders[0];
                                t && t.onProgress && t.onProgress({
                                    loaded: e.loaded
                                })
                            } else {
                                const t = this._fullRequestReader;
                                t && t.onProgress && t.onProgress({
                                    loaded: e.loaded,
                                    total: e.total
                                })
                            }
                        }
                        _onProgressiveDone() {
                            this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0
                        }
                        _removeRangeReader(e) {
                            const t = this._rangeReaders.indexOf(e);
                            t >= 0 && this._rangeReaders.splice(t, 1)
                        }
                        getFullReader() {
                            (0, n.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                            const e = this._queuedChunks;
                            return this._queuedChunks = null, new s(this, e, this._progressiveDone)
                        }
                        getRangeReader(e, t) {
                            if (t <= this._progressiveDataLength) return null;
                            const r = new i(this, e, t);
                            return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(r), r
                        }
                        cancelAllRequests(e) {
                            this._fullRequestReader && this._fullRequestReader.cancel(e), this._rangeReaders.slice(0).forEach((function(t) {
                                t.cancel(e)
                            })), this._pdfDataRangeTransport.abort()
                        }
                    };
                    class s {
                        constructor(e, t, r = !1) {
                            this._stream = e, this._done = r || !1, this._filename = null, this._queuedChunks = t || [], this._loaded = 0;
                            for (const e of this._queuedChunks) this._loaded += e.byteLength;
                            this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null
                        }
                        _enqueue(e) {
                            this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                                value: e,
                                done: !1
                            }) : this._queuedChunks.push(e), this._loaded += e.byteLength)
                        }
                        get headersReady() {
                            return this._headersReady
                        }
                        get filename() {
                            return this._filename
                        }
                        get isRangeSupported() {
                            return this._stream._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._stream._isStreamingSupported
                        }
                        get contentLength() {
                            return this._stream._contentLength
                        }
                        async read() {
                            if (this._queuedChunks.length > 0) return {
                                value: this._queuedChunks.shift(),
                                done: !1
                            };
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const e = (0, n.createPromiseCapability)();
                            return this._requests.push(e), e.promise
                        }
                        cancel(e) {
                            this._done = !0, this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = []
                        }
                        progressiveDone() {
                            this._done || (this._done = !0)
                        }
                    }
                    class i {
                        constructor(e, t, r) {
                            this._stream = e, this._begin = t, this._end = r, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null
                        }
                        _enqueue(e) {
                            this._done || (0 === this._requests.length ? this._queuedChunk = e : (this._requests.shift().resolve({
                                value: e,
                                done: !1
                            }), this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = []), this._done = !0, this._stream._removeRangeReader(this))
                        }
                        get isStreamingSupported() {
                            return !1
                        }
                        async read() {
                            if (this._queuedChunk) {
                                const e = this._queuedChunk;
                                return this._queuedChunk = null, {
                                    value: e,
                                    done: !1
                                }
                            }
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const e = (0, n.createPromiseCapability)();
                            return this._requests.push(e), e.promise
                        }
                        cancel(e) {
                            this._done = !0, this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = [], this._stream._removeRangeReader(this)
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.WebGLContext = void 0;
                    var n = r(2);
                    t.WebGLContext = class {
                        constructor({
                            enable: e = !1
                        }) {
                            this._enabled = !0 === e
                        }
                        get isEnabled() {
                            let e = this._enabled;
                            return e && (e = s.tryInitGL()), (0, n.shadow)(this, "isEnabled", e)
                        }
                        composeSMask({
                            layer: e,
                            mask: t,
                            properties: r
                        }) {
                            return s.composeSMask(e, t, r)
                        }
                        drawFigures({
                            width: e,
                            height: t,
                            backgroundColor: r,
                            figures: n,
                            context: i
                        }) {
                            return s.drawFigures(e, t, r, n, i)
                        }
                        clear() {
                            s.cleanup()
                        }
                    };
                    var s = function() {
                        function e(e, t, r) {
                            var n = e.createShader(r);
                            if (e.shaderSource(n, t), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) {
                                var s = e.getShaderInfoLog(n);
                                throw new Error("Error during shader compilation: " + s)
                            }
                            return n
                        }

                        function t(t, r) {
                            return e(t, r, t.VERTEX_SHADER)
                        }

                        function r(t, r) {
                            return e(t, r, t.FRAGMENT_SHADER)
                        }

                        function n(e, t) {
                            for (var r = e.createProgram(), n = 0, s = t.length; n < s; ++n) e.attachShader(r, t[n]);
                            if (e.linkProgram(r), !e.getProgramParameter(r, e.LINK_STATUS)) {
                                var i = e.getProgramInfoLog(r);
                                throw new Error("Error during program linking: " + i)
                            }
                            return r
                        }

                        function s(e, t, r) {
                            e.activeTexture(r);
                            var n = e.createTexture();
                            return e.bindTexture(e.TEXTURE_2D, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), n
                        }
                        var i, a;

                        function o() {
                            i || (a = document.createElement("canvas"), i = a.getContext("webgl", {
                                premultipliedalpha: !1
                            }))
                        }
                        var l = null,
                            c = null;
                        return {
                            tryInitGL() {
                                try {
                                    return o(), !!i
                                } catch (e) {}
                                return !1
                            },
                            composeSMask: function(e, c, h) {
                                var u = e.width,
                                    d = e.height;
                                l || function() {
                                    var e, s;
                                    o(), e = a, a = null, s = i, i = null;
                                    var c = n(s, [t(s, "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             "), r(s, "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ")]);
                                    s.useProgram(c);
                                    var h = {};
                                    h.gl = s, h.canvas = e, h.resolutionLocation = s.getUniformLocation(c, "u_resolution"), h.positionLocation = s.getAttribLocation(c, "a_position"), h.backdropLocation = s.getUniformLocation(c, "u_backdrop"), h.subtypeLocation = s.getUniformLocation(c, "u_subtype");
                                    var u = s.getAttribLocation(c, "a_texCoord"),
                                        d = s.getUniformLocation(c, "u_image"),
                                        f = s.getUniformLocation(c, "u_mask"),
                                        p = s.createBuffer();
                                    s.bindBuffer(s.ARRAY_BUFFER, p), s.bufferData(s.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), s.STATIC_DRAW), s.enableVertexAttribArray(u), s.vertexAttribPointer(u, 2, s.FLOAT, !1, 0, 0), s.uniform1i(d, 0), s.uniform1i(f, 1), l = h
                                }();
                                var f = l,
                                    p = f.canvas,
                                    _ = f.gl;
                                p.width = u, p.height = d, _.viewport(0, 0, _.drawingBufferWidth, _.drawingBufferHeight), _.uniform2f(f.resolutionLocation, u, d), h.backdrop ? _.uniform4f(f.resolutionLocation, h.backdrop[0], h.backdrop[1], h.backdrop[2], 1) : _.uniform4f(f.resolutionLocation, 0, 0, 0, 0), _.uniform1i(f.subtypeLocation, "Luminosity" === h.subtype ? 1 : 0);
                                var g = s(_, e, _.TEXTURE0),
                                    m = s(_, c, _.TEXTURE1),
                                    A = _.createBuffer();
                                return _.bindBuffer(_.ARRAY_BUFFER, A), _.bufferData(_.ARRAY_BUFFER, new Float32Array([0, 0, u, 0, 0, d, 0, d, u, 0, u, d]), _.STATIC_DRAW), _.enableVertexAttribArray(f.positionLocation), _.vertexAttribPointer(f.positionLocation, 2, _.FLOAT, !1, 0, 0), _.clearColor(0, 0, 0, 0), _.enable(_.BLEND), _.blendFunc(_.ONE, _.ONE_MINUS_SRC_ALPHA), _.clear(_.COLOR_BUFFER_BIT), _.drawArrays(_.TRIANGLES, 0, 6), _.flush(), _.deleteTexture(g), _.deleteTexture(m), _.deleteBuffer(A), p
                            },
                            drawFigures: function(e, s, l, h, u) {
                                c || function() {
                                    var e, s;
                                    o(), e = a, a = null, s = i, i = null;
                                    var l = n(s, [t(s, "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             "), r(s, "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ")]);
                                    s.useProgram(l);
                                    var h = {};
                                    h.gl = s, h.canvas = e, h.resolutionLocation = s.getUniformLocation(l, "u_resolution"), h.scaleLocation = s.getUniformLocation(l, "u_scale"), h.offsetLocation = s.getUniformLocation(l, "u_offset"), h.positionLocation = s.getAttribLocation(l, "a_position"), h.colorLocation = s.getAttribLocation(l, "a_color"), c = h
                                }();
                                var d = c,
                                    f = d.canvas,
                                    p = d.gl;
                                f.width = e, f.height = s, p.viewport(0, 0, p.drawingBufferWidth, p.drawingBufferHeight), p.uniform2f(d.resolutionLocation, e, s);
                                var _, g, m, A = 0;
                                for (_ = 0, g = h.length; _ < g; _++) switch (h[_].type) {
                                    case "lattice":
                                        A += ((m = h[_].coords.length / h[_].verticesPerRow | 0) - 1) * (h[_].verticesPerRow - 1) * 6;
                                        break;
                                    case "triangles":
                                        A += h[_].coords.length
                                }
                                var y = new Float32Array(2 * A),
                                    b = new Uint8Array(3 * A),
                                    E = u.coords,
                                    v = u.colors,
                                    S = 0,
                                    T = 0;
                                for (_ = 0, g = h.length; _ < g; _++) {
                                    var w = h[_],
                                        R = w.coords,
                                        C = w.colors;
                                    switch (w.type) {
                                        case "lattice":
                                            var I = w.verticesPerRow;
                                            m = R.length / I | 0;
                                            for (var x = 1; x < m; x++)
                                                for (var O = x * I + 1, k = 1; k < I; k++, O++) y[S] = E[R[O - I - 1]], y[S + 1] = E[R[O - I - 1] + 1], y[S + 2] = E[R[O - I]], y[S + 3] = E[R[O - I] + 1], y[S + 4] = E[R[O - 1]], y[S + 5] = E[R[O - 1] + 1], b[T] = v[C[O - I - 1]], b[T + 1] = v[C[O - I - 1] + 1], b[T + 2] = v[C[O - I - 1] + 2], b[T + 3] = v[C[O - I]], b[T + 4] = v[C[O - I] + 1], b[T + 5] = v[C[O - I] + 2], b[T + 6] = v[C[O - 1]], b[T + 7] = v[C[O - 1] + 1], b[T + 8] = v[C[O - 1] + 2], y[S + 6] = y[S + 2], y[S + 7] = y[S + 3], y[S + 8] = y[S + 4], y[S + 9] = y[S + 5], y[S + 10] = E[R[O]], y[S + 11] = E[R[O] + 1], b[T + 9] = b[T + 3], b[T + 10] = b[T + 4], b[T + 11] = b[T + 5], b[T + 12] = b[T + 6], b[T + 13] = b[T + 7], b[T + 14] = b[T + 8], b[T + 15] = v[C[O]], b[T + 16] = v[C[O] + 1], b[T + 17] = v[C[O] + 2], S += 12, T += 18;
                                            break;
                                        case "triangles":
                                            for (var N = 0, L = R.length; N < L; N++) y[S] = E[R[N]], y[S + 1] = E[R[N] + 1], b[T] = v[C[N]], b[T + 1] = v[C[N] + 1], b[T + 2] = v[C[N] + 2], S += 2, T += 3
                                    }
                                }
                                l ? p.clearColor(l[0] / 255, l[1] / 255, l[2] / 255, 1) : p.clearColor(0, 0, 0, 0), p.clear(p.COLOR_BUFFER_BIT);
                                var P = p.createBuffer();
                                p.bindBuffer(p.ARRAY_BUFFER, P), p.bufferData(p.ARRAY_BUFFER, y, p.STATIC_DRAW), p.enableVertexAttribArray(d.positionLocation), p.vertexAttribPointer(d.positionLocation, 2, p.FLOAT, !1, 0, 0);
                                var D = p.createBuffer();
                                return p.bindBuffer(p.ARRAY_BUFFER, D), p.bufferData(p.ARRAY_BUFFER, b, p.STATIC_DRAW), p.enableVertexAttribArray(d.colorLocation), p.vertexAttribPointer(d.colorLocation, 3, p.UNSIGNED_BYTE, !1, 0, 0), p.uniform2f(d.scaleLocation, u.scaleX, u.scaleY), p.uniform2f(d.offsetLocation, u.offsetX, u.offsetY), p.drawArrays(p.TRIANGLES, 0, A), p.flush(), p.deleteBuffer(P), p.deleteBuffer(D), f
                            },
                            cleanup() {
                                l && l.canvas && (l.canvas.width = 0, l.canvas.height = 0), c && c.canvas && (c.canvas.width = 0, c.canvas.height = 0), l = null, c = null
                            }
                        }
                    }()
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.AnnotationLayer = void 0;
                    var n = r(1),
                        s = r(2);
                    class i {
                        static create(e) {
                            switch (e.data.annotationType) {
                                case s.AnnotationType.LINK:
                                    return new o(e);
                                case s.AnnotationType.TEXT:
                                    return new l(e);
                                case s.AnnotationType.WIDGET:
                                    switch (e.data.fieldType) {
                                        case "Tx":
                                            return new h(e);
                                        case "Btn":
                                            return e.data.radioButton ? new d(e) : e.data.checkBox ? new u(e) : new f(e);
                                        case "Ch":
                                            return new p(e)
                                    }
                                    return new c(e);
                                case s.AnnotationType.POPUP:
                                    return new _(e);
                                case s.AnnotationType.FREETEXT:
                                    return new m(e);
                                case s.AnnotationType.LINE:
                                    return new A(e);
                                case s.AnnotationType.SQUARE:
                                    return new y(e);
                                case s.AnnotationType.CIRCLE:
                                    return new b(e);
                                case s.AnnotationType.POLYLINE:
                                    return new E(e);
                                case s.AnnotationType.CARET:
                                    return new S(e);
                                case s.AnnotationType.INK:
                                    return new T(e);
                                case s.AnnotationType.POLYGON:
                                    return new v(e);
                                case s.AnnotationType.HIGHLIGHT:
                                    return new w(e);
                                case s.AnnotationType.UNDERLINE:
                                    return new R(e);
                                case s.AnnotationType.SQUIGGLY:
                                    return new C(e);
                                case s.AnnotationType.STRIKEOUT:
                                    return new I(e);
                                case s.AnnotationType.STAMP:
                                    return new x(e);
                                case s.AnnotationType.FILEATTACHMENT:
                                    return new O(e);
                                default:
                                    return new a(e)
                            }
                        }
                    }
                    class a {
                        constructor(e, t = !1, r = !1) {
                            this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.page = e.page, this.viewport = e.viewport, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderInteractiveForms = e.renderInteractiveForms, this.svgFactory = e.svgFactory, t && (this.container = this._createContainer(r))
                        }
                        _createContainer(e = !1) {
                            const t = this.data,
                                r = this.page,
                                n = this.viewport,
                                i = document.createElement("section");
                            let a = t.rect[2] - t.rect[0],
                                o = t.rect[3] - t.rect[1];
                            i.setAttribute("data-annotation-id", t.id);
                            const l = s.Util.normalizeRect([t.rect[0], r.view[3] - t.rect[1] + r.view[1], t.rect[2], r.view[3] - t.rect[3] + r.view[1]]);
                            if (i.style.transform = `matrix(${n.transform.join(",")})`, i.style.transformOrigin = `-${l[0]}px -${l[1]}px`, !e && t.borderStyle.width > 0) {
                                i.style.borderWidth = `${t.borderStyle.width}px`, t.borderStyle.style !== s.AnnotationBorderStyleType.UNDERLINE && (a -= 2 * t.borderStyle.width, o -= 2 * t.borderStyle.width);
                                const e = t.borderStyle.horizontalCornerRadius,
                                    r = t.borderStyle.verticalCornerRadius;
                                if (e > 0 || r > 0) {
                                    const t = `${e}px / ${r}px`;
                                    i.style.borderRadius = t
                                }
                                switch (t.borderStyle.style) {
                                    case s.AnnotationBorderStyleType.SOLID:
                                        i.style.borderStyle = "solid";
                                        break;
                                    case s.AnnotationBorderStyleType.DASHED:
                                        i.style.borderStyle = "dashed";
                                        break;
                                    case s.AnnotationBorderStyleType.BEVELED:
                                        (0, s.warn)("Unimplemented border style: beveled");
                                        break;
                                    case s.AnnotationBorderStyleType.INSET:
                                        (0, s.warn)("Unimplemented border style: inset");
                                        break;
                                    case s.AnnotationBorderStyleType.UNDERLINE:
                                        i.style.borderBottomStyle = "solid"
                                }
                                t.color ? i.style.borderColor = s.Util.makeCssRgb(0 | t.color[0], 0 | t.color[1], 0 | t.color[2]) : i.style.borderWidth = 0
                            }
                            return i.style.left = `${l[0]}px`, i.style.top = `${l[1]}px`, i.style.width = `${a}px`, i.style.height = `${o}px`, i
                        }
                        _createPopup(e, t, r) {
                            t || ((t = document.createElement("div")).style.height = e.style.height, t.style.width = e.style.width, e.appendChild(t));
                            const n = new g({
                                container: e,
                                trigger: t,
                                color: r.color,
                                title: r.title,
                                modificationDate: r.modificationDate,
                                contents: r.contents,
                                hideWrapper: !0
                            }).render();
                            n.style.left = e.style.width, e.appendChild(n)
                        }
                        render() {
                            (0, s.unreachable)("Abstract method `AnnotationElement.render` called")
                        }
                    }
                    class o extends a {
                        constructor(e) {
                            super(e, !!(e.data.url || e.data.dest || e.data.action))
                        }
                        render() {
                            this.container.className = "linkAnnotation";
                            const {
                                data: e,
                                linkService: t
                            } = this, r = document.createElement("a");
                            return e.url ? (0, n.addLinkAttributes)(r, {
                                url: e.url,
                                target: e.newWindow ? n.LinkTarget.BLANK : t.externalLinkTarget,
                                rel: t.externalLinkRel,
                                enabled: t.externalLinkEnabled
                            }) : e.action ? this._bindNamedAction(r, e.action) : this._bindLink(r, e.dest), this.container.appendChild(r), this.container
                        }
                        _bindLink(e, t) {
                            e.href = this.linkService.getDestinationHash(t), e.onclick = () => (t && this.linkService.navigateTo(t), !1), t && (e.className = "internalLink")
                        }
                        _bindNamedAction(e, t) {
                            e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(t), !1), e.className = "internalLink"
                        }
                    }
                    class l extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents))
                        }
                        render() {
                            this.container.className = "textAnnotation";
                            const e = document.createElement("img");
                            return e.style.height = this.container.style.height, e.style.width = this.container.style.width, e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.alt = "[{{type}} Annotation]", e.dataset.l10nId = "text_annotation_type", e.dataset.l10nArgs = JSON.stringify({
                                type: this.data.name
                            }), this.data.hasPopup || this._createPopup(this.container, e, this.data), this.container.appendChild(e), this.container
                        }
                    }
                    class c extends a {
                        render() {
                            return this.container
                        }
                    }
                    class h extends c {
                        constructor(e) {
                            super(e, e.renderInteractiveForms || !e.data.hasAppearance && !!e.data.fieldValue)
                        }
                        render() {
                            const e = ["left", "center", "right"];
                            this.container.className = "textWidgetAnnotation";
                            let t = null;
                            if (this.renderInteractiveForms) {
                                if (this.data.multiLine ? (t = document.createElement("textarea"), t.textContent = this.data.fieldValue) : (t = document.createElement("input"), t.type = "text", t.setAttribute("value", this.data.fieldValue)), t.disabled = this.data.readOnly, t.name = this.data.fieldName, null !== this.data.maxLen && (t.maxLength = this.data.maxLen), this.data.comb) {
                                    const e = (this.data.rect[2] - this.data.rect[0]) / this.data.maxLen;
                                    t.classList.add("comb"), t.style.letterSpacing = `calc(${e}px - 1ch)`
                                }
                            } else {
                                t = document.createElement("div"), t.textContent = this.data.fieldValue, t.style.verticalAlign = "middle", t.style.display = "table-cell";
                                let e = null;
                                this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName) && (e = this.page.commonObjs.get(this.data.fontRefName)), this._setTextStyle(t, e)
                            }
                            return null !== this.data.textAlignment && (t.style.textAlign = e[this.data.textAlignment]), this.container.appendChild(t), this.container
                        }
                        _setTextStyle(e, t) {
                            const r = e.style;
                            if (r.fontSize = `${this.data.fontSize}px`, r.direction = this.data.fontDirection < 0 ? "rtl" : "ltr", !t) return;
                            let n = "normal";
                            t.black ? n = "900" : t.bold && (n = "bold"), r.fontWeight = n, r.fontStyle = t.italic ? "italic" : "normal";
                            const s = t.loadedName ? `"${t.loadedName}", ` : "",
                                i = t.fallbackName || "Helvetica, sans-serif";
                            r.fontFamily = s + i
                        }
                    }
                    class u extends c {
                        constructor(e) {
                            super(e, e.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "buttonWidgetAnnotation checkBox";
                            const e = document.createElement("input");
                            return e.disabled = this.data.readOnly, e.type = "checkbox", e.name = this.data.fieldName, this.data.fieldValue && "Off" !== this.data.fieldValue && e.setAttribute("checked", !0), this.container.appendChild(e), this.container
                        }
                    }
                    class d extends c {
                        constructor(e) {
                            super(e, e.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "buttonWidgetAnnotation radioButton";
                            const e = document.createElement("input");
                            return e.disabled = this.data.readOnly, e.type = "radio", e.name = this.data.fieldName, this.data.fieldValue === this.data.buttonValue && e.setAttribute("checked", !0), this.container.appendChild(e), this.container
                        }
                    }
                    class f extends o {
                        render() {
                            const e = super.render();
                            return e.className = "buttonWidgetAnnotation pushButton", e
                        }
                    }
                    class p extends c {
                        constructor(e) {
                            super(e, e.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "choiceWidgetAnnotation";
                            const e = document.createElement("select");
                            e.disabled = this.data.readOnly, e.name = this.data.fieldName, this.data.combo || (e.size = this.data.options.length, this.data.multiSelect && (e.multiple = !0));
                            for (const t of this.data.options) {
                                const r = document.createElement("option");
                                r.textContent = t.displayValue, r.value = t.exportValue, this.data.fieldValue.includes(t.displayValue) && r.setAttribute("selected", !0), e.appendChild(r)
                            }
                            return this.container.appendChild(e), this.container
                        }
                    }
                    class _ extends a {
                        constructor(e) {
                            super(e, !(!e.data.title && !e.data.contents))
                        }
                        render() {
                            if (this.container.className = "popupAnnotation", ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"].includes(this.data.parentType)) return this.container;
                            const e = `[data-annotation-id="${this.data.parentId}"]`,
                                t = this.layer.querySelector(e);
                            if (!t) return this.container;
                            const r = new g({
                                    container: this.container,
                                    trigger: t,
                                    color: this.data.color,
                                    title: this.data.title,
                                    modificationDate: this.data.modificationDate,
                                    contents: this.data.contents
                                }),
                                n = parseFloat(t.style.left),
                                s = parseFloat(t.style.width);
                            return this.container.style.transformOrigin = `-${n+s}px -${t.style.top}`, this.container.style.left = `${n+s}px`, this.container.appendChild(r.render()), this.container
                        }
                    }
                    class g {
                        constructor(e) {
                            this.container = e.container, this.trigger = e.trigger, this.color = e.color, this.title = e.title, this.modificationDate = e.modificationDate, this.contents = e.contents, this.hideWrapper = e.hideWrapper || !1, this.pinned = !1
                        }
                        render() {
                            const e = document.createElement("div");
                            e.className = "popupWrapper", this.hideElement = this.hideWrapper ? e : this.container, this.hideElement.setAttribute("hidden", !0);
                            const t = document.createElement("div");
                            t.className = "popup";
                            const r = this.color;
                            if (r) {
                                const e = .7 * (255 - r[0]) + r[0],
                                    n = .7 * (255 - r[1]) + r[1],
                                    i = .7 * (255 - r[2]) + r[2];
                                t.style.backgroundColor = s.Util.makeCssRgb(0 | e, 0 | n, 0 | i)
                            }
                            const i = document.createElement("h1");
                            i.textContent = this.title, t.appendChild(i);
                            const a = n.PDFDateString.toDateObject(this.modificationDate);
                            if (a) {
                                const e = document.createElement("span");
                                e.textContent = "{{date}}, {{time}}", e.dataset.l10nId = "annotation_date_string", e.dataset.l10nArgs = JSON.stringify({
                                    date: a.toLocaleDateString(),
                                    time: a.toLocaleTimeString()
                                }), t.appendChild(e)
                            }
                            const o = this._formatContents(this.contents);
                            return t.appendChild(o), this.trigger.addEventListener("click", this._toggle.bind(this)), this.trigger.addEventListener("mouseover", this._show.bind(this, !1)), this.trigger.addEventListener("mouseout", this._hide.bind(this, !1)), t.addEventListener("click", this._hide.bind(this, !0)), e.appendChild(t), e
                        }
                        _formatContents(e) {
                            const t = document.createElement("p"),
                                r = e.split(/(?:\r\n?|\n)/);
                            for (let e = 0, n = r.length; e < n; ++e) {
                                const s = r[e];
                                t.appendChild(document.createTextNode(s)), e < n - 1 && t.appendChild(document.createElement("br"))
                            }
                            return t
                        }
                        _toggle() {
                            this.pinned ? this._hide(!0) : this._show(!0)
                        }
                        _show(e = !1) {
                            e && (this.pinned = !0), this.hideElement.hasAttribute("hidden") && (this.hideElement.removeAttribute("hidden"), this.container.style.zIndex += 1)
                        }
                        _hide(e = !0) {
                            e && (this.pinned = !1), this.hideElement.hasAttribute("hidden") || this.pinned || (this.hideElement.setAttribute("hidden", !0), this.container.style.zIndex -= 1)
                        }
                    }
                    class m extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "freeTextAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class A extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            this.container.className = "lineAnnotation";
                            const e = this.data,
                                t = e.rect[2] - e.rect[0],
                                r = e.rect[3] - e.rect[1],
                                n = this.svgFactory.create(t, r),
                                s = this.svgFactory.createElement("svg:line");
                            return s.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), s.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), s.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), s.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), s.setAttribute("stroke-width", e.borderStyle.width || 1), s.setAttribute("stroke", "transparent"), n.appendChild(s), this.container.append(n), this._createPopup(this.container, s, e), this.container
                        }
                    }
                    class y extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            this.container.className = "squareAnnotation";
                            const e = this.data,
                                t = e.rect[2] - e.rect[0],
                                r = e.rect[3] - e.rect[1],
                                n = this.svgFactory.create(t, r),
                                s = e.borderStyle.width,
                                i = this.svgFactory.createElement("svg:rect");
                            return i.setAttribute("x", s / 2), i.setAttribute("y", s / 2), i.setAttribute("width", t - s), i.setAttribute("height", r - s), i.setAttribute("stroke-width", s || 1), i.setAttribute("stroke", "transparent"), i.setAttribute("fill", "none"), n.appendChild(i), this.container.append(n), this._createPopup(this.container, i, e), this.container
                        }
                    }
                    class b extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            this.container.className = "circleAnnotation";
                            const e = this.data,
                                t = e.rect[2] - e.rect[0],
                                r = e.rect[3] - e.rect[1],
                                n = this.svgFactory.create(t, r),
                                s = e.borderStyle.width,
                                i = this.svgFactory.createElement("svg:ellipse");
                            return i.setAttribute("cx", t / 2), i.setAttribute("cy", r / 2), i.setAttribute("rx", t / 2 - s / 2), i.setAttribute("ry", r / 2 - s / 2), i.setAttribute("stroke-width", s || 1), i.setAttribute("stroke", "transparent"), i.setAttribute("fill", "none"), n.appendChild(i), this.container.append(n), this._createPopup(this.container, i, e), this.container
                        }
                    }
                    class E extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline"
                        }
                        render() {
                            this.container.className = this.containerClassName;
                            const e = this.data,
                                t = e.rect[2] - e.rect[0],
                                r = e.rect[3] - e.rect[1],
                                n = this.svgFactory.create(t, r);
                            let s = [];
                            for (const t of e.vertices) {
                                const r = t.x - e.rect[0],
                                    n = e.rect[3] - t.y;
                                s.push(r + "," + n)
                            }
                            s = s.join(" ");
                            const i = this.svgFactory.createElement(this.svgElementName);
                            return i.setAttribute("points", s), i.setAttribute("stroke-width", e.borderStyle.width || 1), i.setAttribute("stroke", "transparent"), i.setAttribute("fill", "none"), n.appendChild(i), this.container.append(n), this._createPopup(this.container, i, e), this.container
                        }
                    }
                    class v extends E {
                        constructor(e) {
                            super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon"
                        }
                    }
                    class S extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class T extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline"
                        }
                        render() {
                            this.container.className = this.containerClassName;
                            const e = this.data,
                                t = e.rect[2] - e.rect[0],
                                r = e.rect[3] - e.rect[1],
                                n = this.svgFactory.create(t, r);
                            for (const t of e.inkLists) {
                                let r = [];
                                for (const n of t) {
                                    const t = n.x - e.rect[0],
                                        s = e.rect[3] - n.y;
                                    r.push(`${t},${s}`)
                                }
                                r = r.join(" ");
                                const s = this.svgFactory.createElement(this.svgElementName);
                                s.setAttribute("points", r), s.setAttribute("stroke-width", e.borderStyle.width || 1), s.setAttribute("stroke", "transparent"), s.setAttribute("fill", "none"), this._createPopup(this.container, s, e), n.appendChild(s)
                            }
                            return this.container.append(n), this.container
                        }
                    }
                    class w extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "highlightAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class R extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "underlineAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class C extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "squigglyAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class I extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "strikeoutAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class x extends a {
                        constructor(e) {
                            super(e, !!(e.data.hasPopup || e.data.title || e.data.contents), !0)
                        }
                        render() {
                            return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class O extends a {
                        constructor(e) {
                            super(e, !0);
                            const {
                                filename: t,
                                content: r
                            } = this.data.file;
                            this.filename = (0, n.getFilenameFromUrl)(t), this.content = r, this.linkService.eventBus && this.linkService.eventBus.dispatch("fileattachmentannotation", {
                                source: this,
                                id: (0, s.stringToPDFString)(t),
                                filename: t,
                                content: r
                            })
                        }
                        render() {
                            this.container.className = "fileAttachmentAnnotation";
                            const e = document.createElement("div");
                            return e.style.height = this.container.style.height, e.style.width = this.container.style.width, e.addEventListener("dblclick", this._download.bind(this)), this.data.hasPopup || !this.data.title && !this.data.contents || this._createPopup(this.container, e, this.data), this.container.appendChild(e), this.container
                        }
                        _download() {
                            this.downloadManager ? this.downloadManager.downloadData(this.content, this.filename, "") : (0, s.warn)("Download cannot be started due to unavailable download manager")
                        }
                    }
                    t.AnnotationLayer = class {
                        static render(e) {
                            const t = [],
                                r = [];
                            for (const n of e.annotations) n && (n.annotationType !== s.AnnotationType.POPUP ? t.push(n) : r.push(n));
                            r.length && t.push(...r);
                            for (const r of t) {
                                const t = i.create({
                                    data: r,
                                    layer: e.div,
                                    page: e.page,
                                    viewport: e.viewport,
                                    linkService: e.linkService,
                                    downloadManager: e.downloadManager,
                                    imageResourcesPath: e.imageResourcesPath || "",
                                    renderInteractiveForms: e.renderInteractiveForms || !1,
                                    svgFactory: new n.DOMSVGFactory
                                });
                                t.isRenderable && e.div.appendChild(t.render())
                            }
                        }
                        static update(e) {
                            for (const t of e.annotations) {
                                const r = e.div.querySelector(`[data-annotation-id="${t.id}"]`);
                                r && (r.style.transform = `matrix(${e.viewport.transform.join(",")})`)
                            }
                            e.div.removeAttribute("hidden")
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.renderTextLayer = void 0;
                    var n = r(2),
                        s = function() {
                            var e = /\S/;

                            function t(t, r, s) {
                                var i, a = document.createElement("span"),
                                    o = {
                                        angle: 0,
                                        canvasWidth: 0,
                                        isWhitespace: !1,
                                        originalTransform: null,
                                        paddingBottom: 0,
                                        paddingLeft: 0,
                                        paddingRight: 0,
                                        paddingTop: 0,
                                        scale: 1
                                    };
                                if (t._textDivs.push(a), i = r.str, !e.test(i)) return o.isWhitespace = !0, void t._textDivProperties.set(a, o);
                                var l = n.Util.transform(t._viewport.transform, r.transform),
                                    c = Math.atan2(l[1], l[0]),
                                    h = s[r.fontName];
                                h.vertical && (c += Math.PI / 2);
                                var u = Math.sqrt(l[2] * l[2] + l[3] * l[3]),
                                    d = u;
                                let f, p;
                                h.ascent ? d = h.ascent * d : h.descent && (d = (1 + h.descent) * d), 0 === c ? (f = l[4], p = l[5] - d) : (f = l[4] + d * Math.sin(c), p = l[5] - d * Math.cos(c)), a.style.left = `${f}px`, a.style.top = `${p}px`, a.style.fontSize = `${u}px`, a.style.fontFamily = h.fontFamily, a.textContent = r.str, t._fontInspectorEnabled && (a.dataset.fontName = r.fontName), 0 !== c && (o.angle = c * (180 / Math.PI));
                                let _ = !1;
                                if (r.str.length > 1) _ = !0;
                                else if (r.transform[0] !== r.transform[3]) {
                                    const e = Math.abs(r.transform[0]),
                                        t = Math.abs(r.transform[3]);
                                    e !== t && Math.max(e, t) / Math.min(e, t) > 1.5 && (_ = !0)
                                }
                                if (_ && (h.vertical ? o.canvasWidth = r.height * t._viewport.scale : o.canvasWidth = r.width * t._viewport.scale), t._textDivProperties.set(a, o), t._textContentStream && t._layoutText(a), t._enhanceTextSelection) {
                                    var g = 1,
                                        m = 0;
                                    0 !== c && (g = Math.cos(c), m = Math.sin(c));
                                    var A, y, b = (h.vertical ? r.height : r.width) * t._viewport.scale,
                                        E = u;
                                    0 !== c ? (A = [g, m, -m, g, f, p], y = n.Util.getAxialAlignedBoundingBox([0, 0, b, E], A)) : y = [f, p, f + b, p + E], t._bounds.push({
                                        left: y[0],
                                        top: y[1],
                                        right: y[2],
                                        bottom: y[3],
                                        div: a,
                                        size: [b, E],
                                        m: A
                                    })
                                }
                            }

                            function r(e) {
                                if (!e._canceled) {
                                    var t = e._textDivs,
                                        r = e._capability,
                                        n = t.length;
                                    if (n > 1e5) return e._renderingDone = !0, void r.resolve();
                                    if (!e._textContentStream)
                                        for (var s = 0; s < n; s++) e._layoutText(t[s]);
                                    e._renderingDone = !0, r.resolve()
                                }
                            }

                            function s(e, t, r) {
                                let n = 0;
                                for (let s = 0; s < r; s++) {
                                    const r = e[t++];
                                    r > 0 && (n = n ? Math.min(r, n) : r)
                                }
                                return n
                            }

                            function i(e) {
                                for (var t = e._bounds, r = e._viewport, i = function(e, t, r) {
                                        var n = r.map((function(e, t) {
                                            return {
                                                x1: e.left,
                                                y1: e.top,
                                                x2: e.right,
                                                y2: e.bottom,
                                                index: t,
                                                x1New: void 0,
                                                x2New: void 0
                                            }
                                        }));
                                        a(e, n);
                                        var s = new Array(r.length);
                                        return n.forEach((function(e) {
                                            var t = e.index;
                                            s[t] = {
                                                left: e.x1New,
                                                top: 0,
                                                right: e.x2New,
                                                bottom: 0
                                            }
                                        })), r.map((function(t, r) {
                                            var i = s[r],
                                                a = n[r];
                                            a.x1 = t.top, a.y1 = e - i.right, a.x2 = t.bottom, a.y2 = e - i.left, a.index = r, a.x1New = void 0, a.x2New = void 0
                                        })), a(t, n), n.forEach((function(e) {
                                            var t = e.index;
                                            s[t].top = e.x1New, s[t].bottom = e.x2New
                                        })), s
                                    }(r.width, r.height, t), o = 0; o < i.length; o++) {
                                    var l = t[o].div,
                                        c = e._textDivProperties.get(l);
                                    if (0 !== c.angle) {
                                        var h = i[o],
                                            u = t[o],
                                            d = u.m,
                                            f = d[0],
                                            p = d[1],
                                            _ = [
                                                [0, 0],
                                                [0, u.size[1]],
                                                [u.size[0], 0], u.size
                                            ],
                                            g = new Float64Array(64);
                                        _.forEach((function(e, t) {
                                            var r = n.Util.applyTransform(e, d);
                                            g[t + 0] = f && (h.left - r[0]) / f, g[t + 4] = p && (h.top - r[1]) / p, g[t + 8] = f && (h.right - r[0]) / f, g[t + 12] = p && (h.bottom - r[1]) / p, g[t + 16] = p && (h.left - r[0]) / -p, g[t + 20] = f && (h.top - r[1]) / f, g[t + 24] = p && (h.right - r[0]) / -p, g[t + 28] = f && (h.bottom - r[1]) / f, g[t + 32] = f && (h.left - r[0]) / -f, g[t + 36] = p && (h.top - r[1]) / -p, g[t + 40] = f && (h.right - r[0]) / -f, g[t + 44] = p && (h.bottom - r[1]) / -p, g[t + 48] = p && (h.left - r[0]) / p, g[t + 52] = f && (h.top - r[1]) / -f, g[t + 56] = p && (h.right - r[0]) / p, g[t + 60] = f && (h.bottom - r[1]) / -f
                                        }));
                                        var m = 1 + Math.min(Math.abs(f), Math.abs(p));
                                        c.paddingLeft = s(g, 32, 16) / m, c.paddingTop = s(g, 48, 16) / m, c.paddingRight = s(g, 0, 16) / m, c.paddingBottom = s(g, 16, 16) / m, e._textDivProperties.set(l, c)
                                    } else c.paddingLeft = t[o].left - i[o].left, c.paddingTop = t[o].top - i[o].top, c.paddingRight = i[o].right - t[o].right, c.paddingBottom = i[o].bottom - t[o].bottom, e._textDivProperties.set(l, c)
                                }
                            }

                            function a(e, t) {
                                t.sort((function(e, t) {
                                    return e.x1 - t.x1 || e.index - t.index
                                }));
                                var r = [{
                                    start: -1 / 0,
                                    end: 1 / 0,
                                    boundary: {
                                        x1: -1 / 0,
                                        y1: -1 / 0,
                                        x2: 0,
                                        y2: 1 / 0,
                                        index: -1,
                                        x1New: 0,
                                        x2New: 0
                                    }
                                }];
                                t.forEach((function(e) {
                                    for (var t = 0; t < r.length && r[t].end <= e.y1;) t++;
                                    for (var n, s, i = r.length - 1; i >= 0 && r[i].start >= e.y2;) i--;
                                    var a, o, l = -1 / 0;
                                    for (a = t; a <= i; a++) {
                                        var c;
                                        (c = (s = (n = r[a]).boundary).x2 > e.x1 ? s.index > e.index ? s.x1New : e.x1 : void 0 === s.x2New ? (s.x2 + e.x1) / 2 : s.x2New) > l && (l = c)
                                    }
                                    for (e.x1New = l, a = t; a <= i; a++) void 0 === (s = (n = r[a]).boundary).x2New ? s.x2 > e.x1 ? s.index > e.index && (s.x2New = s.x2) : s.x2New = l : s.x2New > l && (s.x2New = Math.max(l, s.x2));
                                    var h = [],
                                        u = null;
                                    for (a = t; a <= i; a++) {
                                        var d = (s = (n = r[a]).boundary).x2 > e.x2 ? s : e;
                                        u === d ? h[h.length - 1].end = n.end : (h.push({
                                            start: n.start,
                                            end: n.end,
                                            boundary: d
                                        }), u = d)
                                    }
                                    for (r[t].start < e.y1 && (h[0].start = e.y1, h.unshift({
                                            start: r[t].start,
                                            end: e.y1,
                                            boundary: r[t].boundary
                                        })), e.y2 < r[i].end && (h[h.length - 1].end = e.y2, h.push({
                                            start: e.y2,
                                            end: r[i].end,
                                            boundary: r[i].boundary
                                        })), a = t; a <= i; a++)
                                        if (void 0 === (s = (n = r[a]).boundary).x2New) {
                                            var f = !1;
                                            for (o = t - 1; !f && o >= 0 && r[o].start >= s.y1; o--) f = r[o].boundary === s;
                                            for (o = i + 1; !f && o < r.length && r[o].end <= s.y2; o++) f = r[o].boundary === s;
                                            for (o = 0; !f && o < h.length; o++) f = h[o].boundary === s;
                                            f || (s.x2New = l)
                                        } Array.prototype.splice.apply(r, [t, i - t + 1].concat(h))
                                })), r.forEach((function(t) {
                                    var r = t.boundary;
                                    void 0 === r.x2New && (r.x2New = Math.max(e, r.x2))
                                }))
                            }

                            function o({
                                textContent: e,
                                textContentStream: t,
                                container: r,
                                viewport: s,
                                textDivs: i,
                                textContentItemsStr: a,
                                enhanceTextSelection: o
                            }) {
                                this._textContent = e, this._textContentStream = t, this._container = r, this._viewport = s, this._textDivs = i || [], this._textContentItemsStr = a || [], this._enhanceTextSelection = !!o, this._fontInspectorEnabled = !(!globalThis.FontInspector || !globalThis.FontInspector.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = new WeakMap, this._renderingDone = !1, this._canceled = !1, this._capability = (0, n.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._capability.promise.finally((() => {
                                    this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null)
                                })).catch((() => {}))
                            }
                            return o.prototype = {
                                    get promise() {
                                        return this._capability.promise
                                    },
                                    cancel: function() {
                                        this._canceled = !0, this._reader && (this._reader.cancel(new n.AbortException("TextLayer task cancelled.")), this._reader = null), null !== this._renderTimer && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."))
                                    },
                                    _processItems(e, r) {
                                        for (let n = 0, s = e.length; n < s; n++) this._textContentItemsStr.push(e[n].str), t(this, e[n], r)
                                    },
                                    _layoutText(e) {
                                        const t = this._textDivProperties.get(e);
                                        if (t.isWhitespace) return;
                                        let r = "";
                                        if (0 !== t.canvasWidth) {
                                            const {
                                                fontSize: n,
                                                fontFamily: s
                                            } = e.style;
                                            n === this._layoutTextLastFontSize && s === this._layoutTextLastFontFamily || (this._layoutTextCtx.font = `${n} ${s}`, this._layoutTextLastFontSize = n, this._layoutTextLastFontFamily = s);
                                            const {
                                                width: i
                                            } = this._layoutTextCtx.measureText(e.textContent);
                                            i > 0 && (t.scale = t.canvasWidth / i, r = `scaleX(${t.scale})`)
                                        }
                                        0 !== t.angle && (r = `rotate(${t.angle}deg) ${r}`), r.length > 0 && (this._enhanceTextSelection && (t.originalTransform = r), e.style.transform = r), this._textDivProperties.set(e, t), this._container.appendChild(e)
                                    },
                                    _render: function(e) {
                                        const t = (0, n.createPromiseCapability)();
                                        let s = Object.create(null);
                                        const i = document.createElement("canvas");
                                        if (i.mozOpaque = !0, this._layoutTextCtx = i.getContext("2d", {
                                                alpha: !1
                                            }), this._textContent) {
                                            const e = this._textContent.items,
                                                r = this._textContent.styles;
                                            this._processItems(e, r), t.resolve()
                                        } else {
                                            if (!this._textContentStream) throw new Error('Neither "textContent" nor "textContentStream" parameters specified.'); {
                                                const e = () => {
                                                    this._reader.read().then((({
                                                        value: r,
                                                        done: n
                                                    }) => {
                                                        n ? t.resolve() : (Object.assign(s, r.styles), this._processItems(r.items, s), e())
                                                    }), t.reject)
                                                };
                                                this._reader = this._textContentStream.getReader(), e()
                                            }
                                        }
                                        t.promise.then((() => {
                                            s = null, e ? this._renderTimer = setTimeout((() => {
                                                r(this), this._renderTimer = null
                                            }), e) : r(this)
                                        }), this._capability.reject)
                                    },
                                    expandTextDivs: function(e) {
                                        if (!this._enhanceTextSelection || !this._renderingDone) return;
                                        null !== this._bounds && (i(this), this._bounds = null);
                                        const t = [],
                                            r = [];
                                        for (var n = 0, s = this._textDivs.length; n < s; n++) {
                                            const s = this._textDivs[n],
                                                i = this._textDivProperties.get(s);
                                            i.isWhitespace || (e ? (t.length = 0, r.length = 0, i.originalTransform && t.push(i.originalTransform), i.paddingTop > 0 ? (r.push(`${i.paddingTop}px`), t.push(`translateY(${-i.paddingTop}px)`)) : r.push(0), i.paddingRight > 0 ? r.push(i.paddingRight / i.scale + "px") : r.push(0), i.paddingBottom > 0 ? r.push(`${i.paddingBottom}px`) : r.push(0), i.paddingLeft > 0 ? (r.push(i.paddingLeft / i.scale + "px"), t.push(`translateX(${-i.paddingLeft/i.scale}px)`)) : r.push(0), s.style.padding = r.join(" "), t.length && (s.style.transform = t.join(" "))) : (s.style.padding = null, s.style.transform = i.originalTransform))
                                        }
                                    }
                                },
                                function(e) {
                                    var t = new o({
                                        textContent: e.textContent,
                                        textContentStream: e.textContentStream,
                                        container: e.container,
                                        viewport: e.viewport,
                                        textDivs: e.textDivs,
                                        textContentItemsStr: e.textContentItemsStr,
                                        enhanceTextSelection: e.enhanceTextSelection
                                    });
                                    return t._render(e.timeout), t
                                }
                        }();
                    t.renderTextLayer = s
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.SVGGraphics = void 0;
                    var n = r(2),
                        s = r(1),
                        i = r(4);
                    let a = function() {
                        throw new Error("Not implemented: SVGGraphics")
                    };
                    t.SVGGraphics = a; {
                        const e = {
                                fontStyle: "normal",
                                fontWeight: "normal",
                                fillColor: "#000000"
                            },
                            r = "http://www.w3.org/XML/1998/namespace",
                            o = "http://www.w3.org/1999/xlink",
                            l = ["butt", "round", "square"],
                            c = ["miter", "round", "bevel"],
                            h = function() {
                                const e = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
                                    t = new Int32Array(256);
                                for (let e = 0; e < 256; e++) {
                                    let r = e;
                                    for (let e = 0; e < 8; e++) r = 1 & r ? 3988292384 ^ r >> 1 & 2147483647 : r >> 1 & 2147483647;
                                    t[e] = r
                                }

                                function r(e, r, n, s) {
                                    let i = s;
                                    const a = r.length;
                                    n[i] = a >> 24 & 255, n[i + 1] = a >> 16 & 255, n[i + 2] = a >> 8 & 255, n[i + 3] = 255 & a, i += 4, n[i] = 255 & e.charCodeAt(0), n[i + 1] = 255 & e.charCodeAt(1), n[i + 2] = 255 & e.charCodeAt(2), n[i + 3] = 255 & e.charCodeAt(3), i += 4, n.set(r, i), i += r.length;
                                    const o = function(e, r, n) {
                                        let s = -1;
                                        for (let i = r; i < n; i++) {
                                            const r = 255 & (s ^ e[i]);
                                            s = s >>> 8 ^ t[r]
                                        }
                                        return -1 ^ s
                                    }(n, s + 4, i);
                                    n[i] = o >> 24 & 255, n[i + 1] = o >> 16 & 255, n[i + 2] = o >> 8 & 255, n[i + 3] = 255 & o
                                }

                                function s(e) {
                                    let t = e.length;
                                    const r = 65535,
                                        n = Math.ceil(t / r),
                                        s = new Uint8Array(2 + t + 5 * n + 4);
                                    let i = 0;
                                    s[i++] = 120, s[i++] = 156;
                                    let a = 0;
                                    for (; t > r;) s[i++] = 0, s[i++] = 255, s[i++] = 255, s[i++] = 0, s[i++] = 0, s.set(e.subarray(a, a + r), i), i += r, a += r, t -= r;
                                    s[i++] = 1, s[i++] = 255 & t, s[i++] = t >> 8 & 255, s[i++] = 255 & ~t, s[i++] = (65535 & ~t) >> 8 & 255, s.set(e.subarray(a), i), i += e.length - a;
                                    const o = function(e, t, r) {
                                        let n = 1,
                                            s = 0;
                                        for (let i = t; i < r; ++i) n = (n + (255 & e[i])) % 65521, s = (s + n) % 65521;
                                        return s << 16 | n
                                    }(e, 0, e.length);
                                    return s[i++] = o >> 24 & 255, s[i++] = o >> 16 & 255, s[i++] = o >> 8 & 255, s[i++] = 255 & o, s
                                }

                                function a(t, a, o, l) {
                                    const c = t.width,
                                        h = t.height;
                                    let u, d, f;
                                    const p = t.data;
                                    switch (a) {
                                        case n.ImageKind.GRAYSCALE_1BPP:
                                            d = 0, u = 1, f = c + 7 >> 3;
                                            break;
                                        case n.ImageKind.RGB_24BPP:
                                            d = 2, u = 8, f = 3 * c;
                                            break;
                                        case n.ImageKind.RGBA_32BPP:
                                            d = 6, u = 8, f = 4 * c;
                                            break;
                                        default:
                                            throw new Error("invalid format")
                                    }
                                    const _ = new Uint8Array((1 + f) * h);
                                    let g = 0,
                                        m = 0;
                                    for (let e = 0; e < h; ++e) _[g++] = 0, _.set(p.subarray(m, m + f), g), m += f, g += f;
                                    if (a === n.ImageKind.GRAYSCALE_1BPP && l) {
                                        g = 0;
                                        for (let e = 0; e < h; e++) {
                                            g++;
                                            for (let e = 0; e < f; e++) _[g++] ^= 255
                                        }
                                    }
                                    const A = new Uint8Array([c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, u, d, 0, 0, 0]),
                                        y = function(e) {
                                            if (!i.isNodeJS) return s(e);
                                            try {
                                                let t;
                                                t = parseInt(process$1.versions.node) >= 8 ? e : Buffer.from(e);
                                                const r = require$$4.deflateSync(t, {
                                                    level: 9
                                                });
                                                return r instanceof Uint8Array ? r : new Uint8Array(r)
                                            } catch (e) {
                                                (0, n.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e)
                                            }
                                            return s(e)
                                        }(_),
                                        b = e.length + 36 + A.length + y.length,
                                        E = new Uint8Array(b);
                                    let v = 0;
                                    return E.set(e, v), v += e.length, r("IHDR", A, E, v), v += 12 + A.length, r("IDATA", y, E, v), v += 12 + y.length, r("IEND", new Uint8Array(0), E, v), (0, n.createObjectURL)(E, "image/png", o)
                                }
                                return function(e, t, r) {
                                    return a(e, void 0 === e.kind ? n.ImageKind.GRAYSCALE_1BPP : e.kind, t, r)
                                }
                            }();
                        class u {
                            constructor() {
                                this.fontSizeScale = 1, this.fontWeight = e.fontWeight, this.fontSize = 0, this.textMatrix = n.IDENTITY_MATRIX, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = n.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = e.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = ""
                            }
                            clone() {
                                return Object.create(this)
                            }
                            setCurrentPoint(e, t) {
                                this.x = e, this.y = t
                            }
                        }

                        function d(e) {
                            let t = [];
                            const r = [];
                            for (const n of e) "save" !== n.fn ? "restore" === n.fn ? t = r.pop() : t.push(n) : (t.push({
                                fnId: 92,
                                fn: "group",
                                items: []
                            }), r.push(t), t = t[t.length - 1].items);
                            return t
                        }

                        function f(e) {
                            if (Number.isInteger(e)) return e.toString();
                            const t = e.toFixed(10);
                            let r = t.length - 1;
                            if ("0" !== t[r]) return t;
                            do {
                                r--
                            } while ("0" === t[r]);
                            return t.substring(0, "." === t[r] ? r : r + 1)
                        }

                        function p(e) {
                            if (0 === e[4] && 0 === e[5]) {
                                if (0 === e[1] && 0 === e[2]) return 1 === e[0] && 1 === e[3] ? "" : `scale(${f(e[0])} ${f(e[3])})`;
                                if (e[0] === e[3] && e[1] === -e[2]) return `rotate(${f(180*Math.acos(e[0])/Math.PI)})`
                            } else if (1 === e[0] && 0 === e[1] && 0 === e[2] && 1 === e[3]) return `translate(${f(e[4])} ${f(e[5])})`;
                            return `matrix(${f(e[0])} ${f(e[1])} ${f(e[2])} ${f(e[3])} ${f(e[4])} ${f(e[5])})`
                        }
                        let _ = 0,
                            g = 0,
                            m = 0;
                        t.SVGGraphics = a = class {
                            constructor(e, t, r = !1) {
                                this.svgFactory = new s.DOMSVGFactory, this.current = new u, this.transformMatrix = n.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = e, this.objs = t, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = Object.create(null), this.cssStyle = null, this.forceDataSchema = !!r, this._operatorIdMapping = [];
                                for (const e in n.OPS) this._operatorIdMapping[n.OPS[e]] = e
                            }
                            save() {
                                this.transformStack.push(this.transformMatrix);
                                const e = this.current;
                                this.extraStack.push(e), this.current = e.clone()
                            }
                            restore() {
                                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null
                            }
                            group(e) {
                                this.save(), this.executeOpTree(e), this.restore()
                            }
                            loadDependencies(e) {
                                const t = e.fnArray,
                                    r = e.argsArray;
                                for (let e = 0, s = t.length; e < s; e++)
                                    if (t[e] === n.OPS.dependency)
                                        for (const t of r[e]) {
                                            const e = t.startsWith("g_") ? this.commonObjs : this.objs,
                                                r = new Promise((r => {
                                                    e.get(t, r)
                                                }));
                                            this.current.dependencies.push(r)
                                        }
                                return Promise.all(this.current.dependencies)
                            }
                            transform(e, t, r, s, i, a) {
                                const o = [e, t, r, s, i, a];
                                this.transformMatrix = n.Util.transform(this.transformMatrix, o), this.tgrp = null
                            }
                            getSVG(e, t) {
                                this.viewport = t;
                                const r = this._initialize(t);
                                return this.loadDependencies(e).then((() => (this.transformMatrix = n.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(e)), r)))
                            }
                            convertOpList(e) {
                                const t = this._operatorIdMapping,
                                    r = e.argsArray,
                                    n = e.fnArray,
                                    s = [];
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    s.push({
                                        fnId: i,
                                        fn: t[i],
                                        args: r[e]
                                    })
                                }
                                return d(s)
                            }
                            executeOpTree(e) {
                                for (const t of e) {
                                    const e = t.fn,
                                        r = t.fnId,
                                        s = t.args;
                                    switch (0 | r) {
                                        case n.OPS.beginText:
                                            this.beginText();
                                            break;
                                        case n.OPS.dependency:
                                            break;
                                        case n.OPS.setLeading:
                                            this.setLeading(s);
                                            break;
                                        case n.OPS.setLeadingMoveText:
                                            this.setLeadingMoveText(s[0], s[1]);
                                            break;
                                        case n.OPS.setFont:
                                            this.setFont(s);
                                            break;
                                        case n.OPS.showText:
                                        case n.OPS.showSpacedText:
                                            this.showText(s[0]);
                                            break;
                                        case n.OPS.endText:
                                            this.endText();
                                            break;
                                        case n.OPS.moveText:
                                            this.moveText(s[0], s[1]);
                                            break;
                                        case n.OPS.setCharSpacing:
                                            this.setCharSpacing(s[0]);
                                            break;
                                        case n.OPS.setWordSpacing:
                                            this.setWordSpacing(s[0]);
                                            break;
                                        case n.OPS.setHScale:
                                            this.setHScale(s[0]);
                                            break;
                                        case n.OPS.setTextMatrix:
                                            this.setTextMatrix(s[0], s[1], s[2], s[3], s[4], s[5]);
                                            break;
                                        case n.OPS.setTextRise:
                                            this.setTextRise(s[0]);
                                            break;
                                        case n.OPS.setTextRenderingMode:
                                            this.setTextRenderingMode(s[0]);
                                            break;
                                        case n.OPS.setLineWidth:
                                            this.setLineWidth(s[0]);
                                            break;
                                        case n.OPS.setLineJoin:
                                            this.setLineJoin(s[0]);
                                            break;
                                        case n.OPS.setLineCap:
                                            this.setLineCap(s[0]);
                                            break;
                                        case n.OPS.setMiterLimit:
                                            this.setMiterLimit(s[0]);
                                            break;
                                        case n.OPS.setFillRGBColor:
                                            this.setFillRGBColor(s[0], s[1], s[2]);
                                            break;
                                        case n.OPS.setStrokeRGBColor:
                                            this.setStrokeRGBColor(s[0], s[1], s[2]);
                                            break;
                                        case n.OPS.setStrokeColorN:
                                            this.setStrokeColorN(s);
                                            break;
                                        case n.OPS.setFillColorN:
                                            this.setFillColorN(s);
                                            break;
                                        case n.OPS.shadingFill:
                                            this.shadingFill(s[0]);
                                            break;
                                        case n.OPS.setDash:
                                            this.setDash(s[0], s[1]);
                                            break;
                                        case n.OPS.setRenderingIntent:
                                            this.setRenderingIntent(s[0]);
                                            break;
                                        case n.OPS.setFlatness:
                                            this.setFlatness(s[0]);
                                            break;
                                        case n.OPS.setGState:
                                            this.setGState(s[0]);
                                            break;
                                        case n.OPS.fill:
                                            this.fill();
                                            break;
                                        case n.OPS.eoFill:
                                            this.eoFill();
                                            break;
                                        case n.OPS.stroke:
                                            this.stroke();
                                            break;
                                        case n.OPS.fillStroke:
                                            this.fillStroke();
                                            break;
                                        case n.OPS.eoFillStroke:
                                            this.eoFillStroke();
                                            break;
                                        case n.OPS.clip:
                                            this.clip("nonzero");
                                            break;
                                        case n.OPS.eoClip:
                                            this.clip("evenodd");
                                            break;
                                        case n.OPS.paintSolidColorImageMask:
                                            this.paintSolidColorImageMask();
                                            break;
                                        case n.OPS.paintImageXObject:
                                            this.paintImageXObject(s[0]);
                                            break;
                                        case n.OPS.paintInlineImageXObject:
                                            this.paintInlineImageXObject(s[0]);
                                            break;
                                        case n.OPS.paintImageMaskXObject:
                                            this.paintImageMaskXObject(s[0]);
                                            break;
                                        case n.OPS.paintFormXObjectBegin:
                                            this.paintFormXObjectBegin(s[0], s[1]);
                                            break;
                                        case n.OPS.paintFormXObjectEnd:
                                            this.paintFormXObjectEnd();
                                            break;
                                        case n.OPS.closePath:
                                            this.closePath();
                                            break;
                                        case n.OPS.closeStroke:
                                            this.closeStroke();
                                            break;
                                        case n.OPS.closeFillStroke:
                                            this.closeFillStroke();
                                            break;
                                        case n.OPS.closeEOFillStroke:
                                            this.closeEOFillStroke();
                                            break;
                                        case n.OPS.nextLine:
                                            this.nextLine();
                                            break;
                                        case n.OPS.transform:
                                            this.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
                                            break;
                                        case n.OPS.constructPath:
                                            this.constructPath(s[0], s[1]);
                                            break;
                                        case n.OPS.endPath:
                                            this.endPath();
                                            break;
                                        case 92:
                                            this.group(t.items);
                                            break;
                                        default:
                                            (0, n.warn)(`Unimplemented operator ${e}`)
                                    }
                                }
                            }
                            setWordSpacing(e) {
                                this.current.wordSpacing = e
                            }
                            setCharSpacing(e) {
                                this.current.charSpacing = e
                            }
                            nextLine() {
                                this.moveText(0, this.current.leading)
                            }
                            setTextMatrix(e, t, r, n, s, i) {
                                const a = this.current;
                                a.textMatrix = a.lineMatrix = [e, t, r, n, s, i], a.textMatrixScale = Math.sqrt(e * e + t * t), a.x = a.lineX = 0, a.y = a.lineY = 0, a.xcoords = [], a.ycoords = [], a.tspan = this.svgFactory.createElement("svg:tspan"), a.tspan.setAttributeNS(null, "font-family", a.fontFamily), a.tspan.setAttributeNS(null, "font-size", `${f(a.fontSize)}px`), a.tspan.setAttributeNS(null, "y", f(-a.y)), a.txtElement = this.svgFactory.createElement("svg:text"), a.txtElement.appendChild(a.tspan)
                            }
                            beginText() {
                                const e = this.current;
                                e.x = e.lineX = 0, e.y = e.lineY = 0, e.textMatrix = n.IDENTITY_MATRIX, e.lineMatrix = n.IDENTITY_MATRIX, e.textMatrixScale = 1, e.tspan = this.svgFactory.createElement("svg:tspan"), e.txtElement = this.svgFactory.createElement("svg:text"), e.txtgrp = this.svgFactory.createElement("svg:g"), e.xcoords = [], e.ycoords = []
                            }
                            moveText(e, t) {
                                const r = this.current;
                                r.x = r.lineX += e, r.y = r.lineY += t, r.xcoords = [], r.ycoords = [], r.tspan = this.svgFactory.createElement("svg:tspan"), r.tspan.setAttributeNS(null, "font-family", r.fontFamily), r.tspan.setAttributeNS(null, "font-size", `${f(r.fontSize)}px`), r.tspan.setAttributeNS(null, "y", f(-r.y))
                            }
                            showText(t) {
                                const s = this.current,
                                    i = s.font,
                                    a = s.fontSize;
                                if (0 === a) return;
                                const o = s.fontSizeScale,
                                    l = s.charSpacing,
                                    c = s.wordSpacing,
                                    h = s.fontDirection,
                                    u = s.textHScale * h,
                                    d = i.vertical,
                                    _ = d ? 1 : -1,
                                    g = i.defaultVMetrics,
                                    m = a * s.fontMatrix[0];
                                let A = 0;
                                for (const e of t) {
                                    if (null === e) {
                                        A += h * c;
                                        continue
                                    }
                                    if ((0, n.isNum)(e)) {
                                        A += _ * e * a / 1e3;
                                        continue
                                    }
                                    const t = (e.isSpace ? c : 0) + l,
                                        r = e.fontChar;
                                    let u, f, p, y = e.width;
                                    if (d) {
                                        let t;
                                        const r = e.vmetric || g;
                                        t = e.vmetric ? r[1] : .5 * y, t = -t * m;
                                        const n = r[2] * m;
                                        y = r ? -r[0] : y, u = t / o, f = (A + n) / o
                                    } else u = A / o, f = 0;
                                    (e.isInFont || i.missingFile) && (s.xcoords.push(s.x + u), d && s.ycoords.push(-s.y + f), s.tspan.textContent += r), p = d ? y * m - t * h : y * m + t * h, A += p
                                }
                                s.tspan.setAttributeNS(null, "x", s.xcoords.map(f).join(" ")), d ? s.tspan.setAttributeNS(null, "y", s.ycoords.map(f).join(" ")) : s.tspan.setAttributeNS(null, "y", f(-s.y)), d ? s.y -= A : s.x += A * u, s.tspan.setAttributeNS(null, "font-family", s.fontFamily), s.tspan.setAttributeNS(null, "font-size", `${f(s.fontSize)}px`), s.fontStyle !== e.fontStyle && s.tspan.setAttributeNS(null, "font-style", s.fontStyle), s.fontWeight !== e.fontWeight && s.tspan.setAttributeNS(null, "font-weight", s.fontWeight);
                                const y = s.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK;
                                if (y === n.TextRenderingMode.FILL || y === n.TextRenderingMode.FILL_STROKE ? (s.fillColor !== e.fillColor && s.tspan.setAttributeNS(null, "fill", s.fillColor), s.fillAlpha < 1 && s.tspan.setAttributeNS(null, "fill-opacity", s.fillAlpha)) : s.textRenderingMode === n.TextRenderingMode.ADD_TO_PATH ? s.tspan.setAttributeNS(null, "fill", "transparent") : s.tspan.setAttributeNS(null, "fill", "none"), y === n.TextRenderingMode.STROKE || y === n.TextRenderingMode.FILL_STROKE) {
                                    const e = 1 / (s.textMatrixScale || 1);
                                    this._setStrokeAttributes(s.tspan, e)
                                }
                                let b = s.textMatrix;
                                0 !== s.textRise && (b = b.slice(), b[5] += s.textRise), s.txtElement.setAttributeNS(null, "transform", `${p(b)} scale(${f(u)}, -1)`), s.txtElement.setAttributeNS(r, "xml:space", "preserve"), s.txtElement.appendChild(s.tspan), s.txtgrp.appendChild(s.txtElement), this._ensureTransformGroup().appendChild(s.txtElement)
                            }
                            setLeadingMoveText(e, t) {
                                this.setLeading(-t), this.moveText(e, t)
                            }
                            addFontStyle(e) {
                                if (!e.data) throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.appendChild(this.cssStyle));
                                const t = (0, n.createObjectURL)(e.data, e.mimetype, this.forceDataSchema);
                                this.cssStyle.textContent += `@font-face { font-family: "${e.loadedName}"; src: url(${t}); }\n`
                            }
                            setFont(e) {
                                const t = this.current,
                                    r = this.commonObjs.get(e[0]);
                                let s = e[1];
                                t.font = r, !this.embedFonts || r.missingFile || this.embeddedFonts[r.loadedName] || (this.addFontStyle(r), this.embeddedFonts[r.loadedName] = r), t.fontMatrix = r.fontMatrix ? r.fontMatrix : n.FONT_IDENTITY_MATRIX;
                                let i = "normal";
                                r.black ? i = "900" : r.bold && (i = "bold");
                                const a = r.italic ? "italic" : "normal";
                                s < 0 ? (s = -s, t.fontDirection = -1) : t.fontDirection = 1, t.fontSize = s, t.fontFamily = r.loadedName, t.fontWeight = i, t.fontStyle = a, t.tspan = this.svgFactory.createElement("svg:tspan"), t.tspan.setAttributeNS(null, "y", f(-t.y)), t.xcoords = [], t.ycoords = []
                            }
                            endText() {
                                const e = this.current;
                                e.textRenderingMode & n.TextRenderingMode.ADD_TO_PATH_FLAG && e.txtElement && e.txtElement.hasChildNodes() && (e.element = e.txtElement, this.clip("nonzero"), this.endPath())
                            }
                            setLineWidth(e) {
                                e > 0 && (this.current.lineWidth = e)
                            }
                            setLineCap(e) {
                                this.current.lineCap = l[e]
                            }
                            setLineJoin(e) {
                                this.current.lineJoin = c[e]
                            }
                            setMiterLimit(e) {
                                this.current.miterLimit = e
                            }
                            setStrokeAlpha(e) {
                                this.current.strokeAlpha = e
                            }
                            setStrokeRGBColor(e, t, r) {
                                this.current.strokeColor = n.Util.makeCssRgb(e, t, r)
                            }
                            setFillAlpha(e) {
                                this.current.fillAlpha = e
                            }
                            setFillRGBColor(e, t, r) {
                                this.current.fillColor = n.Util.makeCssRgb(e, t, r), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = []
                            }
                            setStrokeColorN(e) {
                                this.current.strokeColor = this._makeColorN_Pattern(e)
                            }
                            setFillColorN(e) {
                                this.current.fillColor = this._makeColorN_Pattern(e)
                            }
                            shadingFill(e) {
                                const t = this.viewport.width,
                                    r = this.viewport.height,
                                    s = n.Util.inverseTransform(this.transformMatrix),
                                    i = n.Util.applyTransform([0, 0], s),
                                    a = n.Util.applyTransform([0, r], s),
                                    o = n.Util.applyTransform([t, 0], s),
                                    l = n.Util.applyTransform([t, r], s),
                                    c = Math.min(i[0], a[0], o[0], l[0]),
                                    h = Math.min(i[1], a[1], o[1], l[1]),
                                    u = Math.max(i[0], a[0], o[0], l[0]),
                                    d = Math.max(i[1], a[1], o[1], l[1]),
                                    f = this.svgFactory.createElement("svg:rect");
                                f.setAttributeNS(null, "x", c), f.setAttributeNS(null, "y", h), f.setAttributeNS(null, "width", u - c), f.setAttributeNS(null, "height", d - h), f.setAttributeNS(null, "fill", this._makeShadingPattern(e)), this.current.fillAlpha < 1 && f.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().appendChild(f)
                            }
                            _makeColorN_Pattern(e) {
                                return "TilingPattern" === e[0] ? this._makeTilingPattern(e) : this._makeShadingPattern(e)
                            }
                            _makeTilingPattern(e) {
                                const t = e[1],
                                    r = e[2],
                                    s = e[3] || n.IDENTITY_MATRIX,
                                    [i, a, o, l] = e[4],
                                    c = e[5],
                                    h = e[6],
                                    u = e[7],
                                    d = "shading" + m++,
                                    [f, p] = n.Util.applyTransform([i, a], s),
                                    [_, g] = n.Util.applyTransform([o, l], s),
                                    [A, y] = n.Util.singularValueDecompose2dScale(s),
                                    b = c * A,
                                    E = h * y,
                                    v = this.svgFactory.createElement("svg:pattern");
                                v.setAttributeNS(null, "id", d), v.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), v.setAttributeNS(null, "width", b), v.setAttributeNS(null, "height", E), v.setAttributeNS(null, "x", `${f}`), v.setAttributeNS(null, "y", `${p}`);
                                const S = this.svg,
                                    T = this.transformMatrix,
                                    w = this.current.fillColor,
                                    R = this.current.strokeColor,
                                    C = this.svgFactory.create(_ - f, g - p);
                                if (this.svg = C, this.transformMatrix = s, 2 === u) {
                                    const e = n.Util.makeCssRgb(...t);
                                    this.current.fillColor = e, this.current.strokeColor = e
                                }
                                return this.executeOpTree(this.convertOpList(r)), this.svg = S, this.transformMatrix = T, this.current.fillColor = w, this.current.strokeColor = R, v.appendChild(C.childNodes[0]), this.defs.appendChild(v), `url(#${d})`
                            }
                            _makeShadingPattern(e) {
                                switch (e[0]) {
                                    case "RadialAxial":
                                        const t = "shading" + m++,
                                            r = e[3];
                                        let s;
                                        switch (e[1]) {
                                            case "axial":
                                                const r = e[4],
                                                    n = e[5];
                                                s = this.svgFactory.createElement("svg:linearGradient"), s.setAttributeNS(null, "id", t), s.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), s.setAttributeNS(null, "x1", r[0]), s.setAttributeNS(null, "y1", r[1]), s.setAttributeNS(null, "x2", n[0]), s.setAttributeNS(null, "y2", n[1]);
                                                break;
                                            case "radial":
                                                const i = e[4],
                                                    a = e[5],
                                                    o = e[6],
                                                    l = e[7];
                                                s = this.svgFactory.createElement("svg:radialGradient"), s.setAttributeNS(null, "id", t), s.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), s.setAttributeNS(null, "cx", a[0]), s.setAttributeNS(null, "cy", a[1]), s.setAttributeNS(null, "r", l), s.setAttributeNS(null, "fx", i[0]), s.setAttributeNS(null, "fy", i[1]), s.setAttributeNS(null, "fr", o);
                                                break;
                                            default:
                                                throw new Error(`Unknown RadialAxial type: ${e[1]}`)
                                        }
                                        for (const e of r) {
                                            const t = this.svgFactory.createElement("svg:stop");
                                            t.setAttributeNS(null, "offset", e[0]), t.setAttributeNS(null, "stop-color", e[1]), s.appendChild(t)
                                        }
                                        return this.defs.appendChild(s), `url(#${t})`;
                                    case "Mesh":
                                        return (0, n.warn)("Unimplemented pattern Mesh"), null;
                                    case "Dummy":
                                        return "hotpink";
                                    default:
                                        throw new Error(`Unknown IR type: ${e[0]}`)
                                }
                            }
                            setDash(e, t) {
                                this.current.dashArray = e, this.current.dashPhase = t
                            }
                            constructPath(e, t) {
                                const r = this.current;
                                let s = r.x,
                                    i = r.y,
                                    a = [],
                                    o = 0;
                                for (const r of e) switch (0 | r) {
                                    case n.OPS.rectangle:
                                        s = t[o++], i = t[o++];
                                        const e = s + t[o++],
                                            r = i + t[o++];
                                        a.push("M", f(s), f(i), "L", f(e), f(i), "L", f(e), f(r), "L", f(s), f(r), "Z");
                                        break;
                                    case n.OPS.moveTo:
                                        s = t[o++], i = t[o++], a.push("M", f(s), f(i));
                                        break;
                                    case n.OPS.lineTo:
                                        s = t[o++], i = t[o++], a.push("L", f(s), f(i));
                                        break;
                                    case n.OPS.curveTo:
                                        s = t[o + 4], i = t[o + 5], a.push("C", f(t[o]), f(t[o + 1]), f(t[o + 2]), f(t[o + 3]), f(s), f(i)), o += 6;
                                        break;
                                    case n.OPS.curveTo2:
                                        a.push("C", f(s), f(i), f(t[o]), f(t[o + 1]), f(t[o + 2]), f(t[o + 3])), s = t[o + 2], i = t[o + 3], o += 4;
                                        break;
                                    case n.OPS.curveTo3:
                                        s = t[o + 2], i = t[o + 3], a.push("C", f(t[o]), f(t[o + 1]), f(s), f(i), f(s), f(i)), o += 4;
                                        break;
                                    case n.OPS.closePath:
                                        a.push("Z")
                                }
                                a = a.join(" "), r.path && e.length > 0 && e[0] !== n.OPS.rectangle && e[0] !== n.OPS.moveTo ? a = r.path.getAttributeNS(null, "d") + a : (r.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().appendChild(r.path)), r.path.setAttributeNS(null, "d", a), r.path.setAttributeNS(null, "fill", "none"), r.element = r.path, r.setCurrentPoint(s, i)
                            }
                            endPath() {
                                const e = this.current;
                                if (e.path = null, !this.pendingClip) return;
                                if (!e.element) return void(this.pendingClip = null);
                                const t = "clippath" + _++,
                                    r = this.svgFactory.createElement("svg:clipPath");
                                r.setAttributeNS(null, "id", t), r.setAttributeNS(null, "transform", p(this.transformMatrix));
                                const n = e.element.cloneNode(!0);
                                "evenodd" === this.pendingClip ? n.setAttributeNS(null, "clip-rule", "evenodd") : n.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, r.appendChild(n), this.defs.appendChild(r), e.activeClipUrl && (e.clipGroup = null, this.extraStack.forEach((function(e) {
                                    e.clipGroup = null
                                })), r.setAttributeNS(null, "clip-path", e.activeClipUrl)), e.activeClipUrl = `url(#${t})`, this.tgrp = null
                            }
                            clip(e) {
                                this.pendingClip = e
                            }
                            closePath() {
                                const e = this.current;
                                if (e.path) {
                                    const t = `${e.path.getAttributeNS(null,"d")}Z`;
                                    e.path.setAttributeNS(null, "d", t)
                                }
                            }
                            setLeading(e) {
                                this.current.leading = -e
                            }
                            setTextRise(e) {
                                this.current.textRise = e
                            }
                            setTextRenderingMode(e) {
                                this.current.textRenderingMode = e
                            }
                            setHScale(e) {
                                this.current.textHScale = e / 100
                            }
                            setRenderingIntent(e) {}
                            setFlatness(e) {}
                            setGState(e) {
                                for (const [t, r] of e) switch (t) {
                                    case "LW":
                                        this.setLineWidth(r);
                                        break;
                                    case "LC":
                                        this.setLineCap(r);
                                        break;
                                    case "LJ":
                                        this.setLineJoin(r);
                                        break;
                                    case "ML":
                                        this.setMiterLimit(r);
                                        break;
                                    case "D":
                                        this.setDash(r[0], r[1]);
                                        break;
                                    case "RI":
                                        this.setRenderingIntent(r);
                                        break;
                                    case "FL":
                                        this.setFlatness(r);
                                        break;
                                    case "Font":
                                        this.setFont(r);
                                        break;
                                    case "CA":
                                        this.setStrokeAlpha(r);
                                        break;
                                    case "ca":
                                        this.setFillAlpha(r);
                                        break;
                                    default:
                                        (0, n.warn)(`Unimplemented graphic state operator ${t}`)
                                }
                            }
                            fill() {
                                const e = this.current;
                                e.element && (e.element.setAttributeNS(null, "fill", e.fillColor), e.element.setAttributeNS(null, "fill-opacity", e.fillAlpha), this.endPath())
                            }
                            stroke() {
                                const e = this.current;
                                e.element && (this._setStrokeAttributes(e.element), e.element.setAttributeNS(null, "fill", "none"), this.endPath())
                            }
                            _setStrokeAttributes(e, t = 1) {
                                const r = this.current;
                                let n = r.dashArray;
                                1 !== t && n.length > 0 && (n = n.map((function(e) {
                                    return t * e
                                }))), e.setAttributeNS(null, "stroke", r.strokeColor), e.setAttributeNS(null, "stroke-opacity", r.strokeAlpha), e.setAttributeNS(null, "stroke-miterlimit", f(r.miterLimit)), e.setAttributeNS(null, "stroke-linecap", r.lineCap), e.setAttributeNS(null, "stroke-linejoin", r.lineJoin), e.setAttributeNS(null, "stroke-width", f(t * r.lineWidth) + "px"), e.setAttributeNS(null, "stroke-dasharray", n.map(f).join(" ")), e.setAttributeNS(null, "stroke-dashoffset", f(t * r.dashPhase) + "px")
                            }
                            eoFill() {
                                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill()
                            }
                            fillStroke() {
                                this.stroke(), this.fill()
                            }
                            eoFillStroke() {
                                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke()
                            }
                            closeStroke() {
                                this.closePath(), this.stroke()
                            }
                            closeFillStroke() {
                                this.closePath(), this.fillStroke()
                            }
                            closeEOFillStroke() {
                                this.closePath(), this.eoFillStroke()
                            }
                            paintSolidColorImageMask() {
                                const e = this.svgFactory.createElement("svg:rect");
                                e.setAttributeNS(null, "x", "0"), e.setAttributeNS(null, "y", "0"), e.setAttributeNS(null, "width", "1px"), e.setAttributeNS(null, "height", "1px"), e.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().appendChild(e)
                            }
                            paintImageXObject(e) {
                                const t = this.objs.get(e);
                                t ? this.paintInlineImageXObject(t) : (0, n.warn)(`Dependent image with object ID ${e} is not ready yet`)
                            }
                            paintInlineImageXObject(e, t) {
                                const r = e.width,
                                    n = e.height,
                                    s = h(e, this.forceDataSchema, !!t),
                                    i = this.svgFactory.createElement("svg:rect");
                                i.setAttributeNS(null, "x", "0"), i.setAttributeNS(null, "y", "0"), i.setAttributeNS(null, "width", f(r)), i.setAttributeNS(null, "height", f(n)), this.current.element = i, this.clip("nonzero");
                                const a = this.svgFactory.createElement("svg:image");
                                a.setAttributeNS(o, "xlink:href", s), a.setAttributeNS(null, "x", "0"), a.setAttributeNS(null, "y", f(-n)), a.setAttributeNS(null, "width", f(r) + "px"), a.setAttributeNS(null, "height", f(n) + "px"), a.setAttributeNS(null, "transform", `scale(${f(1/r)} ${f(-1/n)})`), t ? t.appendChild(a) : this._ensureTransformGroup().appendChild(a)
                            }
                            paintImageMaskXObject(e) {
                                const t = this.current,
                                    r = e.width,
                                    n = e.height,
                                    s = t.fillColor;
                                t.maskId = "mask" + g++;
                                const i = this.svgFactory.createElement("svg:mask");
                                i.setAttributeNS(null, "id", t.maskId);
                                const a = this.svgFactory.createElement("svg:rect");
                                a.setAttributeNS(null, "x", "0"), a.setAttributeNS(null, "y", "0"), a.setAttributeNS(null, "width", f(r)), a.setAttributeNS(null, "height", f(n)), a.setAttributeNS(null, "fill", s), a.setAttributeNS(null, "mask", `url(#${t.maskId})`), this.defs.appendChild(i), this._ensureTransformGroup().appendChild(a), this.paintInlineImageXObject(e, i)
                            }
                            paintFormXObjectBegin(e, t) {
                                if (Array.isArray(e) && 6 === e.length && this.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t) {
                                    const e = t[2] - t[0],
                                        r = t[3] - t[1],
                                        n = this.svgFactory.createElement("svg:rect");
                                    n.setAttributeNS(null, "x", t[0]), n.setAttributeNS(null, "y", t[1]), n.setAttributeNS(null, "width", f(e)), n.setAttributeNS(null, "height", f(r)), this.current.element = n, this.clip("nonzero"), this.endPath()
                                }
                            }
                            paintFormXObjectEnd() {}
                            _initialize(e) {
                                const t = this.svgFactory.create(e.width, e.height),
                                    r = this.svgFactory.createElement("svg:defs");
                                t.appendChild(r), this.defs = r;
                                const n = this.svgFactory.createElement("svg:g");
                                return n.setAttributeNS(null, "transform", p(e.transform)), t.appendChild(n), this.svg = n, t
                            }
                            _ensureClipGroup() {
                                if (!this.current.clipGroup) {
                                    const e = this.svgFactory.createElement("svg:g");
                                    e.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.appendChild(e), this.current.clipGroup = e
                                }
                                return this.current.clipGroup
                            }
                            _ensureTransformGroup() {
                                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", p(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().appendChild(this.tgrp) : this.svg.appendChild(this.tgrp)), this.tgrp
                            }
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.PDFNodeStream = void 0;
                    var n = r(2),
                        s = r(20);
                    const i = require$$4,
                        a = require$$4,
                        o = require$$4,
                        l = require$$4,
                        c = /^file:\/\/\/[a-zA-Z]:\//;
                    t.PDFNodeStream = class {
                        constructor(e) {
                            this.source = e, this.url = function(e) {
                                const t = l.parse(e);
                                return "file:" === t.protocol || t.host ? t : /^[a-z]:[/\\]/i.test(e) ? l.parse(`file:///${e}`) : (t.host || (t.protocol = "file:"), t)
                            }(e.url), this.isHttp = "http:" === this.url.protocol || "https:" === this.url.protocol, this.isFsUrl = "file:" === this.url.protocol, this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        getFullReader() {
                            return (0, n.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new _(this) : new f(this), this._fullRequestReader
                        }
                        getRangeReader(e, t) {
                            if (t <= this._progressiveDataLength) return null;
                            const r = this.isFsUrl ? new g(this, e, t) : new p(this, e, t);
                            return this._rangeRequestReaders.push(r), r
                        }
                        cancelAllRequests(e) {
                            this._fullRequestReader && this._fullRequestReader.cancel(e), this._rangeRequestReaders.slice(0).forEach((function(t) {
                                t.cancel(e)
                            }))
                        }
                    };
                    class h {
                        constructor(e) {
                            this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null;
                            const t = e.source;
                            this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = (0, n.createPromiseCapability)(), this._headersCapability = (0, n.createPromiseCapability)()
                        }
                        get headersReady() {
                            return this._headersCapability.promise
                        }
                        get filename() {
                            return this._filename
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            if (await this._readCapability.promise, this._done) return {
                                value: void 0,
                                done: !0
                            };
                            if (this._storedError) throw this._storedError;
                            const e = this._readableStream.read();
                            return null === e ? (this._readCapability = (0, n.createPromiseCapability)(), this.read()) : (this._loaded += e.length, this.onProgress && this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                            }), {
                                value: new Uint8Array(e).buffer,
                                done: !1
                            })
                        }
                        cancel(e) {
                            this._readableStream ? this._readableStream.destroy(e) : this._error(e)
                        }
                        _error(e) {
                            this._storedError = e, this._readCapability.resolve()
                        }
                        _setReadableStream(e) {
                            this._readableStream = e, e.on("readable", (() => {
                                this._readCapability.resolve()
                            })), e.on("end", (() => {
                                e.destroy(), this._done = !0, this._readCapability.resolve()
                            })), e.on("error", (e => {
                                this._error(e)
                            })), !this._isStreamingSupported && this._isRangeSupported && this._error(new n.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError)
                        }
                    }
                    class u {
                        constructor(e) {
                            this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, n.createPromiseCapability)();
                            const t = e.source;
                            this._isStreamingSupported = !t.disableStream
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            if (await this._readCapability.promise, this._done) return {
                                value: void 0,
                                done: !0
                            };
                            if (this._storedError) throw this._storedError;
                            const e = this._readableStream.read();
                            return null === e ? (this._readCapability = (0, n.createPromiseCapability)(), this.read()) : (this._loaded += e.length, this.onProgress && this.onProgress({
                                loaded: this._loaded
                            }), {
                                value: new Uint8Array(e).buffer,
                                done: !1
                            })
                        }
                        cancel(e) {
                            this._readableStream ? this._readableStream.destroy(e) : this._error(e)
                        }
                        _error(e) {
                            this._storedError = e, this._readCapability.resolve()
                        }
                        _setReadableStream(e) {
                            this._readableStream = e, e.on("readable", (() => {
                                this._readCapability.resolve()
                            })), e.on("end", (() => {
                                e.destroy(), this._done = !0, this._readCapability.resolve()
                            })), e.on("error", (e => {
                                this._error(e)
                            })), this._storedError && this._readableStream.destroy(this._storedError)
                        }
                    }

                    function d(e, t) {
                        return {
                            protocol: e.protocol,
                            auth: e.auth,
                            host: e.hostname,
                            port: e.port,
                            path: e.path,
                            method: "GET",
                            headers: t
                        }
                    }
                    class f extends h {
                        constructor(e) {
                            super(e);
                            const t = t => {
                                if (404 === t.statusCode) {
                                    const e = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                                    return this._storedError = e, void this._headersCapability.reject(e)
                                }
                                this._headersCapability.resolve(), this._setReadableStream(t);
                                const r = e => this._readableStream.headers[e.toLowerCase()],
                                    {
                                        allowRangeRequests: i,
                                        suggestedLength: a
                                    } = (0, s.validateRangeRequestCapabilities)({
                                        getResponseHeader: r,
                                        isHttp: e.isHttp,
                                        rangeChunkSize: this._rangeChunkSize,
                                        disableRange: this._disableRange
                                    });
                                this._isRangeSupported = i, this._contentLength = a || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(r)
                            };
                            this._request = null, "http:" === this._url.protocol ? this._request = a.request(d(this._url, e.httpHeaders), t) : this._request = o.request(d(this._url, e.httpHeaders), t), this._request.on("error", (e => {
                                this._storedError = e, this._headersCapability.reject(e)
                            })), this._request.end()
                        }
                    }
                    class p extends u {
                        constructor(e, t, r) {
                            super(e), this._httpHeaders = {};
                            for (const t in e.httpHeaders) {
                                const r = e.httpHeaders[t];
                                void 0 !== r && (this._httpHeaders[t] = r)
                            }
                            this._httpHeaders.Range = `bytes=${t}-${r-1}`;
                            const s = e => {
                                if (404 !== e.statusCode) this._setReadableStream(e);
                                else {
                                    const e = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                                    this._storedError = e
                                }
                            };
                            this._request = null, "http:" === this._url.protocol ? this._request = a.request(d(this._url, this._httpHeaders), s) : this._request = o.request(d(this._url, this._httpHeaders), s), this._request.on("error", (e => {
                                this._storedError = e
                            })), this._request.end()
                        }
                    }
                    class _ extends h {
                        constructor(e) {
                            super(e);
                            let t = decodeURIComponent(this._url.path);
                            c.test(this._url.href) && (t = t.replace(/^\//, "")), i.lstat(t, ((e, r) => {
                                if (e) return "ENOENT" === e.code && (e = new n.MissingPDFException(`Missing PDF "${t}".`)), this._storedError = e, void this._headersCapability.reject(e);
                                this._contentLength = r.size, this._setReadableStream(i.createReadStream(t)), this._headersCapability.resolve()
                            }))
                        }
                    }
                    class g extends u {
                        constructor(e, t, r) {
                            super(e);
                            let n = decodeURIComponent(this._url.path);
                            c.test(this._url.href) && (n = n.replace(/^\//, "")), this._setReadableStream(i.createReadStream(n, {
                                start: t,
                                end: r - 1
                            }))
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.createResponseStatusError = function(e, t) {
                        return 404 === e || 0 === e && t.startsWith("file:") ? new n.MissingPDFException('Missing PDF "' + t + '".') : new n.UnexpectedResponseException("Unexpected server response (" + e + ') while retrieving PDF "' + t + '".', e)
                    }, t.extractFilenameFromHeader = function(e) {
                        const t = e("Content-Disposition");
                        if (t) {
                            let e = (0, s.getFilenameFromContentDispositionHeader)(t);
                            if (e.includes("%")) try {
                                e = decodeURIComponent(e)
                            } catch (e) {}
                            if (/\.pdf$/i.test(e)) return e
                        }
                        return null
                    }, t.validateRangeRequestCapabilities = function({
                        getResponseHeader: e,
                        isHttp: t,
                        rangeChunkSize: r,
                        disableRange: s
                    }) {
                        (0, n.assert)(r > 0, "Range chunk size must be larger than zero");
                        const i = {
                                allowRangeRequests: !1,
                                suggestedLength: void 0
                            },
                            a = parseInt(e("Content-Length"), 10);
                        return Number.isInteger(a) ? (i.suggestedLength = a, a <= 2 * r || s || !t || "bytes" !== e("Accept-Ranges") || "identity" !== (e("Content-Encoding") || "identity") || (i.allowRangeRequests = !0), i) : i
                    }, t.validateResponseStatus = function(e) {
                        return 200 === e || 206 === e
                    };
                    var n = r(2),
                        s = r(21)
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.getFilenameFromContentDispositionHeader = function(e) {
                        let t = !0,
                            r = n("filename\\*", "i").exec(e);
                        if (r) {
                            r = r[1];
                            let e = a(r);
                            return e = unescape(e), e = o(e), e = l(e), i(e)
                        }
                        if (r = function(e) {
                                const t = [];
                                let r;
                                const s = n("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                                for (; null !== (r = s.exec(e));) {
                                    let [, e, n, s] = r;
                                    if (e = parseInt(e, 10), e in t) {
                                        if (0 === e) break
                                    } else t[e] = [n, s]
                                }
                                const i = [];
                                for (let e = 0; e < t.length && e in t; ++e) {
                                    let [r, n] = t[e];
                                    n = a(n), r && (n = unescape(n), 0 === e && (n = o(n))), i.push(n)
                                }
                                return i.join("")
                            }(e), r) return i(l(r));
                        if (r = n("filename", "i").exec(e), r) {
                            r = r[1];
                            let e = a(r);
                            return e = l(e), i(e)
                        }

                        function n(e, t) {
                            return new RegExp("(?:^|;)\\s*" + e + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', t)
                        }

                        function s(e, r) {
                            if (e) {
                                if (!/^[\x00-\xFF]+$/.test(r)) return r;
                                try {
                                    const n = new TextDecoder(e, {
                                            fatal: !0
                                        }),
                                        s = Array.from(r, (function(e) {
                                            return 255 & e.charCodeAt(0)
                                        }));
                                    r = n.decode(new Uint8Array(s)), t = !1
                                } catch (n) {
                                    if (/^utf-?8$/i.test(e)) try {
                                        r = decodeURIComponent(escape(r)), t = !1
                                    } catch (e) {}
                                }
                            }
                            return r
                        }

                        function i(e) {
                            return t && /[\x80-\xff]/.test(e) && (e = s("utf-8", e), t && (e = s("iso-8859-1", e))), e
                        }

                        function a(e) {
                            if (e.startsWith('"')) {
                                const t = e.slice(1).split('\\"');
                                for (let e = 0; e < t.length; ++e) {
                                    const r = t[e].indexOf('"'); - 1 !== r && (t[e] = t[e].slice(0, r), t.length = e + 1), t[e] = t[e].replace(/\\(.)/g, "$1")
                                }
                                e = t.join('"')
                            }
                            return e
                        }

                        function o(e) {
                            const t = e.indexOf("'");
                            return -1 === t ? e : s(e.slice(0, t), e.slice(t + 1).replace(/^[^']*'/, ""))
                        }

                        function l(e) {
                            return !e.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(e) ? e : e.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (function(e, t, r, n) {
                                if ("q" === r || "Q" === r) return s(t, n = (n = n.replace(/_/g, " ")).replace(/=([0-9a-fA-F]{2})/g, (function(e, t) {
                                    return String.fromCharCode(parseInt(t, 16))
                                })));
                                try {
                                    n = atob(n)
                                } catch (e) {}
                                return s(t, n)
                            }))
                        }
                        return ""
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.PDFNetworkStream = void 0;
                    var n = r(2),
                        s = r(20);
                    class i {
                        constructor(e, t) {
                            this.url = e, t = t || {}, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && t.httpHeaders || {}, this.withCredentials = t.withCredentials || !1, this.getXhr = t.getXhr || function() {
                                return new XMLHttpRequest
                            }, this.currXhrId = 0, this.pendingRequests = Object.create(null)
                        }
                        requestRange(e, t, r) {
                            const n = {
                                begin: e,
                                end: t
                            };
                            for (const e in r) n[e] = r[e];
                            return this.request(n)
                        }
                        requestFull(e) {
                            return this.request(e)
                        }
                        request(e) {
                            const t = this.getXhr(),
                                r = this.currXhrId++,
                                n = this.pendingRequests[r] = {
                                    xhr: t
                                };
                            t.open("GET", this.url), t.withCredentials = this.withCredentials;
                            for (const e in this.httpHeaders) {
                                const r = this.httpHeaders[e];
                                void 0 !== r && t.setRequestHeader(e, r)
                            }
                            return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", `bytes=${e.begin}-${e.end-1}`), n.expectedStatus = 206) : n.expectedStatus = 200, t.responseType = "arraybuffer", e.onError && (t.onerror = function(r) {
                                e.onError(t.status)
                            }), t.onreadystatechange = this.onStateChange.bind(this, r), t.onprogress = this.onProgress.bind(this, r), n.onHeadersReceived = e.onHeadersReceived, n.onDone = e.onDone, n.onError = e.onError, n.onProgress = e.onProgress, t.send(null), r
                        }
                        onProgress(e, t) {
                            const r = this.pendingRequests[e];
                            r && r.onProgress && r.onProgress(t)
                        }
                        onStateChange(e, t) {
                            const r = this.pendingRequests[e];
                            if (!r) return;
                            const s = r.xhr;
                            if (s.readyState >= 2 && r.onHeadersReceived && (r.onHeadersReceived(), delete r.onHeadersReceived), 4 !== s.readyState) return;
                            if (!(e in this.pendingRequests)) return;
                            if (delete this.pendingRequests[e], 0 === s.status && this.isHttp) return void(r.onError && r.onError(s.status));
                            const i = s.status || 200;
                            if ((200 !== i || 206 !== r.expectedStatus) && i !== r.expectedStatus) return void(r.onError && r.onError(s.status));
                            const a = function(e) {
                                const t = e.response;
                                return "string" != typeof t ? t : (0, n.stringToBytes)(t).buffer
                            }(s);
                            if (206 === i) {
                                const e = s.getResponseHeader("Content-Range"),
                                    t = /bytes (\d+)-(\d+)\/(\d+)/.exec(e);
                                r.onDone({
                                    begin: parseInt(t[1], 10),
                                    chunk: a
                                })
                            } else a ? r.onDone({
                                begin: 0,
                                chunk: a
                            }) : r.onError && r.onError(s.status)
                        }
                        hasPendingRequests() {
                            for (const e in this.pendingRequests) return !0;
                            return !1
                        }
                        getRequestXhr(e) {
                            return this.pendingRequests[e].xhr
                        }
                        isPendingRequest(e) {
                            return e in this.pendingRequests
                        }
                        abortAllRequests() {
                            for (const e in this.pendingRequests) this.abortRequest(0 | e)
                        }
                        abortRequest(e) {
                            const t = this.pendingRequests[e].xhr;
                            delete this.pendingRequests[e], t.abort()
                        }
                    }
                    t.PDFNetworkStream = class {
                        constructor(e) {
                            this._source = e, this._manager = new i(e.url, {
                                httpHeaders: e.httpHeaders,
                                withCredentials: e.withCredentials
                            }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        _onRangeRequestReaderClosed(e) {
                            const t = this._rangeRequestReaders.indexOf(e);
                            t >= 0 && this._rangeRequestReaders.splice(t, 1)
                        }
                        getFullReader() {
                            return (0, n.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new a(this._manager, this._source), this._fullRequestReader
                        }
                        getRangeReader(e, t) {
                            const r = new o(this._manager, e, t);
                            return r.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(r), r
                        }
                        cancelAllRequests(e) {
                            this._fullRequestReader && this._fullRequestReader.cancel(e), this._rangeRequestReaders.slice(0).forEach((function(t) {
                                t.cancel(e)
                            }))
                        }
                    };
                    class a {
                        constructor(e, t) {
                            this._manager = e;
                            const r = {
                                onHeadersReceived: this._onHeadersReceived.bind(this),
                                onDone: this._onDone.bind(this),
                                onError: this._onError.bind(this),
                                onProgress: this._onProgress.bind(this)
                            };
                            this._url = t.url, this._fullRequestId = e.requestFull(r), this._headersReceivedCapability = (0, n.createPromiseCapability)(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null
                        }
                        _onHeadersReceived() {
                            const e = this._fullRequestId,
                                t = this._manager.getRequestXhr(e),
                                r = e => t.getResponseHeader(e),
                                {
                                    allowRangeRequests: n,
                                    suggestedLength: i
                                } = (0, s.validateRangeRequestCapabilities)({
                                    getResponseHeader: r,
                                    isHttp: this._manager.isHttp,
                                    rangeChunkSize: this._rangeChunkSize,
                                    disableRange: this._disableRange
                                });
                            n && (this._isRangeSupported = !0), this._contentLength = i || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(r), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve()
                        }
                        _onDone(e) {
                            e && (this._requests.length > 0 ? this._requests.shift().resolve({
                                value: e.chunk,
                                done: !1
                            }) : this._cachedChunks.push(e.chunk)), this._done = !0, this._cachedChunks.length > 0 || (this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = [])
                        }
                        _onError(e) {
                            const t = this._url,
                                r = (0, s.createResponseStatusError)(e, t);
                            this._storedError = r, this._headersReceivedCapability.reject(r), this._requests.forEach((function(e) {
                                e.reject(r)
                            })), this._requests = [], this._cachedChunks = []
                        }
                        _onProgress(e) {
                            this.onProgress && this.onProgress({
                                loaded: e.loaded,
                                total: e.lengthComputable ? e.total : this._contentLength
                            })
                        }
                        get filename() {
                            return this._filename
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get headersReady() {
                            return this._headersReceivedCapability.promise
                        }
                        async read() {
                            if (this._storedError) throw this._storedError;
                            if (this._cachedChunks.length > 0) return {
                                value: this._cachedChunks.shift(),
                                done: !1
                            };
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const e = (0, n.createPromiseCapability)();
                            return this._requests.push(e), e.promise
                        }
                        cancel(e) {
                            this._done = !0, this._headersReceivedCapability.reject(e), this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = [], this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null
                        }
                    }
                    class o {
                        constructor(e, t, r) {
                            this._manager = e;
                            const n = {
                                onDone: this._onDone.bind(this),
                                onProgress: this._onProgress.bind(this)
                            };
                            this._requestId = e.requestRange(t, r, n), this._requests = [], this._queuedChunk = null, this._done = !1, this.onProgress = null, this.onClosed = null
                        }
                        _close() {
                            this.onClosed && this.onClosed(this)
                        }
                        _onDone(e) {
                            const t = e.chunk;
                            this._requests.length > 0 ? this._requests.shift().resolve({
                                value: t,
                                done: !1
                            }) : this._queuedChunk = t, this._done = !0, this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = [], this._close()
                        }
                        _onProgress(e) {
                            !this.isStreamingSupported && this.onProgress && this.onProgress({
                                loaded: e.loaded
                            })
                        }
                        get isStreamingSupported() {
                            return !1
                        }
                        async read() {
                            if (null !== this._queuedChunk) {
                                const e = this._queuedChunk;
                                return this._queuedChunk = null, {
                                    value: e,
                                    done: !1
                                }
                            }
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const e = (0, n.createPromiseCapability)();
                            return this._requests.push(e), e.promise
                        }
                        cancel(e) {
                            this._done = !0, this._requests.forEach((function(e) {
                                e.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            })), this._requests = [], this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close()
                        }
                    }
                }, function(e, t, r) {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.PDFFetchStream = void 0;
                    var n = r(2),
                        s = r(20);

                    function i(e, t, r) {
                        return {
                            method: "GET",
                            headers: e,
                            signal: r && r.signal,
                            mode: "cors",
                            credentials: t ? "include" : "same-origin",
                            redirect: "follow"
                        }
                    }

                    function a(e) {
                        const t = new Headers;
                        for (const r in e) {
                            const n = e[r];
                            void 0 !== n && t.append(r, n)
                        }
                        return t
                    }
                    t.PDFFetchStream = class {
                        constructor(e) {
                            this.source = e, this.isHttp = /^https?:/i.test(e.url), this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        getFullReader() {
                            return (0, n.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new o(this), this._fullRequestReader
                        }
                        getRangeReader(e, t) {
                            if (t <= this._progressiveDataLength) return null;
                            const r = new l(this, e, t);
                            return this._rangeRequestReaders.push(r), r
                        }
                        cancelAllRequests(e) {
                            this._fullRequestReader && this._fullRequestReader.cancel(e), this._rangeRequestReaders.slice(0).forEach((function(t) {
                                t.cancel(e)
                            }))
                        }
                    };
                    class o {
                        constructor(e) {
                            this._stream = e, this._reader = null, this._loaded = 0, this._filename = null;
                            const t = e.source;
                            this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = (0, n.createPromiseCapability)(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), "undefined" != typeof AbortController && (this._abortController = new AbortController), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._headers = a(this._stream.httpHeaders);
                            const r = t.url;
                            fetch(r, i(this._headers, this._withCredentials, this._abortController)).then((e => {
                                if (!(0, s.validateResponseStatus)(e.status)) throw (0, s.createResponseStatusError)(e.status, r);
                                this._reader = e.body.getReader(), this._headersCapability.resolve();
                                const t = t => e.headers.get(t),
                                    {
                                        allowRangeRequests: i,
                                        suggestedLength: a
                                    } = (0, s.validateRangeRequestCapabilities)({
                                        getResponseHeader: t,
                                        isHttp: this._stream.isHttp,
                                        rangeChunkSize: this._rangeChunkSize,
                                        disableRange: this._disableRange
                                    });
                                this._isRangeSupported = i, this._contentLength = a || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(t), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new n.AbortException("Streaming is disabled."))
                            })).catch(this._headersCapability.reject), this.onProgress = null
                        }
                        get headersReady() {
                            return this._headersCapability.promise
                        }
                        get filename() {
                            return this._filename
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            await this._headersCapability.promise;
                            const {
                                value: e,
                                done: t
                            } = await this._reader.read();
                            return t ? {
                                value: e,
                                done: t
                            } : (this._loaded += e.byteLength, this.onProgress && this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                            }), {
                                value: new Uint8Array(e).buffer,
                                done: !1
                            })
                        }
                        cancel(e) {
                            this._reader && this._reader.cancel(e), this._abortController && this._abortController.abort()
                        }
                    }
                    class l {
                        constructor(e, t, r) {
                            this._stream = e, this._reader = null, this._loaded = 0;
                            const o = e.source;
                            this._withCredentials = o.withCredentials || !1, this._readCapability = (0, n.createPromiseCapability)(), this._isStreamingSupported = !o.disableStream, "undefined" != typeof AbortController && (this._abortController = new AbortController), this._headers = a(this._stream.httpHeaders), this._headers.append("Range", `bytes=${t}-${r-1}`);
                            const l = o.url;
                            fetch(l, i(this._headers, this._withCredentials, this._abortController)).then((e => {
                                if (!(0, s.validateResponseStatus)(e.status)) throw (0, s.createResponseStatusError)(e.status, l);
                                this._readCapability.resolve(), this._reader = e.body.getReader()
                            })), this.onProgress = null
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            await this._readCapability.promise;
                            const {
                                value: e,
                                done: t
                            } = await this._reader.read();
                            return t ? {
                                value: e,
                                done: t
                            } : (this._loaded += e.byteLength, this.onProgress && this.onProgress({
                                loaded: this._loaded
                            }), {
                                value: new Uint8Array(e).buffer,
                                done: !1
                            })
                        }
                        cancel(e) {
                            this._reader && this._reader.cancel(e), this._abortController && this._abortController.abort()
                        }
                    }
                }])
            }, module.exports = factory()
        }));
    unwrapExports(pdf);
    var pdf_1 = pdf,
        lzString = {
            exports: {}
        };
    ! function(e) {
        var t = function() {
            var e = String.fromCharCode,
                t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
                n = {};

            function s(e, t) {
                if (!n[e]) {
                    n[e] = {};
                    for (var r = 0; r < e.length; r++) n[e][e.charAt(r)] = r
                }
                return n[e][t]
            }
            var i = {
                compressToBase64: function(e) {
                    if (null == e) return "";
                    var r = i._compress(e, 6, (function(e) {
                        return t.charAt(e)
                    }));
                    switch (r.length % 4) {
                        default:
                        case 0:
                            return r;
                        case 1:
                            return r + "===";
                        case 2:
                            return r + "==";
                        case 3:
                            return r + "="
                    }
                },
                decompressFromBase64: function(e) {
                    return null == e ? "" : "" == e ? null : i._decompress(e.length, 32, (function(r) {
                        return s(t, e.charAt(r))
                    }))
                },
                compressToUTF16: function(t) {
                    return null == t ? "" : i._compress(t, 15, (function(t) {
                        return e(t + 32)
                    })) + " "
                },
                decompressFromUTF16: function(e) {
                    return null == e ? "" : "" == e ? null : i._decompress(e.length, 16384, (function(t) {
                        return e.charCodeAt(t) - 32
                    }))
                },
                compressToUint8Array: function(e) {
                    for (var t = i.compress(e), r = new Uint8Array(2 * t.length), n = 0, s = t.length; n < s; n++) {
                        var a = t.charCodeAt(n);
                        r[2 * n] = a >>> 8, r[2 * n + 1] = a % 256
                    }
                    return r
                },
                decompressFromUint8Array: function(t) {
                    if (null == t) return i.decompress(t);
                    for (var r = new Array(t.length / 2), n = 0, s = r.length; n < s; n++) r[n] = 256 * t[2 * n] + t[2 * n + 1];
                    var a = [];
                    return r.forEach((function(t) {
                        a.push(e(t))
                    })), i.decompress(a.join(""))
                },
                compressToEncodedURIComponent: function(e) {
                    return null == e ? "" : i._compress(e, 6, (function(e) {
                        return r.charAt(e)
                    }))
                },
                decompressFromEncodedURIComponent: function(e) {
                    return null == e ? "" : "" == e ? null : (e = e.replace(/ /g, "+"), i._decompress(e.length, 32, (function(t) {
                        return s(r, e.charAt(t))
                    })))
                },
                compress: function(t) {
                    return i._compress(t, 16, (function(t) {
                        return e(t)
                    }))
                },
                _compress: function(e, t, r) {
                    if (null == e) return "";
                    var n, s, i, a = {},
                        o = {},
                        l = "",
                        c = "",
                        h = "",
                        u = 2,
                        d = 3,
                        f = 2,
                        p = [],
                        _ = 0,
                        g = 0;
                    for (i = 0; i < e.length; i += 1)
                        if (l = e.charAt(i), Object.prototype.hasOwnProperty.call(a, l) || (a[l] = d++, o[l] = !0), c = h + l, Object.prototype.hasOwnProperty.call(a, c)) h = c;
                        else {
                            if (Object.prototype.hasOwnProperty.call(o, h)) {
                                if (h.charCodeAt(0) < 256) {
                                    for (n = 0; n < f; n++) _ <<= 1, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++;
                                    for (s = h.charCodeAt(0), n = 0; n < 8; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1
                                } else {
                                    for (s = 1, n = 0; n < f; n++) _ = _ << 1 | s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s = 0;
                                    for (s = h.charCodeAt(0), n = 0; n < 16; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1
                                }
                                0 == --u && (u = Math.pow(2, f), f++), delete o[h]
                            } else
                                for (s = a[h], n = 0; n < f; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1;
                            0 == --u && (u = Math.pow(2, f), f++), a[c] = d++, h = String(l)
                        } if ("" !== h) {
                        if (Object.prototype.hasOwnProperty.call(o, h)) {
                            if (h.charCodeAt(0) < 256) {
                                for (n = 0; n < f; n++) _ <<= 1, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++;
                                for (s = h.charCodeAt(0), n = 0; n < 8; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1
                            } else {
                                for (s = 1, n = 0; n < f; n++) _ = _ << 1 | s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s = 0;
                                for (s = h.charCodeAt(0), n = 0; n < 16; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1
                            }
                            0 == --u && (u = Math.pow(2, f), f++), delete o[h]
                        } else
                            for (s = a[h], n = 0; n < f; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1;
                        0 == --u && (u = Math.pow(2, f), f++)
                    }
                    for (s = 2, n = 0; n < f; n++) _ = _ << 1 | 1 & s, g == t - 1 ? (g = 0, p.push(r(_)), _ = 0) : g++, s >>= 1;
                    for (;;) {
                        if (_ <<= 1, g == t - 1) {
                            p.push(r(_));
                            break
                        }
                        g++
                    }
                    return p.join("")
                },
                decompress: function(e) {
                    return null == e ? "" : "" == e ? null : i._decompress(e.length, 32768, (function(t) {
                        return e.charCodeAt(t)
                    }))
                },
                _decompress: function(t, r, n) {
                    var s, i, a, o, l, c, h, u = [],
                        d = 4,
                        f = 4,
                        p = 3,
                        _ = "",
                        g = [],
                        m = {
                            val: n(0),
                            position: r,
                            index: 1
                        };
                    for (s = 0; s < 3; s += 1) u[s] = s;
                    for (a = 0, l = Math.pow(2, 2), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                    switch (a) {
                        case 0:
                            for (a = 0, l = Math.pow(2, 8), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                            h = e(a);
                            break;
                        case 1:
                            for (a = 0, l = Math.pow(2, 16), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                            h = e(a);
                            break;
                        case 2:
                            return ""
                    }
                    for (u[3] = h, i = h, g.push(h);;) {
                        if (m.index > t) return "";
                        for (a = 0, l = Math.pow(2, p), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                        switch (h = a) {
                            case 0:
                                for (a = 0, l = Math.pow(2, 8), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                                u[f++] = e(a), h = f - 1, d--;
                                break;
                            case 1:
                                for (a = 0, l = Math.pow(2, 16), c = 1; c != l;) o = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = r, m.val = n(m.index++)), a |= (o > 0 ? 1 : 0) * c, c <<= 1;
                                u[f++] = e(a), h = f - 1, d--;
                                break;
                            case 2:
                                return g.join("")
                        }
                        if (0 == d && (d = Math.pow(2, p), p++), u[h]) _ = u[h];
                        else {
                            if (h !== f) return null;
                            _ = i + i.charAt(0)
                        }
                        g.push(_), u[f++] = i + _.charAt(0), i = _, 0 == --d && (d = Math.pow(2, p), p++)
                    }
                }
            };
            return i
        }();
        null != e && (e.exports = t)
    }(lzString);
    var duration$1 = {
        exports: {}
    };
    ! function(e, t) {
        e.exports = function() {
            var e, t, r = 1e3,
                n = 6e4,
                s = 36e5,
                i = 864e5,
                a = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                o = 31536e6,
                l = 2592e6,
                c = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,
                h = {
                    years: o,
                    months: l,
                    days: i,
                    hours: s,
                    minutes: n,
                    seconds: r,
                    milliseconds: 1,
                    weeks: 6048e5
                },
                u = function(e) {
                    return e instanceof A
                },
                d = function(e, t, r) {
                    return new A(e, r, t.$l)
                },
                f = function(e) {
                    return t.p(e) + "s"
                },
                p = function(e) {
                    return e < 0
                },
                _ = function(e) {
                    return p(e) ? Math.ceil(e) : Math.floor(e)
                },
                g = function(e) {
                    return Math.abs(e)
                },
                m = function(e, t) {
                    return e ? p(e) ? {
                        negative: !0,
                        format: "" + g(e) + t
                    } : {
                        negative: !1,
                        format: "" + e + t
                    } : {
                        negative: !1,
                        format: ""
                    }
                },
                A = function() {
                    function p(e, t, r) {
                        var n = this;
                        if (this.$d = {}, this.$l = r, void 0 === e && (this.$ms = 0, this.parseFromMilliseconds()), t) return d(e * h[f(t)], this);
                        if ("number" == typeof e) return this.$ms = e, this.parseFromMilliseconds(), this;
                        if ("object" == typeof e) return Object.keys(e).forEach((function(t) {
                            n.$d[f(t)] = e[t]
                        })), this.calMilliseconds(), this;
                        if ("string" == typeof e) {
                            var s = e.match(c);
                            if (s) {
                                var i = s.slice(2).map((function(e) {
                                    return null != e ? Number(e) : 0
                                }));
                                return this.$d.years = i[0], this.$d.months = i[1], this.$d.weeks = i[2], this.$d.days = i[3], this.$d.hours = i[4], this.$d.minutes = i[5], this.$d.seconds = i[6], this.calMilliseconds(), this
                            }
                        }
                        return this
                    }
                    var g = p.prototype;
                    return g.calMilliseconds = function() {
                        var e = this;
                        this.$ms = Object.keys(this.$d).reduce((function(t, r) {
                            return t + (e.$d[r] || 0) * h[r]
                        }), 0)
                    }, g.parseFromMilliseconds = function() {
                        var e = this.$ms;
                        this.$d.years = _(e / o), e %= o, this.$d.months = _(e / l), e %= l, this.$d.days = _(e / i), e %= i, this.$d.hours = _(e / s), e %= s, this.$d.minutes = _(e / n), e %= n, this.$d.seconds = _(e / r), e %= r, this.$d.milliseconds = e
                    }, g.toISOString = function() {
                        var e = m(this.$d.years, "Y"),
                            t = m(this.$d.months, "M"),
                            r = +this.$d.days || 0;
                        this.$d.weeks && (r += 7 * this.$d.weeks);
                        var n = m(r, "D"),
                            s = m(this.$d.hours, "H"),
                            i = m(this.$d.minutes, "M"),
                            a = this.$d.seconds || 0;
                        this.$d.milliseconds && (a += this.$d.milliseconds / 1e3);
                        var o = m(a, "S"),
                            l = e.negative || t.negative || n.negative || s.negative || i.negative || o.negative,
                            c = s.format || i.format || o.format ? "T" : "",
                            h = (l ? "-" : "") + "P" + e.format + t.format + n.format + c + s.format + i.format + o.format;
                        return "P" === h || "-P" === h ? "P0D" : h
                    }, g.toJSON = function() {
                        return this.toISOString()
                    }, g.format = function(e) {
                        var r = e || "YYYY-MM-DDTHH:mm:ss",
                            n = {
                                Y: this.$d.years,
                                YY: t.s(this.$d.years, 2, "0"),
                                YYYY: t.s(this.$d.years, 4, "0"),
                                M: this.$d.months,
                                MM: t.s(this.$d.months, 2, "0"),
                                D: this.$d.days,
                                DD: t.s(this.$d.days, 2, "0"),
                                H: this.$d.hours,
                                HH: t.s(this.$d.hours, 2, "0"),
                                m: this.$d.minutes,
                                mm: t.s(this.$d.minutes, 2, "0"),
                                s: this.$d.seconds,
                                ss: t.s(this.$d.seconds, 2, "0"),
                                SSS: t.s(this.$d.milliseconds, 3, "0")
                            };
                        return r.replace(a, (function(e, t) {
                            return t || String(n[e])
                        }))
                    }, g.as = function(e) {
                        return this.$ms / h[f(e)]
                    }, g.get = function(e) {
                        var t = this.$ms,
                            r = f(e);
                        return "milliseconds" === r ? t %= 1e3 : t = "weeks" === r ? _(t / h[r]) : this.$d[r], 0 === t ? 0 : t
                    }, g.add = function(e, t, r) {
                        var n;
                        return n = t ? e * h[f(t)] : u(e) ? e.$ms : d(e, this).$ms, d(this.$ms + n * (r ? -1 : 1), this)
                    }, g.subtract = function(e, t) {
                        return this.add(e, t, !0)
                    }, g.locale = function(e) {
                        var t = this.clone();
                        return t.$l = e, t
                    }, g.clone = function() {
                        return d(this.$ms, this)
                    }, g.humanize = function(t) {
                        return e().add(this.$ms, "ms").locale(this.$l).fromNow(!t)
                    }, g.milliseconds = function() {
                        return this.get("milliseconds")
                    }, g.asMilliseconds = function() {
                        return this.as("milliseconds")
                    }, g.seconds = function() {
                        return this.get("seconds")
                    }, g.asSeconds = function() {
                        return this.as("seconds")
                    }, g.minutes = function() {
                        return this.get("minutes")
                    }, g.asMinutes = function() {
                        return this.as("minutes")
                    }, g.hours = function() {
                        return this.get("hours")
                    }, g.asHours = function() {
                        return this.as("hours")
                    }, g.days = function() {
                        return this.get("days")
                    }, g.asDays = function() {
                        return this.as("days")
                    }, g.weeks = function() {
                        return this.get("weeks")
                    }, g.asWeeks = function() {
                        return this.as("weeks")
                    }, g.months = function() {
                        return this.get("months")
                    }, g.asMonths = function() {
                        return this.as("months")
                    }, g.years = function() {
                        return this.get("years")
                    }, g.asYears = function() {
                        return this.as("years")
                    }, p
                }();
            return function(r, n, s) {
                e = s, t = s().$utils(), s.duration = function(e, t) {
                    var r = s.locale();
                    return d(e, {
                        $l: r
                    }, t)
                }, s.isDuration = u;
                var i = n.prototype.add,
                    a = n.prototype.subtract;
                n.prototype.add = function(e, t) {
                    return u(e) && (e = e.asMilliseconds()), i.bind(this)(e, t)
                }, n.prototype.subtract = function(e, t) {
                    return u(e) && (e = e.asMilliseconds()), a.bind(this)(e, t)
                }
            }
        }()
    }(duration$1);
    var duration = duration$1.exports,
        isSameOrBefore$1 = {
            exports: {}
        };
    ! function(e, t) {
        e.exports = function(e, t) {
            t.prototype.isSameOrBefore = function(e, t) {
                return this.isSame(e, t) || this.isBefore(e, t)
            }
        }
    }(isSameOrBefore$1);
    var isSameOrBefore = isSameOrBefore$1.exports,
        isSameOrAfter$1 = {
            exports: {}
        };
    ! function(e, t) {
        e.exports = function(e, t) {
            t.prototype.isSameOrAfter = function(e, t) {
                return this.isSame(e, t) || this.isAfter(e, t)
            }
        }
    }(isSameOrAfter$1);
    var isSameOrAfter = isSameOrAfter$1.exports;
    const TokenType = Object.freeze({
        EOF: Symbol("TEOF"),
        OP: Symbol("TOP"),
        CONST: Symbol("TCONST"),
        NUMBER: Symbol("TNUMBER"),
        STRING: Symbol("TSTRING"),
        PAREN: Symbol("TPAREN"),
        NAME: Symbol("TNAME")
    });
    class Token {
        constructor(e, t, r) {
            this.type = e, this.value = t, this.index = r
        }
        toString() {
            return `${this.type.toString()}: ${this.value}`
        }
    }
    const codePointPattern = /^[0-9a-f]{4}$/i;
    class TokenStream {
        constructor(e, t) {
            this.pos = 0, this.current = null, this.unaryOps = e.unaryOps, this.binaryOps = e.binaryOps, this.consts = e.consts, this.expression = t, this.savedPosition = 0, this.savedCurrent = null, this.options = e.options, this.parser = e
        }
        newToken(e, t, r) {
            return new Token(e, t, null != r ? r : this.pos)
        }
        save() {
            this.savedPosition = this.pos, this.savedCurrent = this.current
        }
        restore() {
            this.pos = this.savedPosition, this.current = this.savedCurrent
        }
        next() {
            return this.pos >= this.expression.length ? this.newToken(TokenType.EOF, "EOF") : this.isWhitespace() ? this.next() : this.isNumber() || this.isOperator() || this.isString() || this.isParen() || this.isNamedOp() || this.isConst() || this.isName() ? this.current : (this.parseError(`Unknown character "${this.expression.charAt(this.pos)}"`), !1)
        }
        isString() {
            let e = !1;
            const t = this.pos,
                r = this.expression.charAt(t);
            if ("'" === r || '"' === r) {
                let n = this.expression.indexOf(r, t + 1);
                for (; n >= 0 && this.pos < this.expression.length;) {
                    if (this.pos = n + 1, "\\" !== this.expression.charAt(n - 1)) {
                        const r = this.expression.substring(t + 1, n);
                        this.current = this.newToken(TokenType.STRING, this.unescape(r), t), e = !0;
                        break
                    }
                    n = this.expression.indexOf(r, n + 1)
                }
            }
            return e
        }
        isParen() {
            const e = this.expression.charAt(this.pos);
            return ("(" === e || ")" === e) && (this.current = this.newToken(TokenType.PAREN, e), this.pos += 1, !0)
        }
        isConst() {
            const e = this.pos;
            let t = e;
            for (; t < this.expression.length; t += 1) {
                const e = this.expression.charAt(t);
                if (e.toUpperCase() === e.toLowerCase() && (t === this.pos || "_" !== e && "." !== e && (e < "0" || e > "9"))) break
            }
            if (t > e) {
                const r = this.expression.substring(e, t);
                if (r in this.consts) return this.current = this.newToken(TokenType.CONST, this.consts[r]), this.pos += r.length, !0
            }
            return !1
        }
        isNamedOp() {
            const e = this.pos;
            let t = e;
            for (; t < this.expression.length; t += 1) {
                const e = this.expression.charAt(t);
                if (e.toUpperCase() === e.toLowerCase() && (t === this.pos || "_" !== e && (e < "0" || e > "9"))) break
            }
            if (t > e) {
                const r = this.expression.substring(e, t);
                if ("and" === r || "or" === r || r in this.binaryOps || r in this.unaryOps) return this.current = this.newToken(TokenType.OP, r), this.pos += r.length, !0
            }
            return !1
        }
        isName() {
            const e = this.pos;
            let t = e,
                r = !1;
            for (; t < this.expression.length; t += 1) {
                const e = this.expression.charAt(t);
                if (e.toUpperCase() === e.toLowerCase())
                    if (t !== this.pos || "$" !== e && "_" !== e) {
                        if (t === this.pos || !r || "_" !== e && (e < "0" || e > "9")) break
                    } else "_" === e && (r = !0);
                else r = !0
            }
            if (r) {
                const r = this.expression.substring(e, t);
                return this.current = this.newToken(TokenType.NAME, r), this.pos += r.length, !0
            }
            return !1
        }
        isWhitespace() {
            let e = !1,
                t = this.expression.charAt(this.pos);
            for (; !(" " !== t && "\t" !== t && "\n" !== t && "\r" !== t || (e = !0, this.pos += 1, this.pos >= this.expression.length));) t = this.expression.charAt(this.pos);
            return e
        }
        unescape(e) {
            let t = e.indexOf("\\");
            if (t < 0) return e;
            let r = e.substring(0, t);
            for (; t >= 0;) {
                const n = e.charAt(t += 1);
                let s;
                switch (n) {
                    case "'":
                        r += "'";
                        break;
                    case '"':
                        r += '"';
                        break;
                    case "\\":
                        r += "\\";
                        break;
                    case "/":
                        r += "/";
                        break;
                    case "b":
                        r += "\b";
                        break;
                    case "f":
                        r += "\f";
                        break;
                    case "n":
                        r += "\n";
                        break;
                    case "r":
                        r += "\r";
                        break;
                    case "t":
                        r += "\t";
                        break;
                    case "u":
                        s = e.substring(t + 1, t + 5), codePointPattern.test(s) || this.parseError(`Illegal escape sequence: \\u${s}`), r += String.fromCharCode(parseInt(s, 16)), t += 4;
                        break;
                    default:
                        throw this.parseError(`Illegal escape sequence: "\\${n}"`)
                }
                t += 1;
                const i = e.indexOf("\\", t);
                r += e.substring(t, i < 0 ? e.length : i), t = i
            }
            return r
        }
        isNumber() {
            let e = !1,
                {
                    pos: t
                } = this;
            const r = t;
            let n, s = t,
                i = !1,
                a = !1;
            for (; t < this.expression.length && (n = this.expression.charAt(t), n >= "0" && n <= "9" || !i && "." === n);) "." === n ? i = !0 : a = !0, t += 1, e = a;
            if (e && (s = t), "e" === n || "E" === n) {
                t += 1;
                let e = !0,
                    r = !1;
                for (; t < this.expression.length;) {
                    if (n = this.expression.charAt(t), !e || "+" !== n && "-" !== n) {
                        if (!(n >= "0" && n <= "9")) break;
                        r = !0, e = !1
                    } else e = !1;
                    t += 1
                }
                r || (t = s)
            }
            return e ? (this.current = this.newToken(TokenType.NUMBER, parseFloat(this.expression.substring(r, t))), this.pos = t) : this.pos = s, e
        }
        isOperator() {
            const e = this.expression.charAt(this.pos);
            if ("+" === e || "-" === e || "." === e) this.current = this.newToken(TokenType.OP, e);
            else if (">" === e) "=" === this.expression.charAt(this.pos + 1) ? (this.current = this.newToken(TokenType.OP, ">="), this.pos += 1) : this.current = this.newToken(TokenType.OP, ">");
            else if ("<" === e) "=" === this.expression.charAt(this.pos + 1) ? (this.current = this.newToken(TokenType.OP, "<="), this.pos += 1) : this.current = this.newToken(TokenType.OP, "<");
            else if ("=" === e) "=" === this.expression.charAt(this.pos + 1) ? (this.current = this.newToken(TokenType.OP, "=="), this.pos += 1) : this.current = this.newToken(TokenType.OP, e);
            else {
                if ("!" !== e) return !1;
                "=" === this.expression.charAt(this.pos + 1) ? (this.current = this.newToken(TokenType.OP, "!="), this.pos += 1) : this.current = this.newToken(TokenType.OP, e)
            }
            return this.pos += 1, !0
        }
        getCoordinates() {
            let e, t = 0,
                r = -1;
            do {
                t += 1, e = this.pos - r, r = this.expression.indexOf("\n", r + 1)
            } while (r >= 0 && r < this.pos);
            return {
                line: t,
                column: e
            }
        }
        parseError(e) {
            const t = this.getCoordinates();
            throw new Error(`parse error [${t.line}:${t.column}]: ${e}`)
        }
    }
    const InstructionType = Object.freeze({
        NUMBER: Symbol("INUMBER"),
        NULL: Symbol("INULL"),
        STRING: Symbol("ISTRING"),
        DATE: Symbol("IDATE"),
        DURATION: Symbol("IDURATION"),
        BOOL: Symbol("IBOOL"),
        OP1: Symbol("IOP1"),
        OP2: Symbol("IOP2"),
        VAR: Symbol("IVAR"),
        VARNAME: Symbol("IVARNAME"),
        EXPR: Symbol("IEXPR"),
        EXPREVAL: Symbol("IEXPREVAL"),
        MEMBER: Symbol("IMEMBER"),
        ARRAY: Symbol("IARRAY")
    });
    class Instruction {
        constructor(e, t) {
            this.type = e, this.value = void 0 !== t ? t : 0
        }
        toString() {
            switch (this.type) {
                case InstructionType.NUMBER:
                case InstructionType.STRING:
                case InstructionType.DATE:
                case InstructionType.DURATION:
                case InstructionType.OP1:
                case InstructionType.OP2:
                case InstructionType.VAR:
                    return this.value;
                case InstructionType.NULL:
                    return "NULL";
                case InstructionType.ARRAY:
                    return `ARRAY ${this.value}`;
                case InstructionType.MEMBER:
                    return `.${this.value}`;
                default:
                    return "Invalid Instruction"
            }
        }
    }

    function unaryInstruction(e) {
        return new Instruction(InstructionType.OP1, e)
    }

    function binaryInstruction(e) {
        return new Instruction(InstructionType.OP2, e)
    }
    const DATE_FORMAT = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,
        DURATION_FORMAT = /^([0-9]+)(s|m|h|d|mo|y)$/;

    function IdentifyValue(e) {
        if (null == e) return new Instruction(InstructionType.NULL, null);
        if (dayjs.isDayjs(e)) return new Instruction(InstructionType.DATE, e);
        if (dayjs.isDuration(e)) return new Instruction(InstructionType.DURATION, e);
        if ("object" == typeof e) return new Instruction(InstructionType.VAR, e);
        if ("boolean" == typeof e) return new Instruction(InstructionType.BOOL, e);
        if ("number" == typeof e) return new Instruction(InstructionType.NUMBER, e);
        const t = String(e);
        if (DATE_FORMAT.test(t)) {
            const e = dayjs.utc(t);
            if (e.isValid()) return new Instruction(InstructionType.DATE, e)
        }
        if (DURATION_FORMAT.test(t)) {
            const e = t.match(DURATION_FORMAT);
            return new Instruction(InstructionType.DURATION, dayjs.duration(parseInt(e[1], 10), "mo" === e[2] ? "M" : e[2]))
        }
        return new Instruction(InstructionType.STRING, t)
    }

    function contains$2(e, t) {
        for (let r = 0; r < e.length; r += 1)
            if (e[r] === t) return !0;
        return !1
    }
    dayjs.extend(duration), dayjs.extend(utc);
    const COMPARISON_OPERATORS = ["==", "!=", "<", "<=", ">=", ">"],
        ADD_SUB_OPERATORS = ["+", "-"];

    function tokenMatches(e, t) {
        return void 0 === t || (Array.isArray(t) ? contains$2(t, e.value) : "function" == typeof t ? t(e) : e.value === t)
    }

    function pushExpression(e, t) {
        for (let r = 0, n = t.length; r < n; r += 1) e.push(t[r])
    }
    class ParserState {
        constructor(e, t) {
            this.parser = e, this.tokens = t, this.current = null, this.nextToken = null, this.next(), this.savedCurrent = null, this.savedNextToken = null
        }
        next() {
            return this.current = this.nextToken, this.nextToken = this.tokens.next(), this.nextToken
        }
        save() {
            this.savedCurrent = this.current, this.savedNextToken = this.nextToken, this.tokens.save()
        }
        restore() {
            this.tokens.restore(), this.current = this.savedCurrent, this.nextToken = this.savedNextToken
        }
        accept(e, t) {
            return !(this.nextToken.type !== e || !tokenMatches(this.nextToken, t)) && (this.next(), !0)
        }
        expect(e, t) {
            if (!this.accept(e, t)) {
                const r = this.tokens.getCoordinates();
                throw new Error(`parse error [${r.line}:${r.column}]: Expected ${t||e.toString()}`)
            }
        }
        parseExpression(e) {
            this.parseOrExpression(e), pushExpression(e, [])
        }
        parseOrExpression(e) {
            for (this.parseAndExpression(e); this.accept(TokenType.OP, "or");) {
                const t = [];
                this.parseAndExpression(t), e.push(new Instruction(InstructionType.EXPR, t)), e.push(binaryInstruction("or"))
            }
        }
        parseAndExpression(e) {
            for (this.parseComparison(e); this.accept(TokenType.OP, "and");) {
                const t = [];
                this.parseComparison(t), e.push(new Instruction(InstructionType.EXPR, t)), e.push(binaryInstruction("and"))
            }
        }
        parseComparison(e) {
            for (this.parseAddSub(e); this.accept(TokenType.OP, COMPARISON_OPERATORS);) {
                const t = this.current;
                this.parseAddSub(e), e.push(binaryInstruction(t.value))
            }
        }
        parseAddSub(e) {
            for (this.parseFactor(e); this.accept(TokenType.OP, ADD_SUB_OPERATORS);) {
                const t = this.current;
                this.parseFactor(e), e.push(binaryInstruction(t.value))
            }
        }
        parseFactor(e) {
            const {
                unaryOps: t
            } = this.tokens;
            if (this.save(), this.accept(TokenType.OP, (function(e) {
                    return e.value in t
                }))) {
                if ("-" !== this.current.value && "+" !== this.current.value && (this.nextToken.type === TokenType.SEMICOLON || this.nextToken.type === TokenType.EOF || this.nextToken.type === TokenType.PAREN && ")" === this.nextToken.value)) return this.restore(), void this.parseAtom(e);
                const t = this.current;
                this.parseFactor(e), e.push(unaryInstruction(t.value))
            } else this.parseMemberExpression(e)
        }
        parseAtom(e) {
            const {
                unaryOps: t
            } = this.tokens;
            if (this.accept(TokenType.NAME) || this.accept(TokenType.OP, (function(e) {
                    return e.value in t
                }))) e.push(new Instruction(InstructionType.VAR, this.current.value));
            else if (this.accept(TokenType.NUMBER)) e.push(new Instruction(InstructionType.NUMBER, this.current.value));
            else if (this.accept(TokenType.STRING) || this.accept(TokenType.CONST)) e.push(IdentifyValue(this.current.value));
            else {
                if (!this.accept(TokenType.PAREN, "(")) throw new Error(`unexpected ${this.nextToken}`);
                this.parseExpression(e), this.expect(TokenType.PAREN, ")")
            }
        }
        parseMemberExpression(e) {
            for (this.parseAtom(e); this.accept(TokenType.OP, ".");) {
                const t = this.current;
                if ("." !== t.value) throw new Error(`unexpected symbol: ${t.value}`);
                this.expect(TokenType.NAME), e.push(new Instruction(InstructionType.MEMBER, this.current.value))
            }
        }
    }

    function isExpressionEvaluator(e) {
        return e && e.type === InstructionType.EXPREVAL
    }

    function resolveExpression(e, t) {
        return isExpressionEvaluator(e) ? e.value(t) : e
    }

    function evaluateInternal(e, t, r) {
        const n = [];
        let s, i, a;
        if (isExpressionEvaluator(e)) return resolveExpression(e, r);
        const o = e.length;
        for (let l = 0; l < o; l += 1) {
            const o = e[l],
                {
                    type: c
                } = o;
            if (c === InstructionType.NULL || c === InstructionType.BOOL || c === InstructionType.NUMBER || c === InstructionType.STRING || c === InstructionType.DATE || c === InstructionType.DURATION) n.push(o);
            else if (c === InstructionType.OP2)
                if (i = n.pop(), s = n.pop(), "and" === o.value) {
                    if (s.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${s.type.toString()} and`);
                    let e = !1;
                    if (s.value) {
                        const n = evaluateInternal(i, t, r);
                        if (n.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${n.type.toString()} and`);
                        e = n.value
                    }
                    n.push(new Instruction(InstructionType.BOOL, e))
                } else if ("or" === o.value) {
                if (s.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${s.type.toString()} or`);
                let e = s.value;
                if (!e) {
                    const n = evaluateInternal(i, t, r);
                    if (n.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${n.type.toString()} or`);
                    e = n.value
                }
                n.push(new Instruction(InstructionType.BOOL, e))
            } else a = t.binaryOps[o.value], n.push(a(resolveExpression(s, r), resolveExpression(i, r)));
            else if (c === InstructionType.VAR)
                if (o.value in t.unaryOps) n.push(t.unaryOps[o.value]);
                else {
                    const e = r[o.value];
                    if (void 0 === e) throw new Error(`undefined variable: ${o.value}`);
                    e && e instanceof Instruction ? n.push(e) : n.push(IdentifyValue(e))
                }
            else if (c === InstructionType.OP1) s = n.pop(), a = t.unaryOps[o.value], n.push(a(resolveExpression(s, r)));
            else if (c === InstructionType.EXPR) n.push(createExpressionEvaluator(o, t));
            else if (c === InstructionType.EXPREVAL) n.push(o);
            else {
                if (c !== InstructionType.MEMBER) throw new Error("invalid expression"); {
                    s = n.pop();
                    const e = s.value[o.value];
                    e && e instanceof Instruction ? n.push(e) : n.push(IdentifyValue(e))
                }
            }
        }
        if (n.length > 1) throw new Error("invalid expression (parity)");
        return 0 === n[0].value ? new Instruction(InstructionType.NULL, null) : resolveExpression(n[0], r)
    }

    function createExpressionEvaluator(e, t) {
        return isExpressionEvaluator(e) ? e : {
            type: InstructionType.EXPREVAL,
            value: r => evaluateInternal(e.value, t, r)
        }
    }

    function evaluate(e, t, r) {
        return evaluateInternal(e, t, r).value
    }
    class Expression {
        constructor(e, t) {
            this.tokens = e, this.parser = t, this.unaryOps = t.unaryOps, this.binaryOps = t.binaryOps
        }
        evaluate(e) {
            return evaluate(this.tokens, this, e || {})
        }
    }

    function add(e, t) {
        if (e.type === InstructionType.DATE) {
            if (t.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${e.type.toString()} + ${t.type.toString()}`);
            return new Instruction(InstructionType.DATE, e.value.clone().add(t.value))
        }
        if (t.type === InstructionType.DATE) {
            if (e.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${e.type.toString()} + ${t.type.toString()}`);
            return new Instruction(InstructionType.DATE, t.value.clone().add(e.value))
        }
        if (e.type !== InstructionType.NUMBER || t.type !== InstructionType.NUMBER) throw new Error(`unsupported operation ${e.type.toString()} + ${t.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, Number(e.value) + Number(t.value))
    }

    function sub(e, t) {
        if (e.type === InstructionType.DATE) {
            if (t.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${e.type.toString()} - ${t.type.toString()}`);
            return new Instruction(InstructionType.DATE, e.value.clone().subtract(t.value))
        }
        if (t.type === InstructionType.DATE) {
            if (e.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${e.type.toString()} - ${t.type.toString()}`);
            return new Instruction(InstructionType.DATE, t.value.clone().subtract(e.value))
        }
        if (e.type !== InstructionType.NUMBER || t.type !== InstructionType.NUMBER) throw new Error(`unsupported operation ${e.type.toString()} - ${t.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, e.value - t.value)
    }

    function equal(e, t) {
        if (e.type !== t.type) {
            if (null === e.value || null === t.value) return new Instruction(InstructionType.BOOL, !1);
            throw new Error(`unsupported operation ${e.type.toString()} == ${t.type.toString()}`)
        }
        let r;
        if (e.type === InstructionType.DATE) {
            let n = e.value.clone(),
                s = t.value.clone();
            (n.clone().startOf("day").isSame(n) || s.clone().startOf("day").isSame(s)) && (n = n.startOf("day").utc(!0), s = s.startOf("day").utc(!0)), r = n.isSame(s)
        } else r = e.value === t.value;
        return new Instruction(InstructionType.BOOL, r)
    }

    function notEqual(e, t) {
        return new Instruction(InstructionType.BOOL, !equal(e, t).value)
    }

    function greaterThan(e, t) {
        if (e.type !== t.type) throw new Error(`unsupported operation ${e.type.toString()} > ${t.type.toString()}`);
        let r;
        if (e.type === InstructionType.DATE) {
            let n = e.value.clone(),
                s = t.value.clone();
            (n.clone().startOf("day").isSame(n) || s.clone().startOf("day").isSame(s)) && (n = n.startOf("day").utc(!0), s = s.startOf("day").utc(!0)), r = n.isAfter(s)
        } else r = e.value > t.value;
        return new Instruction(InstructionType.BOOL, r)
    }

    function lessThan(e, t) {
        if (e.type !== t.type) throw new Error(`unsupported operation ${e.type.toString()} < ${t.type.toString()}`);
        let r;
        if (e.type === InstructionType.DATE) {
            let n = e.value.clone(),
                s = t.value.clone();
            (n.clone().startOf("day").isSame(n) || s.clone().startOf("day").isSame(s)) && (n = n.startOf("day").utc(!0), s = s.startOf("day").utc(!0)), r = n.isBefore(s)
        } else r = e.value < t.value;
        return new Instruction(InstructionType.BOOL, r)
    }

    function greaterThanEqual(e, t) {
        if (e.type !== t.type) throw new Error(`unsupported operation ${e.type.toString()} >= ${t.type.toString()}`);
        let r;
        if (e.type === InstructionType.DATE) {
            let n = e.value.clone(),
                s = t.value.clone();
            (n.clone().startOf("day").isSame(n) || s.clone().startOf("day").isSame(s)) && (n = n.startOf("day").utc(!0), s = s.startOf("day").utc(!0)), r = n.isSameOrAfter(s)
        } else r = e.value >= t.value;
        return new Instruction(InstructionType.BOOL, r)
    }

    function lessThanEqual(e, t) {
        if (e.type !== t.type) throw new Error(`unsupported operation ${e.type.toString()} <= ${t.type.toString()}`);
        let r;
        if (e.type === InstructionType.DATE) {
            let n = e.value.clone(),
                s = t.value.clone();
            (n.clone().startOf("day").isSame(n) || s.clone().startOf("day").isSame(s)) && (n = n.startOf("day").utc(!0), s = s.startOf("day").utc(!0)), r = n.isSameOrBefore(s)
        } else r = e.value <= t.value;
        return new Instruction(InstructionType.BOOL, r)
    }

    function neg(e) {
        if (e.type !== InstructionType.NUMBER) throw new Error(`unsupported operation -${e.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, -e.value)
    }

    function not(e) {
        if (e.type !== InstructionType.BOOL) throw new Error(`unsupported operation not(${e.type.toString()})`);
        return new Instruction(InstructionType.BOOL, !e.value)
    }
    dayjs.extend(isSameOrBefore), dayjs.extend(isSameOrAfter), dayjs.extend(utc), dayjs.extend(duration);
    class Parser {
        constructor() {
            this.unaryOps = {
                "-": neg,
                "+": Number,
                not: not
            }, this.binaryOps = {
                "+": add,
                "-": sub,
                "==": equal,
                "!=": notEqual,
                ">": greaterThan,
                "<": lessThan,
                ">=": greaterThanEqual,
                "<=": lessThanEqual
            }, this.consts = {
                true: !0,
                false: !1,
                null: null
            }
        }
        parse(e) {
            const t = [],
                r = new ParserState(this, new TokenStream(this, e));
            return r.parseExpression(t), r.expect(TokenType.EOF, "EOF"), new Expression(t, this)
        }
    }
    const DEFAULT_LANG = "lv";

    function getActiveRevisions(e) {
        const t = dayjs.utc().startOf("day"),
            r = [];
        for (let n = 0; n < e.revisions.length; n += 1) {
            const s = e.revisions[n];
            s.validFrom && dayjs.utc(s.validFrom).isAfter(t) || (s.validTill && dayjs.utc(s.validTill).isBefore(t) || r.push(s))
        }
        return r
    }

    function getActiveRules(e, t, r) {
        const n = [],
            s = getActiveRevisions(r);
        for (let r = 0; r < s.length; r += 1) {
            const i = s[r];
            for (let r = 0; r < i.roles.length; r += 1) {
                const s = i.roles[r];
                if ((s[e] || {}).rules && (s.common || contains$2(t, s.code)))
                    for (let t = 0; t < s[e].rules.length; t += 1) n.push(s[e].rules[t])
            }
        }
        return n
    }
    dayjs.extend(utc);
    const parser = new Parser;
    class ValidationResult$1 {
        constructor(e, t = null, r = null) {
            this.valid = e, this.reason = t, this.reasonBusinessDescription = r
        }
    }

    function validateByType(e, t, r, n) {
        let s = null;
        for (let n = 0; n < e[t].length; n += 1) {
            let i = !1;
            for (let a = 0; a < r.length; a += 1) {
                const o = r[a];
                i = !1, s = o;
                for (let r = 0; r < (o.conditions || []).length; r += 1) {
                    const a = parser.parse(o.conditions[r]),
                        l = e.dob || "1900-01-01",
                        c = {
                            hcert: {
                                nam: e.nam,
                                dob: l
                            },
                            external: {
                                validationClock: dayjs()
                            }
                        };
                    if (c.hcert[t] = e[t][n], a.evaluate(c)) {
                        i = !0, s = null;
                        break
                    }
                }
                if (!i) break
            }
            if (i) return new ValidationResult$1(!0)
        }
        if (null === s) return new ValidationResult$1(!1, "NO_RULES");
        let {
            businessDescription: i
        } = s;
        return n !== DEFAULT_LANG && `businessDescription:${n}` in s && (i = s[`businessDescription:${n}`]), new ValidationResult$1(!1, s.code, i)
    }

    function validate$2(e, t, r, n) {
        return "t" in (e || {}) && Array.isArray(e.t) && e.t.length > 0 ? validateByType(e, "t", getActiveRules("t", t, r), n) : "r" in (e || {}) && Array.isArray(e.r) && e.r.length > 0 ? validateByType(e, "r", getActiveRules("r", t, r), n) : "v" in (e || {}) && Array.isArray(e.v) && e.v.length > 0 ? validateByType(e, "v", getActiveRules("v", t, r), n) : new ValidationResult$1(!1, "UNKNOWN_CERTIFICATE")
    }
    class Role {
        constructor(e, t) {
            this.code = e, this.businessDescription = t
        }
    }

    function getRoles(e, t = DEFAULT_LANG) {
        const r = getActiveRevisions(e),
            n = [],
            s = {};
        for (let e = 0; e < r.length; e += 1) {
            const i = r[e];
            for (let e = 0; e < i.roles.length; e += 1) {
                const r = i.roles[e];
                if (!r.common && !(r.code in s)) {
                    let {
                        businessDescription: e
                    } = r;
                    t !== DEFAULT_LANG && `businessDescription:${t}` in r && (e = r[`businessDescription:${t}`]), n.push(new Role(r.code, e)), s[r.code] = !0
                }
            }
        }
        return n
    }
    /*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
    const Z_FIXED$1 = 4,
        Z_BINARY = 0,
        Z_TEXT = 1,
        Z_UNKNOWN$1 = 2;

    function zero$1(e) {
        let t = e.length;
        for (; --t >= 0;) e[t] = 0
    }
    const STORED_BLOCK = 0,
        STATIC_TREES = 1,
        DYN_TREES = 2,
        MIN_MATCH$1 = 3,
        MAX_MATCH$1 = 258,
        LENGTH_CODES$1 = 29,
        LITERALS$1 = 256,
        L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1,
        D_CODES$1 = 30,
        BL_CODES$1 = 19,
        HEAP_SIZE$1 = 2 * L_CODES$1 + 1,
        MAX_BITS$1 = 15,
        Buf_size = 16,
        MAX_BL_BITS = 7,
        END_BLOCK = 256,
        REP_3_6 = 16,
        REPZ_3_10 = 17,
        REPZ_11_138 = 18,
        extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
        extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
        extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
        bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
        DIST_CODE_LEN = 512,
        static_ltree = new Array(2 * (L_CODES$1 + 2));
    zero$1(static_ltree);
    const static_dtree = new Array(2 * D_CODES$1);
    zero$1(static_dtree);
    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    const base_dist = new Array(D_CODES$1);

    function StaticTreeDesc(e, t, r, n, s) {
        this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = s, this.has_stree = e && e.length
    }
    let static_l_desc, static_d_desc, static_bl_desc;

    function TreeDesc(e, t) {
        this.dyn_tree = e, this.max_code = 0, this.stat_desc = t
    }
    zero$1(base_dist);
    const d_code = e => e < 256 ? _dist_code[e] : _dist_code[256 + (e >>> 7)],
        put_short = (e, t) => {
            e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255
        },
        send_bits = (e, t, r) => {
            e.bi_valid > Buf_size - r ? (e.bi_buf |= t << e.bi_valid & 65535, put_short(e, e.bi_buf), e.bi_buf = t >> Buf_size - e.bi_valid, e.bi_valid += r - Buf_size) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r)
        },
        send_code = (e, t, r) => {
            send_bits(e, r[2 * t], r[2 * t + 1])
        },
        bi_reverse = (e, t) => {
            let r = 0;
            do {
                r |= 1 & e, e >>>= 1, r <<= 1
            } while (--t > 0);
            return r >>> 1
        },
        bi_flush = e => {
            16 === e.bi_valid ? (put_short(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8)
        },
        gen_bitlen = (e, t) => {
            const r = t.dyn_tree,
                n = t.max_code,
                s = t.stat_desc.static_tree,
                i = t.stat_desc.has_stree,
                a = t.stat_desc.extra_bits,
                o = t.stat_desc.extra_base,
                l = t.stat_desc.max_length;
            let c, h, u, d, f, p, _ = 0;
            for (d = 0; d <= MAX_BITS$1; d++) e.bl_count[d] = 0;
            for (r[2 * e.heap[e.heap_max] + 1] = 0, c = e.heap_max + 1; c < HEAP_SIZE$1; c++) h = e.heap[c], d = r[2 * r[2 * h + 1] + 1] + 1, d > l && (d = l, _++), r[2 * h + 1] = d, h > n || (e.bl_count[d]++, f = 0, h >= o && (f = a[h - o]), p = r[2 * h], e.opt_len += p * (d + f), i && (e.static_len += p * (s[2 * h + 1] + f)));
            if (0 !== _) {
                do {
                    for (d = l - 1; 0 === e.bl_count[d];) d--;
                    e.bl_count[d]--, e.bl_count[d + 1] += 2, e.bl_count[l]--, _ -= 2
                } while (_ > 0);
                for (d = l; 0 !== d; d--)
                    for (h = e.bl_count[d]; 0 !== h;) u = e.heap[--c], u > n || (r[2 * u + 1] !== d && (e.opt_len += (d - r[2 * u + 1]) * r[2 * u], r[2 * u + 1] = d), h--)
            }
        },
        gen_codes = (e, t, r) => {
            const n = new Array(MAX_BITS$1 + 1);
            let s, i, a = 0;
            for (s = 1; s <= MAX_BITS$1; s++) n[s] = a = a + r[s - 1] << 1;
            for (i = 0; i <= t; i++) {
                let t = e[2 * i + 1];
                0 !== t && (e[2 * i] = bi_reverse(n[t]++, t))
            }
        },
        tr_static_init = () => {
            let e, t, r, n, s;
            const i = new Array(MAX_BITS$1 + 1);
            for (r = 0, n = 0; n < LENGTH_CODES$1 - 1; n++)
                for (base_length[n] = r, e = 0; e < 1 << extra_lbits[n]; e++) _length_code[r++] = n;
            for (_length_code[r - 1] = n, s = 0, n = 0; n < 16; n++)
                for (base_dist[n] = s, e = 0; e < 1 << extra_dbits[n]; e++) _dist_code[s++] = n;
            for (s >>= 7; n < D_CODES$1; n++)
                for (base_dist[n] = s << 7, e = 0; e < 1 << extra_dbits[n] - 7; e++) _dist_code[256 + s++] = n;
            for (t = 0; t <= MAX_BITS$1; t++) i[t] = 0;
            for (e = 0; e <= 143;) static_ltree[2 * e + 1] = 8, e++, i[8]++;
            for (; e <= 255;) static_ltree[2 * e + 1] = 9, e++, i[9]++;
            for (; e <= 279;) static_ltree[2 * e + 1] = 7, e++, i[7]++;
            for (; e <= 287;) static_ltree[2 * e + 1] = 8, e++, i[8]++;
            for (gen_codes(static_ltree, L_CODES$1 + 1, i), e = 0; e < D_CODES$1; e++) static_dtree[2 * e + 1] = 5, static_dtree[2 * e] = bi_reverse(e, 5);
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS)
        },
        init_block = e => {
            let t;
            for (t = 0; t < L_CODES$1; t++) e.dyn_ltree[2 * t] = 0;
            for (t = 0; t < D_CODES$1; t++) e.dyn_dtree[2 * t] = 0;
            for (t = 0; t < BL_CODES$1; t++) e.bl_tree[2 * t] = 0;
            e.dyn_ltree[2 * END_BLOCK] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0
        },
        bi_windup = e => {
            e.bi_valid > 8 ? put_short(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0
        },
        copy_block = (e, t, r, n) => {
            bi_windup(e), n && (put_short(e, r), put_short(e, ~r)), e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r
        },
        smaller = (e, t, r, n) => {
            const s = 2 * t,
                i = 2 * r;
            return e[s] < e[i] || e[s] === e[i] && n[t] <= n[r]
        },
        pqdownheap = (e, t, r) => {
            const n = e.heap[r];
            let s = r << 1;
            for (; s <= e.heap_len && (s < e.heap_len && smaller(t, e.heap[s + 1], e.heap[s], e.depth) && s++, !smaller(t, n, e.heap[s], e.depth));) e.heap[r] = e.heap[s], r = s, s <<= 1;
            e.heap[r] = n
        },
        compress_block = (e, t, r) => {
            let n, s, i, a, o = 0;
            if (0 !== e.last_lit)
                do {
                    n = e.pending_buf[e.d_buf + 2 * o] << 8 | e.pending_buf[e.d_buf + 2 * o + 1], s = e.pending_buf[e.l_buf + o], o++, 0 === n ? send_code(e, s, t) : (i = _length_code[s], send_code(e, i + LITERALS$1 + 1, t), a = extra_lbits[i], 0 !== a && (s -= base_length[i], send_bits(e, s, a)), n--, i = d_code(n), send_code(e, i, r), a = extra_dbits[i], 0 !== a && (n -= base_dist[i], send_bits(e, n, a)))
                } while (o < e.last_lit);
            send_code(e, END_BLOCK, t)
        },
        build_tree = (e, t) => {
            const r = t.dyn_tree,
                n = t.stat_desc.static_tree,
                s = t.stat_desc.has_stree,
                i = t.stat_desc.elems;
            let a, o, l, c = -1;
            for (e.heap_len = 0, e.heap_max = HEAP_SIZE$1, a = 0; a < i; a++) 0 !== r[2 * a] ? (e.heap[++e.heap_len] = c = a, e.depth[a] = 0) : r[2 * a + 1] = 0;
            for (; e.heap_len < 2;) l = e.heap[++e.heap_len] = c < 2 ? ++c : 0, r[2 * l] = 1, e.depth[l] = 0, e.opt_len--, s && (e.static_len -= n[2 * l + 1]);
            for (t.max_code = c, a = e.heap_len >> 1; a >= 1; a--) pqdownheap(e, r, a);
            l = i;
            do {
                a = e.heap[1], e.heap[1] = e.heap[e.heap_len--], pqdownheap(e, r, 1), o = e.heap[1], e.heap[--e.heap_max] = a, e.heap[--e.heap_max] = o, r[2 * l] = r[2 * a] + r[2 * o], e.depth[l] = (e.depth[a] >= e.depth[o] ? e.depth[a] : e.depth[o]) + 1, r[2 * a + 1] = r[2 * o + 1] = l, e.heap[1] = l++, pqdownheap(e, r, 1)
            } while (e.heap_len >= 2);
            e.heap[--e.heap_max] = e.heap[1], gen_bitlen(e, t), gen_codes(r, c, e.bl_count)
        },
        scan_tree = (e, t, r) => {
            let n, s, i = -1,
                a = t[1],
                o = 0,
                l = 7,
                c = 4;
            for (0 === a && (l = 138, c = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++) s = a, a = t[2 * (n + 1) + 1], ++o < l && s === a || (o < c ? e.bl_tree[2 * s] += o : 0 !== s ? (s !== i && e.bl_tree[2 * s]++, e.bl_tree[2 * REP_3_6]++) : o <= 10 ? e.bl_tree[2 * REPZ_3_10]++ : e.bl_tree[2 * REPZ_11_138]++, o = 0, i = s, 0 === a ? (l = 138, c = 3) : s === a ? (l = 6, c = 3) : (l = 7, c = 4))
        },
        send_tree = (e, t, r) => {
            let n, s, i = -1,
                a = t[1],
                o = 0,
                l = 7,
                c = 4;
            for (0 === a && (l = 138, c = 3), n = 0; n <= r; n++)
                if (s = a, a = t[2 * (n + 1) + 1], !(++o < l && s === a)) {
                    if (o < c)
                        do {
                            send_code(e, s, e.bl_tree)
                        } while (0 != --o);
                    else 0 !== s ? (s !== i && (send_code(e, s, e.bl_tree), o--), send_code(e, REP_3_6, e.bl_tree), send_bits(e, o - 3, 2)) : o <= 10 ? (send_code(e, REPZ_3_10, e.bl_tree), send_bits(e, o - 3, 3)) : (send_code(e, REPZ_11_138, e.bl_tree), send_bits(e, o - 11, 7));
                    o = 0, i = s, 0 === a ? (l = 138, c = 3) : s === a ? (l = 6, c = 3) : (l = 7, c = 4)
                }
        },
        build_bl_tree = e => {
            let t;
            for (scan_tree(e, e.dyn_ltree, e.l_desc.max_code), scan_tree(e, e.dyn_dtree, e.d_desc.max_code), build_tree(e, e.bl_desc), t = BL_CODES$1 - 1; t >= 3 && 0 === e.bl_tree[2 * bl_order[t] + 1]; t--);
            return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t
        },
        send_all_trees = (e, t, r, n) => {
            let s;
            for (send_bits(e, t - 257, 5), send_bits(e, r - 1, 5), send_bits(e, n - 4, 4), s = 0; s < n; s++) send_bits(e, e.bl_tree[2 * bl_order[s] + 1], 3);
            send_tree(e, e.dyn_ltree, t - 1), send_tree(e, e.dyn_dtree, r - 1)
        },
        detect_data_type = e => {
            let t, r = 4093624447;
            for (t = 0; t <= 31; t++, r >>>= 1)
                if (1 & r && 0 !== e.dyn_ltree[2 * t]) return Z_BINARY;
            if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return Z_TEXT;
            for (t = 32; t < LITERALS$1; t++)
                if (0 !== e.dyn_ltree[2 * t]) return Z_TEXT;
            return Z_BINARY
        };
    let static_init_done = !1;
    const _tr_init$1 = e => {
            static_init_done || (tr_static_init(), static_init_done = !0), e.l_desc = new TreeDesc(e.dyn_ltree, static_l_desc), e.d_desc = new TreeDesc(e.dyn_dtree, static_d_desc), e.bl_desc = new TreeDesc(e.bl_tree, static_bl_desc), e.bi_buf = 0, e.bi_valid = 0, init_block(e)
        },
        _tr_stored_block$1 = (e, t, r, n) => {
            send_bits(e, (STORED_BLOCK << 1) + (n ? 1 : 0), 3), copy_block(e, t, r, !0)
        },
        _tr_align$1 = e => {
            send_bits(e, STATIC_TREES << 1, 3), send_code(e, END_BLOCK, static_ltree), bi_flush(e)
        },
        _tr_flush_block$1 = (e, t, r, n) => {
            let s, i, a = 0;
            e.level > 0 ? (e.strm.data_type === Z_UNKNOWN$1 && (e.strm.data_type = detect_data_type(e)), build_tree(e, e.l_desc), build_tree(e, e.d_desc), a = build_bl_tree(e), s = e.opt_len + 3 + 7 >>> 3, i = e.static_len + 3 + 7 >>> 3, i <= s && (s = i)) : s = i = r + 5, r + 4 <= s && -1 !== t ? _tr_stored_block$1(e, t, r, n) : e.strategy === Z_FIXED$1 || i === s ? (send_bits(e, (STATIC_TREES << 1) + (n ? 1 : 0), 3), compress_block(e, static_ltree, static_dtree)) : (send_bits(e, (DYN_TREES << 1) + (n ? 1 : 0), 3), send_all_trees(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), compress_block(e, e.dyn_ltree, e.dyn_dtree)), init_block(e), n && bi_windup(e)
        },
        _tr_tally$1 = (e, t, r) => (e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & r, e.last_lit++, 0 === t ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (_length_code[r] + LITERALS$1 + 1)]++, e.dyn_dtree[2 * d_code(t)]++), e.last_lit === e.lit_bufsize - 1);
    var _tr_init_1 = _tr_init$1,
        _tr_stored_block_1 = _tr_stored_block$1,
        _tr_flush_block_1 = _tr_flush_block$1,
        _tr_tally_1 = _tr_tally$1,
        _tr_align_1 = _tr_align$1,
        trees = {
            _tr_init: _tr_init_1,
            _tr_stored_block: _tr_stored_block_1,
            _tr_flush_block: _tr_flush_block_1,
            _tr_tally: _tr_tally_1,
            _tr_align: _tr_align_1
        };
    const adler32 = (e, t, r, n) => {
        let s = 65535 & e | 0,
            i = e >>> 16 & 65535 | 0,
            a = 0;
        for (; 0 !== r;) {
            a = r > 2e3 ? 2e3 : r, r -= a;
            do {
                s = s + t[n++] | 0, i = i + s | 0
            } while (--a);
            s %= 65521, i %= 65521
        }
        return s | i << 16 | 0
    };
    var adler32_1 = adler32;
    const makeTable = () => {
            let e, t = [];
            for (var r = 0; r < 256; r++) {
                e = r;
                for (var n = 0; n < 8; n++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                t[r] = e
            }
            return t
        },
        crcTable = new Uint32Array(makeTable()),
        crc32 = (e, t, r, n) => {
            const s = crcTable,
                i = n + r;
            e ^= -1;
            for (let r = n; r < i; r++) e = e >>> 8 ^ s[255 & (e ^ t[r])];
            return -1 ^ e
        };
    var crc32_1 = crc32,
        messages = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        },
        constants$2 = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
    const {
        _tr_init: _tr_init,
        _tr_stored_block: _tr_stored_block,
        _tr_flush_block: _tr_flush_block,
        _tr_tally: _tr_tally,
        _tr_align: _tr_align
    } = trees, {
        Z_NO_FLUSH: Z_NO_FLUSH$2,
        Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH: Z_FULL_FLUSH$1,
        Z_FINISH: Z_FINISH$3,
        Z_BLOCK: Z_BLOCK$1,
        Z_OK: Z_OK$3,
        Z_STREAM_END: Z_STREAM_END$3,
        Z_STREAM_ERROR: Z_STREAM_ERROR$2,
        Z_DATA_ERROR: Z_DATA_ERROR$2,
        Z_BUF_ERROR: Z_BUF_ERROR$1,
        Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
        Z_FILTERED: Z_FILTERED,
        Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY,
        Z_RLE: Z_RLE,
        Z_FIXED: Z_FIXED,
        Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
        Z_UNKNOWN: Z_UNKNOWN,
        Z_DEFLATED: Z_DEFLATED$2
    } = constants$2, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (e, t) => (e.msg = messages[t], t), rank = e => (e << 1) - (e > 4 ? 9 : 0), zero = e => {
        let t = e.length;
        for (; --t >= 0;) e[t] = 0
    };
    let HASH_ZLIB = (e, t, r) => (t << e.hash_shift ^ r) & e.hash_mask,
        HASH = HASH_ZLIB;
    const flush_pending = e => {
            const t = e.state;
            let r = t.pending;
            r > e.avail_out && (r = e.avail_out), 0 !== r && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, 0 === t.pending && (t.pending_out = 0))
        },
        flush_block_only = (e, t) => {
            _tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, flush_pending(e.strm)
        },
        put_byte = (e, t) => {
            e.pending_buf[e.pending++] = t
        },
        putShortMSB = (e, t) => {
            e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t
        },
        read_buf = (e, t, r, n) => {
            let s = e.avail_in;
            return s > n && (s = n), 0 === s ? 0 : (e.avail_in -= s, t.set(e.input.subarray(e.next_in, e.next_in + s), r), 1 === e.state.wrap ? e.adler = adler32_1(e.adler, t, s, r) : 2 === e.state.wrap && (e.adler = crc32_1(e.adler, t, s, r)), e.next_in += s, e.total_in += s, s)
        },
        longest_match = (e, t) => {
            let r, n, s = e.max_chain_length,
                i = e.strstart,
                a = e.prev_length,
                o = e.nice_match;
            const l = e.strstart > e.w_size - MIN_LOOKAHEAD ? e.strstart - (e.w_size - MIN_LOOKAHEAD) : 0,
                c = e.window,
                h = e.w_mask,
                u = e.prev,
                d = e.strstart + MAX_MATCH;
            let f = c[i + a - 1],
                p = c[i + a];
            e.prev_length >= e.good_match && (s >>= 2), o > e.lookahead && (o = e.lookahead);
            do {
                if (r = t, c[r + a] === p && c[r + a - 1] === f && c[r] === c[i] && c[++r] === c[i + 1]) {
                    i += 2, r++;
                    do {} while (c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && i < d);
                    if (n = MAX_MATCH - (d - i), i = d - MAX_MATCH, n > a) {
                        if (e.match_start = t, a = n, n >= o) break;
                        f = c[i + a - 1], p = c[i + a]
                    }
                }
            } while ((t = u[t & h]) > l && 0 != --s);
            return a <= e.lookahead ? a : e.lookahead
        },
        fill_window = e => {
            const t = e.w_size;
            let r, n, s, i, a;
            do {
                if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - MIN_LOOKAHEAD)) {
                    e.window.set(e.window.subarray(t, t + t), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, n = e.hash_size, r = n;
                    do {
                        s = e.head[--r], e.head[r] = s >= t ? s - t : 0
                    } while (--n);
                    n = t, r = n;
                    do {
                        s = e.prev[--r], e.prev[r] = s >= t ? s - t : 0
                    } while (--n);
                    i += t
                }
                if (0 === e.strm.avail_in) break;
                if (n = read_buf(e.strm, e.window, e.strstart + e.lookahead, i), e.lookahead += n, e.lookahead + e.insert >= MIN_MATCH)
                    for (a = e.strstart - e.insert, e.ins_h = e.window[a], e.ins_h = HASH(e, e.ins_h, e.window[a + 1]); e.insert && (e.ins_h = HASH(e, e.ins_h, e.window[a + MIN_MATCH - 1]), e.prev[a & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = a, a++, e.insert--, !(e.lookahead + e.insert < MIN_MATCH)););
            } while (e.lookahead < MIN_LOOKAHEAD && 0 !== e.strm.avail_in)
        },
        deflate_stored = (e, t) => {
            let r = 65535;
            for (r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5);;) {
                if (e.lookahead <= 1) {
                    if (fill_window(e), 0 === e.lookahead && t === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (0 === e.lookahead) break
                }
                e.strstart += e.lookahead, e.lookahead = 0;
                const n = e.block_start + r;
                if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE;
                if (e.strstart - e.block_start >= e.w_size - MIN_LOOKAHEAD && (flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE
            }
            return e.insert = 0, t === Z_FINISH$3 ? (flush_block_only(e, !0), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : (e.strstart > e.block_start && (flush_block_only(e, !1), e.strm.avail_out), BS_NEED_MORE)
        },
        deflate_fast = (e, t) => {
            let r, n;
            for (;;) {
                if (e.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (0 === e.lookahead) break
                }
                if (r = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== r && e.strstart - r <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, r)), e.match_length >= MIN_MATCH)
                    if (n = _tr_tally(e, e.strstart - e.match_start, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= MIN_MATCH) {
                        e.match_length--;
                        do {
                            e.strstart++, e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart
                        } while (0 != --e.match_length);
                        e.strstart++
                    } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + 1]);
                else n = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
                if (n && (flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE
            }
            return e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$3 ? (flush_block_only(e, !0), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, !1), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_slow = (e, t) => {
            let r, n, s;
            for (;;) {
                if (e.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (0 === e.lookahead) break
                }
                if (r = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = MIN_MATCH - 1, 0 !== r && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, r), e.match_length <= 5 && (e.strategy === Z_FILTERED || e.match_length === MIN_MATCH && e.strstart - e.match_start > 4096) && (e.match_length = MIN_MATCH - 1)), e.prev_length >= MIN_MATCH && e.match_length <= e.prev_length) {
                    s = e.strstart + e.lookahead - MIN_MATCH, n = _tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - MIN_MATCH), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
                    do {
                        ++e.strstart <= s && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart)
                    } while (0 != --e.prev_length);
                    if (e.match_available = 0, e.match_length = MIN_MATCH - 1, e.strstart++, n && (flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE
                } else if (e.match_available) {
                    if (n = _tr_tally(e, 0, e.window[e.strstart - 1]), n && flush_block_only(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return BS_NEED_MORE
                } else e.match_available = 1, e.strstart++, e.lookahead--
            }
            return e.match_available && (n = _tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$3 ? (flush_block_only(e, !0), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, !1), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_rle = (e, t) => {
            let r, n, s, i;
            const a = e.window;
            for (;;) {
                if (e.lookahead <= MAX_MATCH) {
                    if (fill_window(e), e.lookahead <= MAX_MATCH && t === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (0 === e.lookahead) break
                }
                if (e.match_length = 0, e.lookahead >= MIN_MATCH && e.strstart > 0 && (s = e.strstart - 1, n = a[s], n === a[++s] && n === a[++s] && n === a[++s])) {
                    i = e.strstart + MAX_MATCH;
                    do {} while (n === a[++s] && n === a[++s] && n === a[++s] && n === a[++s] && n === a[++s] && n === a[++s] && n === a[++s] && n === a[++s] && s < i);
                    e.match_length = MAX_MATCH - (i - s), e.match_length > e.lookahead && (e.match_length = e.lookahead)
                }
                if (e.match_length >= MIN_MATCH ? (r = _tr_tally(e, 1, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE
            }
            return e.insert = 0, t === Z_FINISH$3 ? (flush_block_only(e, !0), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, !1), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_huff = (e, t) => {
            let r;
            for (;;) {
                if (0 === e.lookahead && (fill_window(e), 0 === e.lookahead)) {
                    if (t === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    break
                }
                if (e.match_length = 0, r = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (flush_block_only(e, !1), 0 === e.strm.avail_out)) return BS_NEED_MORE
            }
            return e.insert = 0, t === Z_FINISH$3 ? (flush_block_only(e, !0), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, !1), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
        };

    function Config(e, t, r, n, s) {
        this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = s
    }
    const configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)],
        lm_init = e => {
            e.window_size = 2 * e.w_size, zero(e.head), e.max_lazy_match = configuration_table[e.level].max_lazy, e.good_match = configuration_table[e.level].good_length, e.nice_match = configuration_table[e.level].nice_length, e.max_chain_length = configuration_table[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = MIN_MATCH - 1, e.match_available = 0, e.ins_h = 0
        };

    function DeflateState() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * HEAP_SIZE), this.dyn_dtree = new Uint16Array(2 * (2 * D_CODES + 1)), this.bl_tree = new Uint16Array(2 * (2 * BL_CODES + 1)), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
    }
    const deflateResetKeep = e => {
            if (!e || !e.state) return err(e, Z_STREAM_ERROR$2);
            e.total_in = e.total_out = 0, e.data_type = Z_UNKNOWN;
            const t = e.state;
            return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? INIT_STATE : BUSY_STATE, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = Z_NO_FLUSH$2, _tr_init(t), Z_OK$3
        },
        deflateReset = e => {
            const t = deflateResetKeep(e);
            return t === Z_OK$3 && lm_init(e.state), t
        },
        deflateSetHeader = (e, t) => e && e.state ? 2 !== e.state.wrap ? Z_STREAM_ERROR$2 : (e.state.gzhead = t, Z_OK$3) : Z_STREAM_ERROR$2,
        deflateInit2 = (e, t, r, n, s, i) => {
            if (!e) return Z_STREAM_ERROR$2;
            let a = 1;
            if (t === Z_DEFAULT_COMPRESSION$1 && (t = 6), n < 0 ? (a = 0, n = -n) : n > 15 && (a = 2, n -= 16), s < 1 || s > MAX_MEM_LEVEL || r !== Z_DEFLATED$2 || n < 8 || n > 15 || t < 0 || t > 9 || i < 0 || i > Z_FIXED) return err(e, Z_STREAM_ERROR$2);
            8 === n && (n = 9);
            const o = new DeflateState;
            return e.state = o, o.strm = e, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = s + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + MIN_MATCH - 1) / MIN_MATCH), o.window = new Uint8Array(2 * o.w_size), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << s + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new Uint8Array(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = i, o.method = r, deflateReset(e)
        },
        deflateInit = (e, t) => deflateInit2(e, t, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1),
        deflate$2 = (e, t) => {
            let r, n;
            if (!e || !e.state || t > Z_BLOCK$1 || t < 0) return e ? err(e, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
            const s = e.state;
            if (!e.output || !e.input && 0 !== e.avail_in || s.status === FINISH_STATE && t !== Z_FINISH$3) return err(e, 0 === e.avail_out ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
            s.strm = e;
            const i = s.last_flush;
            if (s.last_flush = t, s.status === INIT_STATE)
                if (2 === s.wrap) e.adler = 0, put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), put_byte(s, 255 & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0), put_byte(s, 255 & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 255 & s.gzhead.extra.length), put_byte(s, s.gzhead.extra.length >> 8 & 255)), s.gzhead.hcrc && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending, 0)), s.gzindex = 0, s.status = EXTRA_STATE) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0), put_byte(s, OS_CODE), s.status = BUSY_STATE);
                else {
                    let t = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8,
                        r = -1;
                    r = s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3, t |= r << 6, 0 !== s.strstart && (t |= PRESET_DICT), t += 31 - t % 31, s.status = BUSY_STATE, putShortMSB(s, t), 0 !== s.strstart && (putShortMSB(s, e.adler >>> 16), putShortMSB(s, 65535 & e.adler)), e.adler = 1
                } if (s.status === EXTRA_STATE)
                if (s.gzhead.extra) {
                    for (r = s.pending; s.gzindex < (65535 & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), flush_pending(e), r = s.pending, s.pending !== s.pending_buf_size));) put_byte(s, 255 & s.gzhead.extra[s.gzindex]), s.gzindex++;
                    s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = NAME_STATE)
                } else s.status = NAME_STATE;
            if (s.status === NAME_STATE)
                if (s.gzhead.name) {
                    r = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), flush_pending(e), r = s.pending, s.pending === s.pending_buf_size)) {
                            n = 1;
                            break
                        }
                        n = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0, put_byte(s, n)
                    } while (0 !== n);
                    s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), 0 === n && (s.gzindex = 0, s.status = COMMENT_STATE)
                } else s.status = COMMENT_STATE;
            if (s.status === COMMENT_STATE)
                if (s.gzhead.comment) {
                    r = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), flush_pending(e), r = s.pending, s.pending === s.pending_buf_size)) {
                            n = 1;
                            break
                        }
                        n = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, put_byte(s, n)
                    } while (0 !== n);
                    s.gzhead.hcrc && s.pending > r && (e.adler = crc32_1(e.adler, s.pending_buf, s.pending - r, r)), 0 === n && (s.status = HCRC_STATE)
                } else s.status = HCRC_STATE;
            if (s.status === HCRC_STATE && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(e), s.pending + 2 <= s.pending_buf_size && (put_byte(s, 255 & e.adler), put_byte(s, e.adler >> 8 & 255), e.adler = 0, s.status = BUSY_STATE)) : s.status = BUSY_STATE), 0 !== s.pending) {
                if (flush_pending(e), 0 === e.avail_out) return s.last_flush = -1, Z_OK$3
            } else if (0 === e.avail_in && rank(t) <= rank(i) && t !== Z_FINISH$3) return err(e, Z_BUF_ERROR$1);
            if (s.status === FINISH_STATE && 0 !== e.avail_in) return err(e, Z_BUF_ERROR$1);
            if (0 !== e.avail_in || 0 !== s.lookahead || t !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
                let r = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, t) : s.strategy === Z_RLE ? deflate_rle(s, t) : configuration_table[s.level].func(s, t);
                if (r !== BS_FINISH_STARTED && r !== BS_FINISH_DONE || (s.status = FINISH_STATE), r === BS_NEED_MORE || r === BS_FINISH_STARTED) return 0 === e.avail_out && (s.last_flush = -1), Z_OK$3;
                if (r === BS_BLOCK_DONE && (t === Z_PARTIAL_FLUSH ? _tr_align(s) : t !== Z_BLOCK$1 && (_tr_stored_block(s, 0, 0, !1), t === Z_FULL_FLUSH$1 && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, s.insert = 0))), flush_pending(e), 0 === e.avail_out)) return s.last_flush = -1, Z_OK$3
            }
            return t !== Z_FINISH$3 ? Z_OK$3 : s.wrap <= 0 ? Z_STREAM_END$3 : (2 === s.wrap ? (put_byte(s, 255 & e.adler), put_byte(s, e.adler >> 8 & 255), put_byte(s, e.adler >> 16 & 255), put_byte(s, e.adler >> 24 & 255), put_byte(s, 255 & e.total_in), put_byte(s, e.total_in >> 8 & 255), put_byte(s, e.total_in >> 16 & 255), put_byte(s, e.total_in >> 24 & 255)) : (putShortMSB(s, e.adler >>> 16), putShortMSB(s, 65535 & e.adler)), flush_pending(e), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? Z_OK$3 : Z_STREAM_END$3)
        },
        deflateEnd = e => {
            if (!e || !e.state) return Z_STREAM_ERROR$2;
            const t = e.state.status;
            return t !== INIT_STATE && t !== EXTRA_STATE && t !== NAME_STATE && t !== COMMENT_STATE && t !== HCRC_STATE && t !== BUSY_STATE && t !== FINISH_STATE ? err(e, Z_STREAM_ERROR$2) : (e.state = null, t === BUSY_STATE ? err(e, Z_DATA_ERROR$2) : Z_OK$3)
        },
        deflateSetDictionary = (e, t) => {
            let r = t.length;
            if (!e || !e.state) return Z_STREAM_ERROR$2;
            const n = e.state,
                s = n.wrap;
            if (2 === s || 1 === s && n.status !== INIT_STATE || n.lookahead) return Z_STREAM_ERROR$2;
            if (1 === s && (e.adler = adler32_1(e.adler, t, r, 0)), n.wrap = 0, r >= n.w_size) {
                0 === s && (zero(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
                let e = new Uint8Array(n.w_size);
                e.set(t.subarray(r - n.w_size, r), 0), t = e, r = n.w_size
            }
            const i = e.avail_in,
                a = e.next_in,
                o = e.input;
            for (e.avail_in = r, e.next_in = 0, e.input = t, fill_window(n); n.lookahead >= MIN_MATCH;) {
                let e = n.strstart,
                    t = n.lookahead - (MIN_MATCH - 1);
                do {
                    n.ins_h = HASH(n, n.ins_h, n.window[e + MIN_MATCH - 1]), n.prev[e & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = e, e++
                } while (--t);
                n.strstart = e, n.lookahead = MIN_MATCH - 1, fill_window(n)
            }
            return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = MIN_MATCH - 1, n.match_available = 0, e.next_in = a, e.input = o, e.avail_in = i, n.wrap = s, Z_OK$3
        };
    var deflateInit_1 = deflateInit,
        deflateInit2_1 = deflateInit2,
        deflateReset_1 = deflateReset,
        deflateResetKeep_1 = deflateResetKeep,
        deflateSetHeader_1 = deflateSetHeader,
        deflate_2$1 = deflate$2,
        deflateEnd_1 = deflateEnd,
        deflateSetDictionary_1 = deflateSetDictionary,
        deflateInfo = "pako deflate (from Nodeca project)",
        deflate_1$2 = {
            deflateInit: deflateInit_1,
            deflateInit2: deflateInit2_1,
            deflateReset: deflateReset_1,
            deflateResetKeep: deflateResetKeep_1,
            deflateSetHeader: deflateSetHeader_1,
            deflate: deflate_2$1,
            deflateEnd: deflateEnd_1,
            deflateSetDictionary: deflateSetDictionary_1,
            deflateInfo: deflateInfo
        };
    const _has = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
    var assign = function(e) {
            const t = Array.prototype.slice.call(arguments, 1);
            for (; t.length;) {
                const r = t.shift();
                if (r) {
                    if ("object" != typeof r) throw new TypeError(r + "must be non-object");
                    for (const t in r) _has(r, t) && (e[t] = r[t])
                }
            }
            return e
        },
        flattenChunks = e => {
            let t = 0;
            for (let r = 0, n = e.length; r < n; r++) t += e[r].length;
            const r = new Uint8Array(t);
            for (let t = 0, n = 0, s = e.length; t < s; t++) {
                let s = e[t];
                r.set(s, n), n += s.length
            }
            return r
        },
        common = {
            assign: assign,
            flattenChunks: flattenChunks
        };
    let STR_APPLY_UIA_OK = !0;
    try {
        String.fromCharCode.apply(null, new Uint8Array(1))
    } catch (e) {
        STR_APPLY_UIA_OK = !1
    }
    const _utf8len = new Uint8Array(256);
    for (let e = 0; e < 256; e++) _utf8len[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = e => {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(e);
        let t, r, n, s, i, a = e.length,
            o = 0;
        for (s = 0; s < a; s++) r = e.charCodeAt(s), 55296 == (64512 & r) && s + 1 < a && (n = e.charCodeAt(s + 1), 56320 == (64512 & n) && (r = 65536 + (r - 55296 << 10) + (n - 56320), s++)), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
        for (t = new Uint8Array(o), i = 0, s = 0; i < o; s++) r = e.charCodeAt(s), 55296 == (64512 & r) && s + 1 < a && (n = e.charCodeAt(s + 1), 56320 == (64512 & n) && (r = 65536 + (r - 55296 << 10) + (n - 56320), s++)), r < 128 ? t[i++] = r : r < 2048 ? (t[i++] = 192 | r >>> 6, t[i++] = 128 | 63 & r) : r < 65536 ? (t[i++] = 224 | r >>> 12, t[i++] = 128 | r >>> 6 & 63, t[i++] = 128 | 63 & r) : (t[i++] = 240 | r >>> 18, t[i++] = 128 | r >>> 12 & 63, t[i++] = 128 | r >>> 6 & 63, t[i++] = 128 | 63 & r);
        return t
    };
    const buf2binstring = (e, t) => {
        if (t < 65534 && e.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
        let r = "";
        for (let n = 0; n < t; n++) r += String.fromCharCode(e[n]);
        return r
    };
    var buf2string = (e, t) => {
            const r = t || e.length;
            if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(e.subarray(0, t));
            let n, s;
            const i = new Array(2 * r);
            for (s = 0, n = 0; n < r;) {
                let t = e[n++];
                if (t < 128) {
                    i[s++] = t;
                    continue
                }
                let a = _utf8len[t];
                if (a > 4) i[s++] = 65533, n += a - 1;
                else {
                    for (t &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && n < r;) t = t << 6 | 63 & e[n++], a--;
                    a > 1 ? i[s++] = 65533 : t < 65536 ? i[s++] = t : (t -= 65536, i[s++] = 55296 | t >> 10 & 1023, i[s++] = 56320 | 1023 & t)
                }
            }
            return buf2binstring(i, s)
        },
        utf8border = (e, t) => {
            (t = t || e.length) > e.length && (t = e.length);
            let r = t - 1;
            for (; r >= 0 && 128 == (192 & e[r]);) r--;
            return r < 0 || 0 === r ? t : r + _utf8len[e[r]] > t ? r : t
        },
        strings = {
            string2buf: string2buf,
            buf2string: buf2string,
            utf8border: utf8border
        };

    function ZStream() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
    }
    var zstream = ZStream;
    const toString$1 = Object.prototype.toString,
        {
            Z_NO_FLUSH: Z_NO_FLUSH$1,
            Z_SYNC_FLUSH: Z_SYNC_FLUSH,
            Z_FULL_FLUSH: Z_FULL_FLUSH,
            Z_FINISH: Z_FINISH$2,
            Z_OK: Z_OK$2,
            Z_STREAM_END: Z_STREAM_END$2,
            Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION,
            Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY,
            Z_DEFLATED: Z_DEFLATED$1
        } = constants$2;

    function Deflate$1(e) {
        this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, e || {});
        let t = this.options;
        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
        let r = deflate_1$2.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
        if (r !== Z_OK$2) throw new Error(messages[r]);
        if (t.header && deflate_1$2.deflateSetHeader(this.strm, t.header), t.dictionary) {
            let e;
            if (e = "string" == typeof t.dictionary ? strings.string2buf(t.dictionary) : "[object ArrayBuffer]" === toString$1.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, r = deflate_1$2.deflateSetDictionary(this.strm, e), r !== Z_OK$2) throw new Error(messages[r]);
            this._dict_set = !0
        }
    }
    Deflate$1.prototype.push = function(e, t) {
        const r = this.strm,
            n = this.options.chunkSize;
        let s, i;
        if (this.ended) return !1;
        for (i = t === ~~t ? t : !0 === t ? Z_FINISH$2 : Z_NO_FLUSH$1, "string" == typeof e ? r.input = strings.string2buf(e) : "[object ArrayBuffer]" === toString$1.call(e) ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length;;)
            if (0 === r.avail_out && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (i === Z_SYNC_FLUSH || i === Z_FULL_FLUSH) && r.avail_out <= 6) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
            else {
                if (s = deflate_1$2.deflate(r, i), s === Z_STREAM_END$2) return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), s = deflate_1$2.deflateEnd(this.strm), this.onEnd(s), this.ended = !0, s === Z_OK$2;
                if (0 !== r.avail_out) {
                    if (i > 0 && r.next_out > 0) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
                    else if (0 === r.avail_in) break
                } else this.onData(r.output)
            } return !0
    }, Deflate$1.prototype.onData = function(e) {
        this.chunks.push(e)
    }, Deflate$1.prototype.onEnd = function(e) {
        e === Z_OK$2 && (this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
    };
    const BAD$1 = 30,
        TYPE$1 = 12;
    var inffast = function(e, t) {
        let r, n, s, i, a, o, l, c, h, u, d, f, p, _, g, m, A, y, b, E, v, S, T, w;
        const R = e.state;
        r = e.next_in, T = e.input, n = r + (e.avail_in - 5), s = e.next_out, w = e.output, i = s - (t - e.avail_out), a = s + (e.avail_out - 257), o = R.dmax, l = R.wsize, c = R.whave, h = R.wnext, u = R.window, d = R.hold, f = R.bits, p = R.lencode, _ = R.distcode, g = (1 << R.lenbits) - 1, m = (1 << R.distbits) - 1;
        e: do {
            f < 15 && (d += T[r++] << f, f += 8, d += T[r++] << f, f += 8), A = p[d & g];
            t: for (;;) {
                if (y = A >>> 24, d >>>= y, f -= y, y = A >>> 16 & 255, 0 === y) w[s++] = 65535 & A;
                else {
                    if (!(16 & y)) {
                        if (0 == (64 & y)) {
                            A = p[(65535 & A) + (d & (1 << y) - 1)];
                            continue t
                        }
                        if (32 & y) {
                            R.mode = TYPE$1;
                            break e
                        }
                        e.msg = "invalid literal/length code", R.mode = BAD$1;
                        break e
                    }
                    b = 65535 & A, y &= 15, y && (f < y && (d += T[r++] << f, f += 8), b += d & (1 << y) - 1, d >>>= y, f -= y), f < 15 && (d += T[r++] << f, f += 8, d += T[r++] << f, f += 8), A = _[d & m];
                    r: for (;;) {
                        if (y = A >>> 24, d >>>= y, f -= y, y = A >>> 16 & 255, !(16 & y)) {
                            if (0 == (64 & y)) {
                                A = _[(65535 & A) + (d & (1 << y) - 1)];
                                continue r
                            }
                            e.msg = "invalid distance code", R.mode = BAD$1;
                            break e
                        }
                        if (E = 65535 & A, y &= 15, f < y && (d += T[r++] << f, f += 8, f < y && (d += T[r++] << f, f += 8)), E += d & (1 << y) - 1, E > o) {
                            e.msg = "invalid distance too far back", R.mode = BAD$1;
                            break e
                        }
                        if (d >>>= y, f -= y, y = s - i, E > y) {
                            if (y = E - y, y > c && R.sane) {
                                e.msg = "invalid distance too far back", R.mode = BAD$1;
                                break e
                            }
                            if (v = 0, S = u, 0 === h) {
                                if (v += l - y, y < b) {
                                    b -= y;
                                    do {
                                        w[s++] = u[v++]
                                    } while (--y);
                                    v = s - E, S = w
                                }
                            } else if (h < y) {
                                if (v += l + h - y, y -= h, y < b) {
                                    b -= y;
                                    do {
                                        w[s++] = u[v++]
                                    } while (--y);
                                    if (v = 0, h < b) {
                                        y = h, b -= y;
                                        do {
                                            w[s++] = u[v++]
                                        } while (--y);
                                        v = s - E, S = w
                                    }
                                }
                            } else if (v += h - y, y < b) {
                                b -= y;
                                do {
                                    w[s++] = u[v++]
                                } while (--y);
                                v = s - E, S = w
                            }
                            for (; b > 2;) w[s++] = S[v++], w[s++] = S[v++], w[s++] = S[v++], b -= 3;
                            b && (w[s++] = S[v++], b > 1 && (w[s++] = S[v++]))
                        } else {
                            v = s - E;
                            do {
                                w[s++] = w[v++], w[s++] = w[v++], w[s++] = w[v++], b -= 3
                            } while (b > 2);
                            b && (w[s++] = w[v++], b > 1 && (w[s++] = w[v++]))
                        }
                        break
                    }
                }
                break
            }
        } while (r < n && s < a);
        b = f >> 3, r -= b, f -= b << 3, d &= (1 << f) - 1, e.next_in = r, e.next_out = s, e.avail_in = r < n ? n - r + 5 : 5 - (r - n), e.avail_out = s < a ? a - s + 257 : 257 - (s - a), R.hold = d, R.bits = f
    };
    const MAXBITS = 15,
        ENOUGH_LENS$1 = 852,
        ENOUGH_DISTS$1 = 592,
        CODES$1 = 0,
        LENS$1 = 1,
        DISTS$1 = 2,
        lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
        lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
        dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
        dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
        inflate_table = (e, t, r, n, s, i, a, o) => {
            const l = o.bits;
            let c, h, u, d, f, p, _ = 0,
                g = 0,
                m = 0,
                A = 0,
                y = 0,
                b = 0,
                E = 0,
                v = 0,
                S = 0,
                T = 0,
                w = null,
                R = 0;
            const C = new Uint16Array(MAXBITS + 1),
                I = new Uint16Array(MAXBITS + 1);
            let x, O, k, N = null,
                L = 0;
            for (_ = 0; _ <= MAXBITS; _++) C[_] = 0;
            for (g = 0; g < n; g++) C[t[r + g]]++;
            for (y = l, A = MAXBITS; A >= 1 && 0 === C[A]; A--);
            if (y > A && (y = A), 0 === A) return s[i++] = 20971520, s[i++] = 20971520, o.bits = 1, 0;
            for (m = 1; m < A && 0 === C[m]; m++);
            for (y < m && (y = m), v = 1, _ = 1; _ <= MAXBITS; _++)
                if (v <<= 1, v -= C[_], v < 0) return -1;
            if (v > 0 && (e === CODES$1 || 1 !== A)) return -1;
            for (I[1] = 0, _ = 1; _ < MAXBITS; _++) I[_ + 1] = I[_] + C[_];
            for (g = 0; g < n; g++) 0 !== t[r + g] && (a[I[t[r + g]]++] = g);
            if (e === CODES$1 ? (w = N = a, p = 19) : e === LENS$1 ? (w = lbase, R -= 257, N = lext, L -= 257, p = 256) : (w = dbase, N = dext, p = -1), T = 0, g = 0, _ = m, f = i, b = y, E = 0, u = -1, S = 1 << y, d = S - 1, e === LENS$1 && S > ENOUGH_LENS$1 || e === DISTS$1 && S > ENOUGH_DISTS$1) return 1;
            for (;;) {
                x = _ - E, a[g] < p ? (O = 0, k = a[g]) : a[g] > p ? (O = N[L + a[g]], k = w[R + a[g]]) : (O = 96, k = 0), c = 1 << _ - E, h = 1 << b, m = h;
                do {
                    h -= c, s[f + (T >> E) + h] = x << 24 | O << 16 | k | 0
                } while (0 !== h);
                for (c = 1 << _ - 1; T & c;) c >>= 1;
                if (0 !== c ? (T &= c - 1, T += c) : T = 0, g++, 0 == --C[_]) {
                    if (_ === A) break;
                    _ = t[r + a[g]]
                }
                if (_ > y && (T & d) !== u) {
                    for (0 === E && (E = y), f += m, b = _ - E, v = 1 << b; b + E < A && (v -= C[b + E], !(v <= 0));) b++, v <<= 1;
                    if (S += 1 << b, e === LENS$1 && S > ENOUGH_LENS$1 || e === DISTS$1 && S > ENOUGH_DISTS$1) return 1;
                    u = T & d, s[u] = y << 24 | b << 16 | f - i | 0
                }
            }
            return 0 !== T && (s[f + T] = _ - E << 24 | 64 << 16 | 0), o.bits = y, 0
        };
    var inftrees = inflate_table;
    const CODES = 0,
        LENS = 1,
        DISTS = 2,
        {
            Z_FINISH: Z_FINISH$1,
            Z_BLOCK: Z_BLOCK,
            Z_TREES: Z_TREES,
            Z_OK: Z_OK$1,
            Z_STREAM_END: Z_STREAM_END$1,
            Z_NEED_DICT: Z_NEED_DICT$1,
            Z_STREAM_ERROR: Z_STREAM_ERROR$1,
            Z_DATA_ERROR: Z_DATA_ERROR$1,
            Z_MEM_ERROR: Z_MEM_ERROR$1,
            Z_BUF_ERROR: Z_BUF_ERROR,
            Z_DEFLATED: Z_DEFLATED
        } = constants$2,
        HEAD = 1,
        FLAGS = 2,
        TIME = 3,
        OS = 4,
        EXLEN = 5,
        EXTRA = 6,
        NAME = 7,
        COMMENT = 8,
        HCRC = 9,
        DICTID = 10,
        DICT = 11,
        TYPE = 12,
        TYPEDO = 13,
        STORED = 14,
        COPY_ = 15,
        COPY = 16,
        TABLE = 17,
        LENLENS = 18,
        CODELENS = 19,
        LEN_ = 20,
        LEN = 21,
        LENEXT = 22,
        DIST = 23,
        DISTEXT = 24,
        MATCH = 25,
        LIT = 26,
        CHECK = 27,
        LENGTH$1 = 28,
        DONE = 29,
        BAD = 30,
        MEM = 31,
        SYNC = 32,
        ENOUGH_LENS = 852,
        ENOUGH_DISTS = 592,
        MAX_WBITS = 15,
        DEF_WBITS = MAX_WBITS,
        zswap32 = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);

    function InflateState() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
    }
    const inflateResetKeep = e => {
            if (!e || !e.state) return Z_STREAM_ERROR$1;
            const t = e.state;
            return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = HEAD, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(ENOUGH_LENS), t.distcode = t.distdyn = new Int32Array(ENOUGH_DISTS), t.sane = 1, t.back = -1, Z_OK$1
        },
        inflateReset = e => {
            if (!e || !e.state) return Z_STREAM_ERROR$1;
            const t = e.state;
            return t.wsize = 0, t.whave = 0, t.wnext = 0, inflateResetKeep(e)
        },
        inflateReset2 = (e, t) => {
            let r;
            if (!e || !e.state) return Z_STREAM_ERROR$1;
            const n = e.state;
            return t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Z_STREAM_ERROR$1 : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, inflateReset(e))
        },
        inflateInit2 = (e, t) => {
            if (!e) return Z_STREAM_ERROR$1;
            const r = new InflateState;
            e.state = r, r.window = null;
            const n = inflateReset2(e, t);
            return n !== Z_OK$1 && (e.state = null), n
        },
        inflateInit = e => inflateInit2(e, DEF_WBITS);
    let virgin = !0,
        lenfix, distfix;
    const fixedtables = e => {
            if (virgin) {
                lenfix = new Int32Array(512), distfix = new Int32Array(32);
                let t = 0;
                for (; t < 144;) e.lens[t++] = 8;
                for (; t < 256;) e.lens[t++] = 9;
                for (; t < 280;) e.lens[t++] = 7;
                for (; t < 288;) e.lens[t++] = 8;
                for (inftrees(LENS, e.lens, 0, 288, lenfix, 0, e.work, {
                        bits: 9
                    }), t = 0; t < 32;) e.lens[t++] = 5;
                inftrees(DISTS, e.lens, 0, 32, distfix, 0, e.work, {
                    bits: 5
                }), virgin = !1
            }
            e.lencode = lenfix, e.lenbits = 9, e.distcode = distfix, e.distbits = 5
        },
        updatewindow = (e, t, r, n) => {
            let s;
            const i = e.state;
            return null === i.window && (i.wsize = 1 << i.wbits, i.wnext = 0, i.whave = 0, i.window = new Uint8Array(i.wsize)), n >= i.wsize ? (i.window.set(t.subarray(r - i.wsize, r), 0), i.wnext = 0, i.whave = i.wsize) : (s = i.wsize - i.wnext, s > n && (s = n), i.window.set(t.subarray(r - n, r - n + s), i.wnext), (n -= s) ? (i.window.set(t.subarray(r - n, r), 0), i.wnext = n, i.whave = i.wsize) : (i.wnext += s, i.wnext === i.wsize && (i.wnext = 0), i.whave < i.wsize && (i.whave += s))), 0
        },
        inflate$2 = (e, t) => {
            let r, n, s, i, a, o, l, c, h, u, d, f, p, _, g, m, A, y, b, E, v, S, T = 0;
            const w = new Uint8Array(4);
            let R, C;
            const I = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
            if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return Z_STREAM_ERROR$1;
            r = e.state, r.mode === TYPE && (r.mode = TYPEDO), a = e.next_out, s = e.output, l = e.avail_out, i = e.next_in, n = e.input, o = e.avail_in, c = r.hold, h = r.bits, u = o, d = l, S = Z_OK$1;
            e: for (;;) switch (r.mode) {
                case HEAD:
                    if (0 === r.wrap) {
                        r.mode = TYPEDO;
                        break
                    }
                    for (; h < 16;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if (2 & r.wrap && 35615 === c) {
                        r.check = 0, w[0] = 255 & c, w[1] = c >>> 8 & 255, r.check = crc32_1(r.check, w, 2, 0), c = 0, h = 0, r.mode = FLAGS;
                        break
                    }
                    if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                        e.msg = "incorrect header check", r.mode = BAD;
                        break
                    }
                    if ((15 & c) !== Z_DEFLATED) {
                        e.msg = "unknown compression method", r.mode = BAD;
                        break
                    }
                    if (c >>>= 4, h -= 4, v = 8 + (15 & c), 0 === r.wbits) r.wbits = v;
                    else if (v > r.wbits) {
                        e.msg = "invalid window size", r.mode = BAD;
                        break
                    }
                    r.dmax = 1 << r.wbits, e.adler = r.check = 1, r.mode = 512 & c ? DICTID : TYPE, c = 0, h = 0;
                    break;
                case FLAGS:
                    for (; h < 16;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if (r.flags = c, (255 & r.flags) !== Z_DEFLATED) {
                        e.msg = "unknown compression method", r.mode = BAD;
                        break
                    }
                    if (57344 & r.flags) {
                        e.msg = "unknown header flags set", r.mode = BAD;
                        break
                    }
                    r.head && (r.head.text = c >> 8 & 1), 512 & r.flags && (w[0] = 255 & c, w[1] = c >>> 8 & 255, r.check = crc32_1(r.check, w, 2, 0)), c = 0, h = 0, r.mode = TIME;
                case TIME:
                    for (; h < 32;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    r.head && (r.head.time = c), 512 & r.flags && (w[0] = 255 & c, w[1] = c >>> 8 & 255, w[2] = c >>> 16 & 255, w[3] = c >>> 24 & 255, r.check = crc32_1(r.check, w, 4, 0)), c = 0, h = 0, r.mode = OS;
                case OS:
                    for (; h < 16;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    r.head && (r.head.xflags = 255 & c, r.head.os = c >> 8), 512 & r.flags && (w[0] = 255 & c, w[1] = c >>> 8 & 255, r.check = crc32_1(r.check, w, 2, 0)), c = 0, h = 0, r.mode = EXLEN;
                case EXLEN:
                    if (1024 & r.flags) {
                        for (; h < 16;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        r.length = c, r.head && (r.head.extra_len = c), 512 & r.flags && (w[0] = 255 & c, w[1] = c >>> 8 & 255, r.check = crc32_1(r.check, w, 2, 0)), c = 0, h = 0
                    } else r.head && (r.head.extra = null);
                    r.mode = EXTRA;
                case EXTRA:
                    if (1024 & r.flags && (f = r.length, f > o && (f = o), f && (r.head && (v = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(i, i + f), v)), 512 & r.flags && (r.check = crc32_1(r.check, n, f, i)), o -= f, i += f, r.length -= f), r.length)) break e;
                    r.length = 0, r.mode = NAME;
                case NAME:
                    if (2048 & r.flags) {
                        if (0 === o) break e;
                        f = 0;
                        do {
                            v = n[i + f++], r.head && v && r.length < 65536 && (r.head.name += String.fromCharCode(v))
                        } while (v && f < o);
                        if (512 & r.flags && (r.check = crc32_1(r.check, n, f, i)), o -= f, i += f, v) break e
                    } else r.head && (r.head.name = null);
                    r.length = 0, r.mode = COMMENT;
                case COMMENT:
                    if (4096 & r.flags) {
                        if (0 === o) break e;
                        f = 0;
                        do {
                            v = n[i + f++], r.head && v && r.length < 65536 && (r.head.comment += String.fromCharCode(v))
                        } while (v && f < o);
                        if (512 & r.flags && (r.check = crc32_1(r.check, n, f, i)), o -= f, i += f, v) break e
                    } else r.head && (r.head.comment = null);
                    r.mode = HCRC;
                case HCRC:
                    if (512 & r.flags) {
                        for (; h < 16;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        if (c !== (65535 & r.check)) {
                            e.msg = "header crc mismatch", r.mode = BAD;
                            break
                        }
                        c = 0, h = 0
                    }
                    r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = TYPE;
                    break;
                case DICTID:
                    for (; h < 32;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    e.adler = r.check = zswap32(c), c = 0, h = 0, r.mode = DICT;
                case DICT:
                    if (0 === r.havedict) return e.next_out = a, e.avail_out = l, e.next_in = i, e.avail_in = o, r.hold = c, r.bits = h, Z_NEED_DICT$1;
                    e.adler = r.check = 1, r.mode = TYPE;
                case TYPE:
                    if (t === Z_BLOCK || t === Z_TREES) break e;
                case TYPEDO:
                    if (r.last) {
                        c >>>= 7 & h, h -= 7 & h, r.mode = CHECK;
                        break
                    }
                    for (; h < 3;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    switch (r.last = 1 & c, c >>>= 1, h -= 1, 3 & c) {
                        case 0:
                            r.mode = STORED;
                            break;
                        case 1:
                            if (fixedtables(r), r.mode = LEN_, t === Z_TREES) {
                                c >>>= 2, h -= 2;
                                break e
                            }
                            break;
                        case 2:
                            r.mode = TABLE;
                            break;
                        case 3:
                            e.msg = "invalid block type", r.mode = BAD
                    }
                    c >>>= 2, h -= 2;
                    break;
                case STORED:
                    for (c >>>= 7 & h, h -= 7 & h; h < 32;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if ((65535 & c) != (c >>> 16 ^ 65535)) {
                        e.msg = "invalid stored block lengths", r.mode = BAD;
                        break
                    }
                    if (r.length = 65535 & c, c = 0, h = 0, r.mode = COPY_, t === Z_TREES) break e;
                case COPY_:
                    r.mode = COPY;
                case COPY:
                    if (f = r.length, f) {
                        if (f > o && (f = o), f > l && (f = l), 0 === f) break e;
                        s.set(n.subarray(i, i + f), a), o -= f, i += f, l -= f, a += f, r.length -= f;
                        break
                    }
                    r.mode = TYPE;
                    break;
                case TABLE:
                    for (; h < 14;) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if (r.nlen = 257 + (31 & c), c >>>= 5, h -= 5, r.ndist = 1 + (31 & c), c >>>= 5, h -= 5, r.ncode = 4 + (15 & c), c >>>= 4, h -= 4, r.nlen > 286 || r.ndist > 30) {
                        e.msg = "too many length or distance symbols", r.mode = BAD;
                        break
                    }
                    r.have = 0, r.mode = LENLENS;
                case LENLENS:
                    for (; r.have < r.ncode;) {
                        for (; h < 3;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        r.lens[I[r.have++]] = 7 & c, c >>>= 3, h -= 3
                    }
                    for (; r.have < 19;) r.lens[I[r.have++]] = 0;
                    if (r.lencode = r.lendyn, r.lenbits = 7, R = {
                            bits: r.lenbits
                        }, S = inftrees(CODES, r.lens, 0, 19, r.lencode, 0, r.work, R), r.lenbits = R.bits, S) {
                        e.msg = "invalid code lengths set", r.mode = BAD;
                        break
                    }
                    r.have = 0, r.mode = CODELENS;
                case CODELENS:
                    for (; r.have < r.nlen + r.ndist;) {
                        for (; T = r.lencode[c & (1 << r.lenbits) - 1], g = T >>> 24, m = T >>> 16 & 255, A = 65535 & T, !(g <= h);) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        if (A < 16) c >>>= g, h -= g, r.lens[r.have++] = A;
                        else {
                            if (16 === A) {
                                for (C = g + 2; h < C;) {
                                    if (0 === o) break e;
                                    o--, c += n[i++] << h, h += 8
                                }
                                if (c >>>= g, h -= g, 0 === r.have) {
                                    e.msg = "invalid bit length repeat", r.mode = BAD;
                                    break
                                }
                                v = r.lens[r.have - 1], f = 3 + (3 & c), c >>>= 2, h -= 2
                            } else if (17 === A) {
                                for (C = g + 3; h < C;) {
                                    if (0 === o) break e;
                                    o--, c += n[i++] << h, h += 8
                                }
                                c >>>= g, h -= g, v = 0, f = 3 + (7 & c), c >>>= 3, h -= 3
                            } else {
                                for (C = g + 7; h < C;) {
                                    if (0 === o) break e;
                                    o--, c += n[i++] << h, h += 8
                                }
                                c >>>= g, h -= g, v = 0, f = 11 + (127 & c), c >>>= 7, h -= 7
                            }
                            if (r.have + f > r.nlen + r.ndist) {
                                e.msg = "invalid bit length repeat", r.mode = BAD;
                                break
                            }
                            for (; f--;) r.lens[r.have++] = v
                        }
                    }
                    if (r.mode === BAD) break;
                    if (0 === r.lens[256]) {
                        e.msg = "invalid code -- missing end-of-block", r.mode = BAD;
                        break
                    }
                    if (r.lenbits = 9, R = {
                            bits: r.lenbits
                        }, S = inftrees(LENS, r.lens, 0, r.nlen, r.lencode, 0, r.work, R), r.lenbits = R.bits, S) {
                        e.msg = "invalid literal/lengths set", r.mode = BAD;
                        break
                    }
                    if (r.distbits = 6, r.distcode = r.distdyn, R = {
                            bits: r.distbits
                        }, S = inftrees(DISTS, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, R), r.distbits = R.bits, S) {
                        e.msg = "invalid distances set", r.mode = BAD;
                        break
                    }
                    if (r.mode = LEN_, t === Z_TREES) break e;
                case LEN_:
                    r.mode = LEN;
                case LEN:
                    if (o >= 6 && l >= 258) {
                        e.next_out = a, e.avail_out = l, e.next_in = i, e.avail_in = o, r.hold = c, r.bits = h, inffast(e, d), a = e.next_out, s = e.output, l = e.avail_out, i = e.next_in, n = e.input, o = e.avail_in, c = r.hold, h = r.bits, r.mode === TYPE && (r.back = -1);
                        break
                    }
                    for (r.back = 0; T = r.lencode[c & (1 << r.lenbits) - 1], g = T >>> 24, m = T >>> 16 & 255, A = 65535 & T, !(g <= h);) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if (m && 0 == (240 & m)) {
                        for (y = g, b = m, E = A; T = r.lencode[E + ((c & (1 << y + b) - 1) >> y)], g = T >>> 24, m = T >>> 16 & 255, A = 65535 & T, !(y + g <= h);) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        c >>>= y, h -= y, r.back += y
                    }
                    if (c >>>= g, h -= g, r.back += g, r.length = A, 0 === m) {
                        r.mode = LIT;
                        break
                    }
                    if (32 & m) {
                        r.back = -1, r.mode = TYPE;
                        break
                    }
                    if (64 & m) {
                        e.msg = "invalid literal/length code", r.mode = BAD;
                        break
                    }
                    r.extra = 15 & m, r.mode = LENEXT;
                case LENEXT:
                    if (r.extra) {
                        for (C = r.extra; h < C;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        r.length += c & (1 << r.extra) - 1, c >>>= r.extra, h -= r.extra, r.back += r.extra
                    }
                    r.was = r.length, r.mode = DIST;
                case DIST:
                    for (; T = r.distcode[c & (1 << r.distbits) - 1], g = T >>> 24, m = T >>> 16 & 255, A = 65535 & T, !(g <= h);) {
                        if (0 === o) break e;
                        o--, c += n[i++] << h, h += 8
                    }
                    if (0 == (240 & m)) {
                        for (y = g, b = m, E = A; T = r.distcode[E + ((c & (1 << y + b) - 1) >> y)], g = T >>> 24, m = T >>> 16 & 255, A = 65535 & T, !(y + g <= h);) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        c >>>= y, h -= y, r.back += y
                    }
                    if (c >>>= g, h -= g, r.back += g, 64 & m) {
                        e.msg = "invalid distance code", r.mode = BAD;
                        break
                    }
                    r.offset = A, r.extra = 15 & m, r.mode = DISTEXT;
                case DISTEXT:
                    if (r.extra) {
                        for (C = r.extra; h < C;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        r.offset += c & (1 << r.extra) - 1, c >>>= r.extra, h -= r.extra, r.back += r.extra
                    }
                    if (r.offset > r.dmax) {
                        e.msg = "invalid distance too far back", r.mode = BAD;
                        break
                    }
                    r.mode = MATCH;
                case MATCH:
                    if (0 === l) break e;
                    if (f = d - l, r.offset > f) {
                        if (f = r.offset - f, f > r.whave && r.sane) {
                            e.msg = "invalid distance too far back", r.mode = BAD;
                            break
                        }
                        f > r.wnext ? (f -= r.wnext, p = r.wsize - f) : p = r.wnext - f, f > r.length && (f = r.length), _ = r.window
                    } else _ = s, p = a - r.offset, f = r.length;
                    f > l && (f = l), l -= f, r.length -= f;
                    do {
                        s[a++] = _[p++]
                    } while (--f);
                    0 === r.length && (r.mode = LEN);
                    break;
                case LIT:
                    if (0 === l) break e;
                    s[a++] = r.length, l--, r.mode = LEN;
                    break;
                case CHECK:
                    if (r.wrap) {
                        for (; h < 32;) {
                            if (0 === o) break e;
                            o--, c |= n[i++] << h, h += 8
                        }
                        if (d -= l, e.total_out += d, r.total += d, d && (e.adler = r.check = r.flags ? crc32_1(r.check, s, d, a - d) : adler32_1(r.check, s, d, a - d)), d = l, (r.flags ? c : zswap32(c)) !== r.check) {
                            e.msg = "incorrect data check", r.mode = BAD;
                            break
                        }
                        c = 0, h = 0
                    }
                    r.mode = LENGTH$1;
                case LENGTH$1:
                    if (r.wrap && r.flags) {
                        for (; h < 32;) {
                            if (0 === o) break e;
                            o--, c += n[i++] << h, h += 8
                        }
                        if (c !== (4294967295 & r.total)) {
                            e.msg = "incorrect length check", r.mode = BAD;
                            break
                        }
                        c = 0, h = 0
                    }
                    r.mode = DONE;
                case DONE:
                    S = Z_STREAM_END$1;
                    break e;
                case BAD:
                    S = Z_DATA_ERROR$1;
                    break e;
                case MEM:
                    return Z_MEM_ERROR$1;
                case SYNC:
                default:
                    return Z_STREAM_ERROR$1
            }
            return e.next_out = a, e.avail_out = l, e.next_in = i, e.avail_in = o, r.hold = c, r.bits = h, (r.wsize || d !== e.avail_out && r.mode < BAD && (r.mode < CHECK || t !== Z_FINISH$1)) && updatewindow(e, e.output, e.next_out, d - e.avail_out), u -= e.avail_in, d -= e.avail_out, e.total_in += u, e.total_out += d, r.total += d, r.wrap && d && (e.adler = r.check = r.flags ? crc32_1(r.check, s, d, e.next_out - d) : adler32_1(r.check, s, d, e.next_out - d)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === TYPE ? 128 : 0) + (r.mode === LEN_ || r.mode === COPY_ ? 256 : 0), (0 === u && 0 === d || t === Z_FINISH$1) && S === Z_OK$1 && (S = Z_BUF_ERROR), S
        },
        inflateEnd = e => {
            if (!e || !e.state) return Z_STREAM_ERROR$1;
            let t = e.state;
            return t.window && (t.window = null), e.state = null, Z_OK$1
        },
        inflateGetHeader = (e, t) => {
            if (!e || !e.state) return Z_STREAM_ERROR$1;
            const r = e.state;
            return 0 == (2 & r.wrap) ? Z_STREAM_ERROR$1 : (r.head = t, t.done = !1, Z_OK$1)
        },
        inflateSetDictionary = (e, t) => {
            const r = t.length;
            let n, s, i;
            return e && e.state ? (n = e.state, 0 !== n.wrap && n.mode !== DICT ? Z_STREAM_ERROR$1 : n.mode === DICT && (s = 1, s = adler32_1(s, t, r, 0), s !== n.check) ? Z_DATA_ERROR$1 : (i = updatewindow(e, t, r, r), i ? (n.mode = MEM, Z_MEM_ERROR$1) : (n.havedict = 1, Z_OK$1))) : Z_STREAM_ERROR$1
        };
    var inflateReset_1 = inflateReset,
        inflateReset2_1 = inflateReset2,
        inflateResetKeep_1 = inflateResetKeep,
        inflateInit_1 = inflateInit,
        inflateInit2_1 = inflateInit2,
        inflate_2$1 = inflate$2,
        inflateEnd_1 = inflateEnd,
        inflateGetHeader_1 = inflateGetHeader,
        inflateSetDictionary_1 = inflateSetDictionary,
        inflateInfo = "pako inflate (from Nodeca project)",
        inflate_1$2 = {
            inflateReset: inflateReset_1,
            inflateReset2: inflateReset2_1,
            inflateResetKeep: inflateResetKeep_1,
            inflateInit: inflateInit_1,
            inflateInit2: inflateInit2_1,
            inflate: inflate_2$1,
            inflateEnd: inflateEnd_1,
            inflateGetHeader: inflateGetHeader_1,
            inflateSetDictionary: inflateSetDictionary_1,
            inflateInfo: inflateInfo
        };

    function GZheader() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
    }
    var gzheader = GZheader;
    const toString = Object.prototype.toString,
        {
            Z_NO_FLUSH: Z_NO_FLUSH,
            Z_FINISH: Z_FINISH,
            Z_OK: Z_OK,
            Z_STREAM_END: Z_STREAM_END,
            Z_NEED_DICT: Z_NEED_DICT,
            Z_STREAM_ERROR: Z_STREAM_ERROR,
            Z_DATA_ERROR: Z_DATA_ERROR,
            Z_MEM_ERROR: Z_MEM_ERROR
        } = constants$2;

    function Inflate$1(e) {
        this.options = common.assign({
            chunkSize: 65536,
            windowBits: 15,
            to: ""
        }, e || {});
        const t = this.options;
        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
        let r = inflate_1$2.inflateInit2(this.strm, t.windowBits);
        if (r !== Z_OK) throw new Error(messages[r]);
        if (this.header = new gzheader, inflate_1$2.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = strings.string2buf(t.dictionary) : "[object ArrayBuffer]" === toString.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = inflate_1$2.inflateSetDictionary(this.strm, t.dictionary), r !== Z_OK))) throw new Error(messages[r])
    }

    function inflate$1(e, t) {
        const r = new Inflate$1(t);
        if (r.push(e), r.err) throw r.msg || messages[r.err];
        return r.result
    }

    function inflateRaw$1(e, t) {
        return (t = t || {}).raw = !0, inflate$1(e, t)
    }
    Inflate$1.prototype.push = function(e, t) {
        const r = this.strm,
            n = this.options.chunkSize,
            s = this.options.dictionary;
        let i, a, o;
        if (this.ended) return !1;
        for (a = t === ~~t ? t : !0 === t ? Z_FINISH : Z_NO_FLUSH, "[object ArrayBuffer]" === toString.call(e) ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length;;) {
            for (0 === r.avail_out && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), i = inflate_1$2.inflate(r, a), i === Z_NEED_DICT && s && (i = inflate_1$2.inflateSetDictionary(r, s), i === Z_OK ? i = inflate_1$2.inflate(r, a) : i === Z_DATA_ERROR && (i = Z_NEED_DICT)); r.avail_in > 0 && i === Z_STREAM_END && r.state.wrap > 0 && 0 !== e[r.next_in];) inflate_1$2.inflateReset(r), i = inflate_1$2.inflate(r, a);
            switch (i) {
                case Z_STREAM_ERROR:
                case Z_DATA_ERROR:
                case Z_NEED_DICT:
                case Z_MEM_ERROR:
                    return this.onEnd(i), this.ended = !0, !1
            }
            if (o = r.avail_out, r.next_out && (0 === r.avail_out || i === Z_STREAM_END))
                if ("string" === this.options.to) {
                    let e = strings.utf8border(r.output, r.next_out),
                        t = r.next_out - e,
                        s = strings.buf2string(r.output, e);
                    r.next_out = t, r.avail_out = n - t, t && r.output.set(r.output.subarray(e, e + t), 0), this.onData(s)
                } else this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
            if (i !== Z_OK || 0 !== o) {
                if (i === Z_STREAM_END) return i = inflate_1$2.inflateEnd(this.strm), this.onEnd(i), this.ended = !0, !0;
                if (0 === r.avail_in) break
            }
        }
        return !0
    }, Inflate$1.prototype.onData = function(e) {
        this.chunks.push(e)
    }, Inflate$1.prototype.onEnd = function(e) {
        e === Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
    };
    var Inflate_1$1 = Inflate$1,
        inflate_2 = inflate$1,
        inflateRaw_1$1 = inflateRaw$1,
        ungzip$1 = inflate$1,
        constants$1 = constants$2,
        inflate_1$1 = {
            Inflate: Inflate_1$1,
            inflate: inflate_2,
            inflateRaw: inflateRaw_1$1,
            ungzip: ungzip$1,
            constants: constants$1
        };
    const {
        Inflate: Inflate,
        inflate: inflate,
        inflateRaw: inflateRaw,
        ungzip: ungzip
    } = inflate_1$1;
    var inflate_1 = inflate,
        iterator = function(e) {
            e.prototype[Symbol.iterator] = function*() {
                for (let e = this.head; e; e = e.next) yield e.value
            }
        },
        yallist = Yallist$1;

    function Yallist$1(e) {
        var t = this;
        if (t instanceof Yallist$1 || (t = new Yallist$1), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach((function(e) {
            t.push(e)
        }));
        else if (arguments.length > 0)
            for (var r = 0, n = arguments.length; r < n; r++) t.push(arguments[r]);
        return t
    }

    function insert(e, t, r) {
        var n = t === e.head ? new Node(r, null, t, e) : new Node(r, t, t.next, e);
        return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n
    }

    function push(e, t) {
        e.tail = new Node(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
    }

    function unshift(e, t) {
        e.head = new Node(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
    }

    function Node(e, t, r, n) {
        if (!(this instanceof Node)) return new Node(e, t, r, n);
        this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null
    }
    Yallist$1.Node = Node, Yallist$1.create = Yallist$1, Yallist$1.prototype.removeNode = function(e) {
        if (e.list !== this) throw new Error("removing node which does not belong to this list");
        var t = e.next,
            r = e.prev;
        return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t
    }, Yallist$1.prototype.unshiftNode = function(e) {
        if (e !== this.head) {
            e.list && e.list.removeNode(e);
            var t = this.head;
            e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
        }
    }, Yallist$1.prototype.pushNode = function(e) {
        if (e !== this.tail) {
            e.list && e.list.removeNode(e);
            var t = this.tail;
            e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
        }
    }, Yallist$1.prototype.push = function() {
        for (var e = 0, t = arguments.length; e < t; e++) push(this, arguments[e]);
        return this.length
    }, Yallist$1.prototype.unshift = function() {
        for (var e = 0, t = arguments.length; e < t; e++) unshift(this, arguments[e]);
        return this.length
    }, Yallist$1.prototype.pop = function() {
        if (this.tail) {
            var e = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
        }
    }, Yallist$1.prototype.shift = function() {
        if (this.head) {
            var e = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
        }
    }, Yallist$1.prototype.forEach = function(e, t) {
        t = t || this;
        for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next
    }, Yallist$1.prototype.forEachReverse = function(e, t) {
        t = t || this;
        for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev
    }, Yallist$1.prototype.get = function(e) {
        for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;
        if (t === e && null !== r) return r.value
    }, Yallist$1.prototype.getReverse = function(e) {
        for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;
        if (t === e && null !== r) return r.value
    }, Yallist$1.prototype.map = function(e, t) {
        t = t || this;
        for (var r = new Yallist$1, n = this.head; null !== n;) r.push(e.call(t, n.value, this)), n = n.next;
        return r
    }, Yallist$1.prototype.mapReverse = function(e, t) {
        t = t || this;
        for (var r = new Yallist$1, n = this.tail; null !== n;) r.push(e.call(t, n.value, this)), n = n.prev;
        return r
    }, Yallist$1.prototype.reduce = function(e, t) {
        var r, n = this.head;
        if (arguments.length > 1) r = t;
        else {
            if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
            n = this.head.next, r = this.head.value
        }
        for (var s = 0; null !== n; s++) r = e(r, n.value, s), n = n.next;
        return r
    }, Yallist$1.prototype.reduceReverse = function(e, t) {
        var r, n = this.tail;
        if (arguments.length > 1) r = t;
        else {
            if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
            n = this.tail.prev, r = this.tail.value
        }
        for (var s = this.length - 1; null !== n; s--) r = e(r, n.value, s), n = n.prev;
        return r
    }, Yallist$1.prototype.toArray = function() {
        for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;
        return e
    }, Yallist$1.prototype.toArrayReverse = function() {
        for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;
        return e
    }, Yallist$1.prototype.slice = function(e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new Yallist$1;
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var n = 0, s = this.head; null !== s && n < e; n++) s = s.next;
        for (; null !== s && n < t; n++, s = s.next) r.push(s.value);
        return r
    }, Yallist$1.prototype.sliceReverse = function(e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new Yallist$1;
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var n = this.length, s = this.tail; null !== s && n > t; n--) s = s.prev;
        for (; null !== s && n > e; n--, s = s.prev) r.push(s.value);
        return r
    }, Yallist$1.prototype.splice = function(e, t, ...r) {
        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
        for (var n = 0, s = this.head; null !== s && n < e; n++) s = s.next;
        var i = [];
        for (n = 0; s && n < t; n++) i.push(s.value), s = this.removeNode(s);
        null === s && (s = this.tail), s !== this.head && s !== this.tail && (s = s.prev);
        for (n = 0; n < r.length; n++) s = insert(this, s, r[n]);
        return i
    }, Yallist$1.prototype.reverse = function() {
        for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
            var n = r.prev;
            r.prev = r.next, r.next = n
        }
        return this.head = t, this.tail = e, this
    };
    try {
        iterator(Yallist$1)
    } catch (e) {}
    const Yallist = yallist,
        MAX = Symbol("max"),
        LENGTH = Symbol("length"),
        LENGTH_CALCULATOR = Symbol("lengthCalculator"),
        ALLOW_STALE = Symbol("allowStale"),
        MAX_AGE = Symbol("maxAge"),
        DISPOSE = Symbol("dispose"),
        NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"),
        LRU_LIST = Symbol("lruList"),
        CACHE = Symbol("cache"),
        UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"),
        naiveLength = () => 1;
    class LRUCache {
        constructor(e) {
            if ("number" == typeof e && (e = {
                    max: e
                }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
            this[MAX] = e.max || 1 / 0;
            const t = e.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = "function" != typeof t ? naiveLength : t, this[ALLOW_STALE] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = e.maxAge || 0, this[DISPOSE] = e.dispose, this[NO_DISPOSE_ON_SET] = e.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = e.updateAgeOnGet || !1, this.reset()
        }
        set max(e) {
            if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
            this[MAX] = e || 1 / 0, trim(this)
        }
        get max() {
            return this[MAX]
        }
        set allowStale(e) {
            this[ALLOW_STALE] = !!e
        }
        get allowStale() {
            return this[ALLOW_STALE]
        }
        set maxAge(e) {
            if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = e, trim(this)
        }
        get maxAge() {
            return this[MAX_AGE]
        }
        set lengthCalculator(e) {
            "function" != typeof e && (e = naiveLength), e !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = e, this[LENGTH] = 0, this[LRU_LIST].forEach((e => {
                e.length = this[LENGTH_CALCULATOR](e.value, e.key), this[LENGTH] += e.length
            }))), trim(this)
        }
        get lengthCalculator() {
            return this[LENGTH_CALCULATOR]
        }
        get length() {
            return this[LENGTH]
        }
        get itemCount() {
            return this[LRU_LIST].length
        }
        rforEach(e, t) {
            t = t || this;
            for (let r = this[LRU_LIST].tail; null !== r;) {
                const n = r.prev;
                forEachStep(this, e, r, t), r = n
            }
        }
        forEach(e, t) {
            t = t || this;
            for (let r = this[LRU_LIST].head; null !== r;) {
                const n = r.next;
                forEachStep(this, e, r, t), r = n
            }
        }
        keys() {
            return this[LRU_LIST].toArray().map((e => e.key))
        }
        values() {
            return this[LRU_LIST].toArray().map((e => e.value))
        }
        reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((e => this[DISPOSE](e.key, e.value))), this[CACHE] = new Map, this[LRU_LIST] = new Yallist, this[LENGTH] = 0
        }
        dump() {
            return this[LRU_LIST].map((e => !isStale(this, e) && {
                k: e.key,
                v: e.value,
                e: e.now + (e.maxAge || 0)
            })).toArray().filter((e => e))
        }
        dumpLru() {
            return this[LRU_LIST]
        }
        set(e, t, r) {
            if ((r = r || this[MAX_AGE]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
            const n = r ? Date.now() : 0,
                s = this[LENGTH_CALCULATOR](t, e);
            if (this[CACHE].has(e)) {
                if (s > this[MAX]) return del(this, this[CACHE].get(e)), !1;
                const i = this[CACHE].get(e).value;
                return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](e, i.value)), i.now = n, i.maxAge = r, i.value = t, this[LENGTH] += s - i.length, i.length = s, this.get(e), trim(this), !0
            }
            const i = new Entry(e, t, s, n, r);
            return i.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](e, t), !1) : (this[LENGTH] += i.length, this[LRU_LIST].unshift(i), this[CACHE].set(e, this[LRU_LIST].head), trim(this), !0)
        }
        has(e) {
            if (!this[CACHE].has(e)) return !1;
            const t = this[CACHE].get(e).value;
            return !isStale(this, t)
        }
        get(e) {
            return get(this, e, !0)
        }
        peek(e) {
            return get(this, e, !1)
        }
        pop() {
            const e = this[LRU_LIST].tail;
            return e ? (del(this, e), e.value) : null
        }
        del(e) {
            del(this, this[CACHE].get(e))
        }
        load(e) {
            this.reset();
            const t = Date.now();
            for (let r = e.length - 1; r >= 0; r--) {
                const n = e[r],
                    s = n.e || 0;
                if (0 === s) this.set(n.k, n.v);
                else {
                    const e = s - t;
                    e > 0 && this.set(n.k, n.v, e)
                }
            }
        }
        prune() {
            this[CACHE].forEach(((e, t) => get(this, t, !1)))
        }
    }
    const get = (e, t, r) => {
            const n = e[CACHE].get(t);
            if (n) {
                const t = n.value;
                if (isStale(e, t)) {
                    if (del(e, n), !e[ALLOW_STALE]) return
                } else r && (e[UPDATE_AGE_ON_GET] && (n.value.now = Date.now()), e[LRU_LIST].unshiftNode(n));
                return t.value
            }
        },
        isStale = (e, t) => {
            if (!t || !t.maxAge && !e[MAX_AGE]) return !1;
            const r = Date.now() - t.now;
            return t.maxAge ? r > t.maxAge : e[MAX_AGE] && r > e[MAX_AGE]
        },
        trim = e => {
            if (e[LENGTH] > e[MAX])
                for (let t = e[LRU_LIST].tail; e[LENGTH] > e[MAX] && null !== t;) {
                    const r = t.prev;
                    del(e, t), t = r
                }
        },
        del = (e, t) => {
            if (t) {
                const r = t.value;
                e[DISPOSE] && e[DISPOSE](r.key, r.value), e[LENGTH] -= r.length, e[CACHE].delete(r.key), e[LRU_LIST].removeNode(t)
            }
        };
    class Entry {
        constructor(e, t, r, n, s) {
            this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = s || 0
        }
    }
    const forEachStep = (e, t, r, n) => {
        let s = r.value;
        isStale(e, s) && (del(e, r), e[ALLOW_STALE] || (s = void 0)), s && t.call(n, s.value, s.key, e)
    };
    var lruCache = LRUCache;
    const opts = ["includePrerelease", "loose", "rtl"],
        parseOptions$3 = e => e ? "object" != typeof e ? {
            loose: !0
        } : opts.filter((t => e[t])).reduce(((e, t) => (e[t] = !0, e)), {}) : {};
    var parseOptions_1 = parseOptions$3,
        re$3 = {
            exports: {}
        };
    const SEMVER_SPEC_VERSION = "2.0.0",
        MAX_LENGTH$1 = 256,
        MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991,
        MAX_SAFE_COMPONENT_LENGTH = 16;
    var constants = {
        SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
        MAX_LENGTH: MAX_LENGTH$1,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
        MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
    };
    const debug$3 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {};
    var debug_1 = debug$3;
    ! function(e, t) {
        const {
            MAX_SAFE_COMPONENT_LENGTH: r
        } = constants, n = debug_1, s = (t = e.exports = {}).re = [], i = t.src = [], a = t.t = {};
        let o = 0;
        const l = (e, t, r) => {
            const l = o++;
            n(l, t), a[e] = l, i[l] = t, s[l] = new RegExp(t, r ? "g" : void 0)
        };
        l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${i[a.NUMERICIDENTIFIER]})\\.(${i[a.NUMERICIDENTIFIER]})\\.(${i[a.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${i[a.NUMERICIDENTIFIERLOOSE]})\\.(${i[a.NUMERICIDENTIFIERLOOSE]})\\.(${i[a.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${i[a.NUMERICIDENTIFIER]}|${i[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${i[a.NUMERICIDENTIFIERLOOSE]}|${i[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${i[a.PRERELEASEIDENTIFIER]}(?:\\.${i[a.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${i[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[a.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${i[a.BUILDIDENTIFIER]}(?:\\.${i[a.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${i[a.MAINVERSION]}${i[a.PRERELEASE]}?${i[a.BUILD]}?`), l("FULL", `^${i[a.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${i[a.MAINVERSIONLOOSE]}${i[a.PRERELEASELOOSE]}?${i[a.BUILD]}?`), l("LOOSE", `^${i[a.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${i[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${i[a.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${i[a.XRANGEIDENTIFIER]})(?:\\.(${i[a.XRANGEIDENTIFIER]})(?:\\.(${i[a.XRANGEIDENTIFIER]})(?:${i[a.PRERELEASE]})?${i[a.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${i[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[a.XRANGEIDENTIFIERLOOSE]})(?:${i[a.PRERELEASELOOSE]})?${i[a.BUILD]}?)?)?`), l("XRANGE", `^${i[a.GTLT]}\\s*${i[a.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${i[a.GTLT]}\\s*${i[a.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), l("COERCERTL", i[a.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${i[a.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${i[a.LONETILDE]}${i[a.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${i[a.LONETILDE]}${i[a.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${i[a.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${i[a.LONECARET]}${i[a.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${i[a.LONECARET]}${i[a.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${i[a.GTLT]}\\s*(${i[a.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${i[a.GTLT]}\\s*(${i[a.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${i[a.GTLT]}\\s*(${i[a.LOOSEPLAIN]}|${i[a.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${i[a.XRANGEPLAIN]})\\s+-\\s+(${i[a.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${i[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[a.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$")
    }(re$3, re$3.exports);
    const numeric = /^[0-9]+$/,
        compareIdentifiers$1 = (e, t) => {
            const r = numeric.test(e),
                n = numeric.test(t);
            return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
        },
        rcompareIdentifiers = (e, t) => compareIdentifiers$1(t, e);
    var identifiers = {
        compareIdentifiers: compareIdentifiers$1,
        rcompareIdentifiers: rcompareIdentifiers
    };
    const debug$2 = debug_1,
        {
            MAX_LENGTH: MAX_LENGTH,
            MAX_SAFE_INTEGER: MAX_SAFE_INTEGER
        } = constants,
        {
            re: re$2,
            t: t$2
        } = re$3.exports,
        parseOptions$2 = parseOptions_1,
        {
            compareIdentifiers: compareIdentifiers
        } = identifiers;
    class SemVer$3 {
        constructor(e, t) {
            if (t = parseOptions$2(t), e instanceof SemVer$3) {
                if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e;
                e = e.version
            } else if ("string" != typeof e) throw new TypeError(`Invalid Version: ${e}`);
            if (e.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
            debug$2("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
            const r = e.trim().match(t.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
            if (!r) throw new TypeError(`Invalid Version: ${e}`);
            if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
            r[4] ? this.prerelease = r[4].split(".").map((e => {
                if (/^[0-9]+$/.test(e)) {
                    const t = +e;
                    if (t >= 0 && t < MAX_SAFE_INTEGER) return t
                }
                return e
            })) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format()
        }
        format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
        }
        toString() {
            return this.version
        }
        compare(e) {
            if (debug$2("SemVer.compare", this.version, this.options, e), !(e instanceof SemVer$3)) {
                if ("string" == typeof e && e === this.version) return 0;
                e = new SemVer$3(e, this.options)
            }
            return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e)
        }
        compareMain(e) {
            return e instanceof SemVer$3 || (e = new SemVer$3(e, this.options)), compareIdentifiers(this.major, e.major) || compareIdentifiers(this.minor, e.minor) || compareIdentifiers(this.patch, e.patch)
        }
        comparePre(e) {
            if (e instanceof SemVer$3 || (e = new SemVer$3(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
            if (!this.prerelease.length && e.prerelease.length) return 1;
            if (!this.prerelease.length && !e.prerelease.length) return 0;
            let t = 0;
            do {
                const r = this.prerelease[t],
                    n = e.prerelease[t];
                if (debug$2("prerelease compare", t, r, n), void 0 === r && void 0 === n) return 0;
                if (void 0 === n) return 1;
                if (void 0 === r) return -1;
                if (r !== n) return compareIdentifiers(r, n)
            } while (++t)
        }
        compareBuild(e) {
            e instanceof SemVer$3 || (e = new SemVer$3(e, this.options));
            let t = 0;
            do {
                const r = this.build[t],
                    n = e.build[t];
                if (debug$2("prerelease compare", t, r, n), void 0 === r && void 0 === n) return 0;
                if (void 0 === n) return 1;
                if (void 0 === r) return -1;
                if (r !== n) return compareIdentifiers(r, n)
            } while (++t)
        }
        inc(e, t) {
            switch (e) {
                case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                    break;
                case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                    break;
                case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                    break;
                case "prerelease":
                    0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                    break;
                case "major":
                    0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                case "minor":
                    0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                case "patch":
                    0 === this.prerelease.length && this.patch++, this.prerelease = [];
                    break;
                case "pre":
                    if (0 === this.prerelease.length) this.prerelease = [0];
                    else {
                        let e = this.prerelease.length;
                        for (; --e >= 0;) "number" == typeof this.prerelease[e] && (this.prerelease[e]++, e = -2); - 1 === e && this.prerelease.push(0)
                    }
                    t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                    break;
                default:
                    throw new Error(`invalid increment argument: ${e}`)
            }
            return this.format(), this.raw = this.version, this
        }
    }
    var semver = SemVer$3;
    const SemVer$2 = semver,
        compare$6 = (e, t, r) => new SemVer$2(e, r).compare(new SemVer$2(t, r));
    var compare_1 = compare$6;
    const compare$5 = compare_1,
        eq$1 = (e, t, r) => 0 === compare$5(e, t, r);
    var eq_1 = eq$1;
    const compare$4 = compare_1,
        neq$1 = (e, t, r) => 0 !== compare$4(e, t, r);
    var neq_1 = neq$1;
    const compare$3 = compare_1,
        gt$1 = (e, t, r) => compare$3(e, t, r) > 0;
    var gt_1 = gt$1;
    const compare$2 = compare_1,
        gte$1 = (e, t, r) => compare$2(e, t, r) >= 0;
    var gte_1 = gte$1;
    const compare$1 = compare_1,
        lt$1 = (e, t, r) => compare$1(e, t, r) < 0;
    var lt_1 = lt$1;
    const compare = compare_1,
        lte$1 = (e, t, r) => compare(e, t, r) <= 0;
    var lte_1 = lte$1;
    const eq = eq_1,
        neq = neq_1,
        gt = gt_1,
        gte = gte_1,
        lt = lt_1,
        lte = lte_1,
        cmp$1 = (e, t, r, n) => {
            switch (t) {
                case "===":
                    return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e === r;
                case "!==":
                    return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e !== r;
                case "":
                case "=":
                case "==":
                    return eq(e, r, n);
                case "!=":
                    return neq(e, r, n);
                case ">":
                    return gt(e, r, n);
                case ">=":
                    return gte(e, r, n);
                case "<":
                    return lt(e, r, n);
                case "<=":
                    return lte(e, r, n);
                default:
                    throw new TypeError(`Invalid operator: ${t}`)
            }
        };
    var cmp_1 = cmp$1;
    const ANY = Symbol("SemVer ANY");
    class Comparator$1 {
        static get ANY() {
            return ANY
        }
        constructor(e, t) {
            if (t = parseOptions$1(t), e instanceof Comparator$1) {
                if (e.loose === !!t.loose) return e;
                e = e.value
            }
            debug$1("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug$1("comp", this)
        }
        parse(e) {
            const t = this.options.loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR],
                r = e.match(t);
            if (!r) throw new TypeError(`Invalid comparator: ${e}`);
            this.operator = void 0 !== r[1] ? r[1] : "", "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new SemVer$1(r[2], this.options.loose) : this.semver = ANY
        }
        toString() {
            return this.value
        }
        test(e) {
            if (debug$1("Comparator.test", e, this.options.loose), this.semver === ANY || e === ANY) return !0;
            if ("string" == typeof e) try {
                e = new SemVer$1(e, this.options)
            } catch (e) {
                return !1
            }
            return cmp(e, this.operator, this.semver, this.options)
        }
        intersects(e, t) {
            if (!(e instanceof Comparator$1)) throw new TypeError("a Comparator is required");
            if (t && "object" == typeof t || (t = {
                    loose: !!t,
                    includePrerelease: !1
                }), "" === this.operator) return "" === this.value || new Range$2(e.value, t).test(this.value);
            if ("" === e.operator) return "" === e.value || new Range$2(this.value, t).test(e.semver);
            const r = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
                n = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
                s = this.semver.version === e.semver.version,
                i = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
                a = cmp(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
                o = cmp(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
            return r || n || s && i || a || o
        }
    }
    var comparator = Comparator$1;
    const parseOptions$1 = parseOptions_1,
        {
            re: re$1,
            t: t$1
        } = re$3.exports,
        cmp = cmp_1,
        debug$1 = debug_1,
        SemVer$1 = semver,
        Range$2 = range;
    class Range$1 {
        constructor(e, t) {
            if (t = parseOptions(t), e instanceof Range$1) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new Range$1(e.raw, t);
            if (e instanceof Comparator) return this.raw = e.value, this.set = [
                [e]
            ], this.format(), this;
            if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((e => this.parseRange(e.trim()))).filter((e => e.length)), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${e}`);
            if (this.set.length > 1) {
                const e = this.set[0];
                if (this.set = this.set.filter((e => !isNullSet(e[0]))), 0 === this.set.length) this.set = [e];
                else if (this.set.length > 1)
                    for (const e of this.set)
                        if (1 === e.length && isAny(e[0])) {
                            this.set = [e];
                            break
                        }
            }
            this.format()
        }
        format() {
            return this.range = this.set.map((e => e.join(" ").trim())).join("||").trim(), this.range
        }
        toString() {
            return this.range
        }
        parseRange(e) {
            e = e.trim();
            const r = `parseRange:${Object.keys(this.options).join(",")}:${e}`,
                n = cache.get(r);
            if (n) return n;
            const s = this.options.loose,
                i = s ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
            e = e.replace(i, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", e), e = e.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", e, re[t.COMPARATORTRIM]), e = (e = (e = e.replace(re[t.TILDETRIM], tildeTrimReplace)).replace(re[t.CARETTRIM], caretTrimReplace)).split(/\s+/).join(" ");
            const a = s ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR],
                o = e.split(" ").map((e => parseComparator(e, this.options))).join(" ").split(/\s+/).map((e => replaceGTE0(e, this.options))).filter(this.options.loose ? e => !!e.match(a) : () => !0).map((e => new Comparator(e, this.options)));
            o.length;
            const l = new Map;
            for (const e of o) {
                if (isNullSet(e)) return [e];
                l.set(e.value, e)
            }
            l.size > 1 && l.has("") && l.delete("");
            const c = [...l.values()];
            return cache.set(r, c), c
        }
        intersects(e, t) {
            if (!(e instanceof Range$1)) throw new TypeError("a Range is required");
            return this.set.some((r => isSatisfiable(r, t) && e.set.some((e => isSatisfiable(e, t) && r.every((r => e.every((e => r.intersects(e, t)))))))))
        }
        test(e) {
            if (!e) return !1;
            if ("string" == typeof e) try {
                e = new SemVer(e, this.options)
            } catch (e) {
                return !1
            }
            for (let t = 0; t < this.set.length; t++)
                if (testSet(this.set[t], e, this.options)) return !0;
            return !1
        }
    }
    var range = Range$1;
    const LRU = lruCache,
        cache = new LRU({
            max: 1e3
        }),
        parseOptions = parseOptions_1,
        Comparator = comparator,
        debug = debug_1,
        SemVer = semver,
        {
            re: re,
            t: t,
            comparatorTrimReplace: comparatorTrimReplace,
            tildeTrimReplace: tildeTrimReplace,
            caretTrimReplace: caretTrimReplace
        } = re$3.exports,
        isNullSet = e => "<0.0.0-0" === e.value,
        isAny = e => "" === e.value,
        isSatisfiable = (e, t) => {
            let r = !0;
            const n = e.slice();
            let s = n.pop();
            for (; r && n.length;) r = n.every((e => s.intersects(e, t))), s = n.pop();
            return r
        },
        parseComparator = (e, t) => (debug("comp", e, t), e = replaceCarets(e, t), debug("caret", e), e = replaceTildes(e, t), debug("tildes", e), e = replaceXRanges(e, t), debug("xrange", e), e = replaceStars(e, t), debug("stars", e), e),
        isX = e => !e || "x" === e.toLowerCase() || "*" === e,
        replaceTildes = (e, t) => e.trim().split(/\s+/).map((e => replaceTilde(e, t))).join(" "),
        replaceTilde = (e, r) => {
            const n = r.loose ? re[t.TILDELOOSE] : re[t.TILDE];
            return e.replace(n, ((t, r, n, s, i) => {
                let a;
                return debug("tilde", e, t, r, n, s, i), isX(r) ? a = "" : isX(n) ? a = `>=${r}.0.0 <${+r+1}.0.0-0` : isX(s) ? a = `>=${r}.${n}.0 <${r}.${+n+1}.0-0` : i ? (debug("replaceTilde pr", i), a = `>=${r}.${n}.${s}-${i} <${r}.${+n+1}.0-0`) : a = `>=${r}.${n}.${s} <${r}.${+n+1}.0-0`, debug("tilde return", a), a
            }))
        },
        replaceCarets = (e, t) => e.trim().split(/\s+/).map((e => replaceCaret(e, t))).join(" "),
        replaceCaret = (e, r) => {
            debug("caret", e, r);
            const n = r.loose ? re[t.CARETLOOSE] : re[t.CARET],
                s = r.includePrerelease ? "-0" : "";
            return e.replace(n, ((t, r, n, i, a) => {
                let o;
                return debug("caret", e, t, r, n, i, a), isX(r) ? o = "" : isX(n) ? o = `>=${r}.0.0${s} <${+r+1}.0.0-0` : isX(i) ? o = "0" === r ? `>=${r}.${n}.0${s} <${r}.${+n+1}.0-0` : `>=${r}.${n}.0${s} <${+r+1}.0.0-0` : a ? (debug("replaceCaret pr", a), o = "0" === r ? "0" === n ? `>=${r}.${n}.${i}-${a} <${r}.${n}.${+i+1}-0` : `>=${r}.${n}.${i}-${a} <${r}.${+n+1}.0-0` : `>=${r}.${n}.${i}-${a} <${+r+1}.0.0-0`) : (debug("no pr"), o = "0" === r ? "0" === n ? `>=${r}.${n}.${i}${s} <${r}.${n}.${+i+1}-0` : `>=${r}.${n}.${i}${s} <${r}.${+n+1}.0-0` : `>=${r}.${n}.${i} <${+r+1}.0.0-0`), debug("caret return", o), o
            }))
        },
        replaceXRanges = (e, t) => (debug("replaceXRanges", e, t), e.split(/\s+/).map((e => replaceXRange(e, t))).join(" ")),
        replaceXRange = (e, r) => {
            e = e.trim();
            const n = r.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
            return e.replace(n, ((t, n, s, i, a, o) => {
                debug("xRange", e, t, n, s, i, a, o);
                const l = isX(s),
                    c = l || isX(i),
                    h = c || isX(a),
                    u = h;
                return "=" === n && u && (n = ""), o = r.includePrerelease ? "-0" : "", l ? t = ">" === n || "<" === n ? "<0.0.0-0" : "*" : n && u ? (c && (i = 0), a = 0, ">" === n ? (n = ">=", c ? (s = +s + 1, i = 0, a = 0) : (i = +i + 1, a = 0)) : "<=" === n && (n = "<", c ? s = +s + 1 : i = +i + 1), "<" === n && (o = "-0"), t = `${n+s}.${i}.${a}${o}`) : c ? t = `>=${s}.0.0${o} <${+s+1}.0.0-0` : h && (t = `>=${s}.${i}.0${o} <${s}.${+i+1}.0-0`), debug("xRange return", t), t
            }))
        },
        replaceStars = (e, r) => (debug("replaceStars", e, r), e.trim().replace(re[t.STAR], "")),
        replaceGTE0 = (e, r) => (debug("replaceGTE0", e, r), e.trim().replace(re[r.includePrerelease ? t.GTE0PRE : t.GTE0], "")),
        hyphenReplace = e => (t, r, n, s, i, a, o, l, c, h, u, d, f) => `${r=isX(n)?"":isX(s)?`>=${n}.0.0${e?"-0":""}`:isX(i)?`>=${n}.${s}.0${e?"-0":""}`:a?`>=${r}`:`>=${r}${e?"-0":""}`} ${l=isX(c)?"":isX(h)?`<${+c+1}.0.0-0`:isX(u)?`<${c}.${+h+1}.0-0`:d?`<=${c}.${h}.${u}-${d}`:e?`<${c}.${h}.${+u+1}-0`:`<=${l}`}`.trim(),
        testSet = (e, t, r) => {
            for (let r = 0; r < e.length; r++)
                if (!e[r].test(t)) return !1;
            if (t.prerelease.length && !r.includePrerelease) {
                for (let r = 0; r < e.length; r++)
                    if (debug(e[r].semver), e[r].semver !== Comparator.ANY && e[r].semver.prerelease.length > 0) {
                        const n = e[r].semver;
                        if (n.major === t.major && n.minor === t.minor && n.patch === t.patch) return !0
                    } return !1
            }
            return !0
        },
        Range = range,
        satisfies = (e, t, r) => {
            try {
                t = new Range(t, r)
            } catch (e) {
                return !1
            }
            return t.test(e)
        };
    var satisfies_1 = satisfies;

    function buf2hex(e) {
        return [...e].map((e => e.toString(16).padStart(2, "0"))).join("")
    }

    function contains$1(e, t) {
        for (let r = 0; r < e.length; r += 1)
            if (e[r] === t) return !0;
        return !1
    }
    class ValidationError$1 extends Error {
        constructor(e = "") {
            super(e), this.name = "ValidationError"
        }
    }
    const baseSize = 45,
        baseSizeSquared = 2025,
        chunkSize = 2,
        encodedChunkSize = 3,
        byteSize = 256,
        encoding = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
    let decoding;

    function decode$2(e) {
        if (null == e) throw new Error("utf8StringArg is null or undefined.");
        if (0 === e.length) return [];
        const t = e.length % encodedChunkSize;
        if (1 === t) throw new Error("utf8StringArg has incorrect length.");
        if (void 0 === decoding) {
            decoding = {};
            for (let e = 0; e < encoding.length; e += 1) decoding[encoding[e]] = e
        }
        const r = new Array(e.length);
        for (let t = 0; t < e.length; t += 1) {
            const n = decoding[e[t]];
            if (void 0 === n) throw new Error("invalid character at position ".concat(t).concat("."));
            r[t] = n
        }
        const n = Math.trunc(r.length / encodedChunkSize),
            s = new Uint8Array(n * chunkSize + (t === chunkSize ? 1 : 0));
        let i = 0;
        const a = n * encodedChunkSize;
        for (let e = 0; e < a;) {
            let t = r[e];
            e += 1, t += baseSize * r[e], e += 1, t += baseSizeSquared * r[e], e += 1, s[i] = Math.trunc(t / byteSize), i += 1, s[i] = t % byteSize, i += 1
        }
        return 0 === t || (s[s.length - 1] = r[r.length - 2] + baseSize * r[r.length - 1]), s
    }
    const POW_2_24 = 5.960464477539063e-8,
        POW_2_32 = 4294967296,
        POW_2_53 = 9007199254740992;

    function encode(e) {
        let t, r = new ArrayBuffer(256),
            n = new DataView(r),
            s = 0;

        function i(e) {
            let i = r.byteLength;
            const a = s + e;
            for (; i < a;) i <<= 1;
            if (i !== r.byteLength) {
                const e = n;
                r = new ArrayBuffer(i), n = new DataView(r);
                const t = s + 3 >> 2;
                for (let r = 0; r < t; r += 1) n.setUint32(r << 2, e.getUint32(r << 2))
            }
            return t = e, n
        }

        function a() {
            s += t
        }

        function o(e) {
            i(1).setUint8(s, e), a()
        }

        function l(e) {
            const t = i(e.length);
            for (let r = 0; r < e.length; r += 1) t.setUint8(s + r, e[r]);
            a()
        }

        function c(e, t) {
            var r;
            t < 24 ? o(e << 5 | t) : t < 256 ? (o(e << 5 | 24), o(t)) : t < 65536 ? (o(e << 5 | 25), r = t, i(2).setUint16(s, r), a()) : t < 4294967296 ? (o(e << 5 | 26), function(e) {
                i(4).setUint32(s, e), a()
            }(t)) : (o(e << 5 | 27), function(e) {
                const t = e % POW_2_32,
                    r = (e - t) / POW_2_32,
                    n = i(8);
                n.setUint32(s, r), n.setUint32(s + 4, t), a()
            }(t))
        }
        if (function e(t) {
                if (!1 === t) return void o(244);
                if (!0 === t) return void o(245);
                if (null === t) return void o(246);
                if (void 0 === t) return void o(247);
                let r;
                const n = [];
                switch (typeof t) {
                    case "number":
                        if (Math.floor(t) === t) {
                            if (t >= 0 && t <= POW_2_53) {
                                c(0, t);
                                break
                            }
                            if (-POW_2_53 <= t && t < 0) {
                                c(1, -(t + 1));
                                break
                            }
                        }
                        o(251),
                            function(e) {
                                i(8).setFloat64(s, e), a()
                            }(t);
                        break;
                    case "string":
                        for (let e = 0; e < t.length; e += 1) {
                            let r = t.charCodeAt(e);
                            r < 128 ? n.push(r) : r < 2048 ? (n.push(192 | r >> 6), n.push(128 | 63 & r)) : r < 55296 ? (n.push(224 | r >> 12), n.push(128 | r >> 6 & 63), n.push(128 | 63 & r)) : (r = (1023 & r) << 10, r |= 1023 & t.charCodeAt(e += 1), r += 65536, n.push(240 | r >> 18), n.push(128 | r >> 12 & 63), n.push(128 | r >> 6 & 63), n.push(128 | 63 & r))
                        }
                        c(3, n.length), l(n);
                        break;
                    default:
                        if (Array.isArray(t)) {
                            r = t.length, c(4, r);
                            for (let n = 0; n < r; n += 1) e(t[n])
                        } else if (t instanceof Uint8Array) c(2, t.length), l(t);
                        else {
                            const n = Object.keys(t);
                            r = n.length, c(5, r);
                            for (let s = 0; s < r; s += 1) {
                                const r = n[s];
                                e(r), e(t[r])
                            }
                        }
                }
            }(e), "slice" in r) return r.slice(0, s);
        const h = new ArrayBuffer(s),
            u = new DataView(h);
        for (let e = 0; e < s; e += 1) u.setUint8(e, n.getUint8(e));
        return h
    }

    function decode$1(e, t = (e => e), r = (() => {})) {
        const n = new DataView(e);
        let s = 0;

        function i(e, t) {
            return s += e, t
        }

        function a(t) {
            return i(t, new Uint8Array(e, s, t))
        }

        function o() {
            return i(1, n.getUint8(s))
        }

        function l() {
            return i(2, n.getUint16(s))
        }

        function c() {
            return i(4, n.getUint32(s))
        }

        function h() {
            return 255 === n.getUint8(s) && (s += 1, !0)
        }

        function u(e) {
            if (e < 24) return e;
            if (24 === e) return o();
            if (25 === e) return l();
            if (26 === e) return c();
            if (27 === e) return c() * POW_2_32 + c();
            if (31 === e) return -1;
            throw new Error("invalid length encoding")
        }

        function d(e) {
            const t = o();
            if (255 === t) return -1;
            const r = u(31 & t);
            if (r < 0 || t >> 5 !== e) throw new Error("invalid indefinite length element");
            return r
        }

        function f(e, t) {
            for (let r = 0, n = t; r < n; r += 1) {
                let t = o();
                128 & t && (t < 224 ? (t = (31 & t) << 6 | 63 & o(), n -= 1) : t < 240 ? (t = (15 & t) << 12 | (63 & o()) << 6 | 63 & o(), n -= 2) : (t = (15 & t) << 18 | (63 & o()) << 12 | (63 & o()) << 6 | 63 & o(), n -= 3)), t < 65536 ? e.push(t) : (t -= 65536, e.push(55296 | t >> 10), e.push(56320 | 1023 & t))
            }
        }
        const p = function e() {
            const c = o(),
                p = c >> 5,
                _ = 31 & c;
            let g, m;
            if (7 === p) switch (_) {
                case 25:
                    return function() {
                        const e = new ArrayBuffer(4),
                            t = new DataView(e),
                            r = l(),
                            n = 32768 & r;
                        let s = 31744 & r;
                        const i = 1023 & r;
                        if (31744 === s) s = 261120;
                        else if (0 !== s) s += 114688;
                        else if (0 !== i) return (n ? -1 : 1) * i * POW_2_24;
                        return t.setUint32(0, n << 16 | s << 13 | i << 13), t.getFloat32(0)
                    }();
                case 26:
                    return i(4, n.getFloat32(s));
                case 27:
                    return i(8, n.getFloat64(s))
            }
            if (m = u(_), m < 0 && (p < 2 || p > 6)) throw new Error("invalid length");
            const A = [];
            let y;
            const b = {};
            switch (p) {
                case 0:
                    return m;
                case 1:
                    return -1 - m;
                case 2:
                    if (m < 0) {
                        const e = [];
                        let t = 0;
                        for (;
                            (m = d(p)) >= 0;) t += m, e.push(a(m));
                        const r = new Uint8Array(t);
                        let n = 0;
                        for (g = 0; g < e.length; g += 1) r.set(e[g], n), n += e[g].length;
                        return r
                    }
                    return a(m);
                case 3:
                    if (m < 0)
                        for (;
                            (m = d(p)) >= 0;) f(A, m);
                    else f(A, m);
                    return String.fromCharCode.apply(null, A);
                case 4:
                    if (m < 0)
                        for (y = []; !h();) y.push(e());
                    else
                        for (y = new Array(m), g = 0; g < m; g += 1) y[g] = e();
                    return y;
                case 5:
                    for (g = 0; g < m || m < 0 && !h(); g += 1) {
                        b[e()] = e()
                    }
                    return b;
                case 6:
                    return t(e(), m);
                case 7:
                    switch (m) {
                        case 20:
                            return !1;
                        case 21:
                            return !0;
                        case 22:
                            return null;
                        case 23:
                            return;
                        default:
                            return r(m)
                    }
            }
            return null
        }();
        if (s !== e.byteLength) throw new Error("remaining bytes");
        return p
    }
    const ALGO_ECDSA_256 = -7,
        ALGO_RSA_PSS_256 = -37,
        COSE_KEY_KEYTYPE = 1,
        COSE_HEADER_KID = 4;

    function decode(e) {
        const t = decode$1(new Uint8Array(e).buffer);
        if (null === t || !Array.isArray(t) || 4 !== t.length) throw new Error("invalid sign1 structure");
        let r = t[0];
        if (null === r) throw new Error("invalid sign1 structure");
        let n = {};
        if (r.length > 0 && (n = decode$1(new Uint8Array(r).buffer), null !== n && 0 !== n.length || (r = new Uint8Array)), n[COSE_KEY_KEYTYPE] !== ALGO_ECDSA_256 && n[COSE_KEY_KEYTYPE] !== ALGO_RSA_PSS_256) throw new Error("invalid sign1 algo, expected ECDSA SHA-256 or RSASSA-PSS SHA-256");
        let s = n[COSE_HEADER_KID];
        if (!s) {
            if (null === t[1] && "object" != typeof t[1]) throw new Error("invalid sign1 structure");
            s = t[1][COSE_HEADER_KID]
        }
        if (!s) throw new Error("sign1 message missing KID");
        if (null === t[2] || null === t[3]) throw new Error("invalid sign1 structure");
        return {
            protected: r,
            unprotected: t[1],
            params: {
                kty: n[COSE_KEY_KEYTYPE],
                kid: s
            },
            content: t[2],
            signature: t[3]
        }
    }

    function verifyWithKey(e, t, r, n) {
        return new Promise(((s, i) => {
            if (!n || 0 === n.length) return void i(new ValidationError$1("MISSING_KEY"));
            const a = n[0];
            let o;
            o = "EC" === a.kty ? {
                name: "ECDSA",
                namedCurve: a.crv
            } : {
                name: "RSA-PSS",
                hash: {
                    name: "SHA-256"
                }
            }, window.crypto.subtle.importKey("jwk", a, o, !1, ["verify"]).then((o => {
                window.crypto.subtle.verify(r, o, t, e).then((o => {
                    o || 1 === n.length ? s({
                        valid: o,
                        publicKey: a
                    }) : verifyWithKey(e, t, r, n.slice(1)).then((e => {
                        s(e)
                    })).catch((e => {
                        i(e)
                    }))
                })).catch((a => {
                    if (1 === n.length) return console.warn(a), void i(new ValidationError$1("VERIFY_ERROR"));
                    verifyWithKey(e, t, r, n.slice(1)).then((e => {
                        s(e)
                    })).catch((e => {
                        i(e)
                    }))
                }))
            })).catch((a => {
                if (1 === n.length) return console.warn(a), void i(new ValidationError$1("INVALID_KEY"));
                verifyWithKey(e, t, r, n.slice(1)).then((e => {
                    s(e)
                })).catch((e => {
                    i(e)
                }))
            }))
        }))
    }

    function verify(e, t) {
        let r, n;
        try {
            r = encode(["Signature1", e.protected, new Uint8Array(0), e.content])
        } catch (e) {
            return Promise.reject(e)
        }
        return n = e.params.kty === ALGO_ECDSA_256 ? {
            name: "ECDSA",
            hash: {
                name: "SHA-256"
            }
        } : {
            name: "RSA-PSS",
            saltLength: 32
        }, verifyWithKey(r, e.signature, n, t)
    }
    class ValidationResult {
        constructor(e, t, r = null) {
            this.valid = e, this.content = t, this.reason = r
        }
    }
    const DGC_CERTIFICATE_EXTENSION_TEST_V0 = "1.3.6.1.4.1.0.1847.2021.1.1",
        DGC_CERTIFICATE_EXTENSION_VACCINATION_V0 = "1.3.6.1.4.1.0.1847.2021.1.2",
        DGC_CERTIFICATE_EXTENSION_RECOVERY_V0 = "1.3.6.1.4.1.0.1847.2021.1.3",
        DGC_CERTIFICATE_EXTENSION_TEST_V1 = "1.3.6.1.4.1.1847.2021.1.1",
        DGC_CERTIFICATE_EXTENSION_VACCINATION_V1 = "1.3.6.1.4.1.1847.2021.1.2",
        DGC_CERTIFICATE_EXTENSION_RECOVERY_V1 = "1.3.6.1.4.1.1847.2021.1.3";
    dayjs.extend(utc);
    const uaDobDateFormat$2 = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec$2(e, t) {
        const r = e,
            n = "t" in (r || {}) && Array.isArray(r.t) && r.t.length > 0,
            s = "v" in (r || {}) && Array.isArray(r.v) && r.v.length > 0,
            i = "r" in (r || {}) && Array.isArray(r.r) && r.r.length > 0;
        if (r && r.dob) {
            const e = r.dob.indexOf("T");
            e >= 0 && (r.dob = r.dob.substr(0, e));
            const t = r.dob.match(uaDobDateFormat$2);
            null !== t && 4 === t.length && (r.dob = `${t[3]}-${t[2]}-${t[1]}`)
        }
        if (s) {
            for (let e = 0; e < r.v.length; e += 1) {
                const t = r.v[e];
                if (t.dt) {
                    const e = t.dt.indexOf("T");
                    e >= 0 && (t.dt = t.dt.substr(0, e))
                }
            }
            "t" in r && delete r.t, "r" in r && delete r.r
        }
        if (i) {
            for (let e = 0; e < r.r.length; e += 1) {
                const t = r.r[e];
                if (t.fr) {
                    const e = t.fr.indexOf("T");
                    e >= 0 && (t.fr = t.fr.substr(0, e))
                }
                if (t.df) {
                    const e = t.df.indexOf("T");
                    e >= 0 && (t.df = t.df.substr(0, e))
                }
                if (t.du) {
                    const e = t.du.indexOf("T");
                    e >= 0 && (t.du = t.du.substr(0, e))
                }
            }
            "t" in r && delete r.t, "v" in r && delete r.v
        }
        n && ("r" in r && delete r.r, "v" in r && delete r.v);
        const a = dayjs.utc();
        if (n && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (s && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (i && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (s)
            for (let e = 0; e < r.v.length; e += 1) {
                const t = r.v[e],
                    n = dayjs.utc(t.dt);
                if (!n.isValid() || n.isAfter(a)) return new ValidationResult(!1, r, "DT_IN_FUTURE")
            }
        if (n)
            for (let e = 0; e < r.t.length; e += 1) {
                const t = r.t[e],
                    n = dayjs.utc(t.sc);
                if (!n.isValid() || n.isAfter(a)) return new ValidationResult(!1, r, "SC_IN_FUTURE");
                if (t.dr) {
                    const e = dayjs.utc(t.dr);
                    if (!e.isValid() || e.isAfter(a)) return new ValidationResult(!1, r, "DR_IN_FUTURE")
                }
            }
        if (i)
            for (let e = 0; e < r.r.length; e += 1) {
                const t = r.r[e],
                    n = dayjs.utc(t.fr);
                if (!n.isValid() || n.isAfter(a)) return new ValidationResult(!1, r, "FR_IN_FUTURE");
                if (!dayjs.utc(t.df).isValid()) return new ValidationResult(!1, r, "INVALID_DF");
                if (!dayjs.utc(t.du).isValid()) return new ValidationResult(!1, r, "INVALID_DU")
            }
        if (!r.dob) return new ValidationResult(!1, r, "MISSING_DOB");
        return dayjs.utc(r.dob).isValid() ? new ValidationResult(!0, r) : new ValidationResult(!1, r, "INVALID_DOB")
    }
    dayjs.extend(utc);
    const uaDobDateFormat$1 = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec$1(e, t) {
        const r = e,
            n = dayjs.utc(),
            s = "t" in (r || {}) && Array.isArray(r.t) && r.t.length > 0,
            i = "v" in (r || {}) && Array.isArray(r.v) && r.v.length > 0,
            a = "r" in (r || {}) && Array.isArray(r.r) && r.r.length > 0;
        if (r && r.dob) {
            const e = r.dob.match(uaDobDateFormat$1);
            null !== e && 4 === e.length && (r.dob = `${e[3]}-${e[2]}-${e[1]}`)
        }
        if (s && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (i && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (a && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (i)
            for (let e = 0; e < r.v.length; e += 1) {
                const t = r.v[e],
                    s = dayjs.utc(t.dt);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "DT_IN_FUTURE")
            }
        if (s)
            for (let e = 0; e < r.t.length; e += 1) {
                const t = r.t[e],
                    s = dayjs.utc(t.sc);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "SC_IN_FUTURE")
            }
        if (a)
            for (let e = 0; e < r.r.length; e += 1) {
                const t = r.r[e],
                    s = dayjs.utc(t.fr);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "FR_IN_FUTURE");
                if (!dayjs.utc(t.df).isValid()) return new ValidationResult(!1, r, "INVALID_DF");
                if (!dayjs.utc(t.du).isValid()) return new ValidationResult(!1, r, "INVALID_DU")
            }
        if (!r.dob) return new ValidationResult(!1, r, "MISSING_DOB");
        return dayjs.utc(r.dob).isValid() ? new ValidationResult(!0, r) : new ValidationResult(!1, r, "INVALID_DOB")
    }
    dayjs.extend(utc);
    const uaDobDateFormat = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec(e, t) {
        const r = e,
            n = dayjs.utc(),
            s = "t" in (r || {}) && Array.isArray(r.t) && r.t.length > 0,
            i = "v" in (r || {}) && Array.isArray(r.v) && r.v.length > 0,
            a = "r" in (r || {}) && Array.isArray(r.r) && r.r.length > 0;
        if (r && r.dob) {
            const e = r.dob.match(uaDobDateFormat);
            null !== e && 4 === e.length && (r.dob = `${e[3]}-${e[2]}-${e[1]}`)
        }
        if (s && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (i && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (a && t.extensions && 0 !== t.extensions.length && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) && !contains$1(t.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1)) return new ValidationResult(!1, r, "INVALID_CERT_OID");
        if (i)
            for (let e = 0; e < r.v.length; e += 1) {
                const t = r.v[e],
                    s = dayjs.utc(t.dt);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "DT_IN_FUTURE")
            }
        if (s)
            for (let e = 0; e < r.t.length; e += 1) {
                const t = r.t[e],
                    s = dayjs.utc(t.sc);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "SC_IN_FUTURE")
            }
        if (a)
            for (let e = 0; e < r.r.length; e += 1) {
                const t = r.r[e],
                    s = dayjs.utc(t.fr);
                if (!s.isValid() || s.isAfter(n)) return new ValidationResult(!1, r, "FR_IN_FUTURE");
                if (!dayjs.utc(t.df).isValid()) return new ValidationResult(!1, r, "INVALID_DF");
                if (!dayjs.utc(t.du).isValid()) return new ValidationResult(!1, r, "INVALID_DU")
            }
        if (r.dob) {
            if (!dayjs.utc(r.dob).isValid()) return new ValidationResult(!1, r, "INVALID_DOB")
        }
        return new ValidationResult(!0, r)
    }
    const CWT_KEY_ISS = 1,
        CWT_KEY_EXP = 4,
        CWT_KEY_IAT = 6,
        CWT_KEY_HCERT = -260,
        CWT_SUBKEY_HCERT_EU_DGCv1 = 1;

    function dataValidation(e, t) {
        if (!t) return new ValidationResult(!1, e.certificate, "MISSING_PUBKEY");
        const r = dayjs.utc().unix();
        return r > e.exp ? new ValidationResult(!1, e.certificate, "CERT_EXPIRED") : r < e.iat ? new ValidationResult(!1, e.certificate, "CERT_ISSUED_BEFORE_IAT") : e.iat > t.exp ? new ValidationResult(!1, e.certificate, "CERT_ISSUED_AFTER_EXP") : satisfies_1(e.certificate.ver, ">=1.0.0 <1.2.0") ? validateSpec$2(e.certificate, t) : satisfies_1(e.certificate.ver, "1.2.x") ? validateSpec$1(e.certificate, t) : satisfies_1(e.certificate.ver, "1.3.x") ? validateSpec(e.certificate, t) : (console.warn(`Unsupported certificate version: ${e.certificate.v}`), new ValidationResult(!1, e.certificate, "UNSUPPORTED_VERSION"))
    }

    function validate$1(e, t) {
        return new Promise(((r, n) => {
            e || n(new ValidationError$1("EMPTY_CERTIFICATE"));
            let s = e;
            const i = s.indexOf(":");
            if (i >= 0 && "HC" === s.substr(0, 2)) {
                if ("HC1:" !== s.substr(0, i + 1)) return void n(new ValidationError$1("INVALID_PREFIX"));
                s = s.substr(i + 1)
            }
            let a, o, l;
            try {
                a = decode$2(s)
            } catch (e) {
                return void n(new ValidationError$1("INVALID_BASE45"))
            }
            if (120 === a[0]) try {
                if (o = inflate_1(a), !o || 0 === o.byteLength) return void n(new ValidationError$1("INVALID_ZLIB_COMPRESSION"))
            } catch (e) {
                return console.warn(e), void n(new ValidationError$1("INVALID_ZLIB_COMPRESSION"))
            } else o = a;
            try {
                l = decode(o)
            } catch (e) {
                return console.warn(e), void n(new ValidationError$1("INVALID_COSE"))
            }
            t(buf2hex(l.params.kid)).then((e => {
                verify(l, e).then((e => {
                    if (!e.valid) return void n(new ValidationError$1("INVALID_SIGNATURE"));
                    let t;
                    try {
                        t = decode$1(new Uint8Array(l.content).buffer)
                    } catch (e) {
                        return console.warn(e), void n(new ValidationError$1("INVALID_CBOR"))
                    }
                    if (null !== t && CWT_KEY_HCERT in t && CWT_SUBKEY_HCERT_EU_DGCv1 in t[CWT_KEY_HCERT]) try {
                        r(dataValidation({
                            iss: t[CWT_KEY_ISS],
                            iat: t[CWT_KEY_IAT],
                            exp: t[CWT_KEY_EXP],
                            certificate: t[CWT_KEY_HCERT][CWT_SUBKEY_HCERT_EU_DGCv1]
                        }, e.publicKey))
                    } catch (e) {
                        n(e)
                    } else n(new ValidationError$1("NOT_HCERT"))
                })).catch((e => {
                    n(new ValidationError$1(e.message))
                }))
            })).catch((e => {
                n(e)
            }))
        }))
    }
    dayjs.extend(utc);
    const baseUrl = window.baseUrl || "/",
        lang = window.language || "lv",
        verifyKeyCacheTime = 21600,
        valuesetCacheTime = 21600,
        rulesCacheTime = 3600;
    QrScanner.WORKER_PATH = baseUrl + "qr-scanner-worker.min.js", pdf_1.GlobalWorkerOptions.workerSrc = baseUrl + "pdf.worker.min.js", dayjs.extend(utc);
    const localStorageEx = {
            get: function(e) {
                const t = window.localStorage.getItem(e);
                if (null !== t) {
                    let r = {
                        payload: null
                    };
                    try {
                        r = JSON.parse(lzString.exports.decompressFromUTF16(t))
                    } catch (e) {
                        return null
                    }
                    if (null != r.payload && null != r.expiry) {
                        if (new Date > Date.parse(r.expiry)) return window.localStorage.removeItem(e), null
                    }
                    return r.payload
                }
                return null
            },
            set: function(e, t, r) {
                if (null === t) return void window.localStorage.removeItem(e);
                const n = new Date;
                n.setSeconds(n.getSeconds() + r), window.localStorage.setItem(e, lzString.exports.compressToUTF16(JSON.stringify({
                    payload: t,
                    expiry: n
                })))
            }
        },
        codeProcessing = {};
    var verificationKeys = localStorageEx.get("verificationKeys") || {},
        devliceList = null,
        rules = localStorageEx.get("rules") || null,
        valueset = localStorageEx.get("valueset") || null,
        selectedRole = null,
        selectedCamera = null,
        qrScanner = null;

    function loadRules() {
        return new Promise((function(e, t) {
            null !== rules ? e(rules) : $.ajax({
                url: baseUrl + "verify/rules.json",
                type: "GET"
            }).done((function(t) {
                rules = t, localStorageEx.set("rules", rules, rulesCacheTime), e(rules)
            })).fail((function() {
                t(new Error("can not load rules"))
            }))
        }))
    }

    function loadValueset() {
        return new Promise((function(e, t) {
            null !== valueset ? e(valueset) : $.ajax({
                url: baseUrl + "verify/valueset",
                type: "GET"
            }).done((function(t) {
                valueset = t, localStorageEx.set("valueset", valueset, valuesetCacheTime), e(valueset)
            })).fail((function() {
                t(new Error("can not load valueset"))
            }))
        }))
    }

    function isEmpty(e) {
        for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
        return !0
    }

    function contains(e, t) {
        for (let r = 0; r < e.length; r += 1)
            if (e[r] === t) return !0;
        return !1
    }

    function preloadKeys() {
        return new Promise((function(e) {
            isEmpty(verificationKeys) ? $.ajax({
                url: baseUrl + "verify/keys",
                type: "GET"
            }).done((function(t) {
                verificationKeys = t, localStorageEx.set("verificationKeys", verificationKeys, verifyKeyCacheTime), e()
            })).fail((function() {
                console.warn("key preload failed")
            })) : e()
        }))
    }

    function getActiveRoles() {
        return new Promise((function(e, t) {
            loadRules().then((function(t) {
                e(getRoles(t, lang))
            })).catch((function(e) {
                t(e)
            }))
        }))
    }

    function fillValues(e, t) {
        if (3 === e.nodeType)
            for (let r in t) {
                const n = e.data.replace(new RegExp("{{" + r + "}}", "g"), t[r]);
                n != e.data && (e.data = n)
            } else if (1 === e.nodeType)
                for (let r = 0; r < e.childNodes.length; r++) fillValues(e.childNodes[r], t)
    }

    function templateRepeat(e, t) {
        const r = e.cloneNode(!0);
        return r.id = "", r.style.display = "block", t.parentNode.insertBefore(r, t.nextSibling), r
    }

    function renderRoleList(e, t, r) {
        return new Promise((function(n, s) {
            getActiveRoles().then((function(s) {
                for (var i = s.length - 1; i >= 0; i -= 1) {
                    const n = templateRepeat(e, t);
                    fillValues(n, {
                        roleName: s[i].businessDescription
                    }), n.dataset.code = s[i].code, n.dataset.displayname = s[i].businessDescription, r && n.addEventListener("click", r)
                }
                n()
            })).catch((function(e) {
                s(e)
            }))
        }))
    }

    function selectRole(e) {
        selectedRole = e
    }

    function keyProvider(e) {
        return new Promise((function(t, r) {
            e in verificationKeys ? t(verificationKeys[e]) : $.ajax({
                url: baseUrl + "verify/key?kid=" + e,
                type: "GET"
            }).done((function(r) {
                verificationKeys[e] = r, localStorageEx.set("verificationKeys", verificationKeys, verifyKeyCacheTime), t(r)
            })).fail((function(e) {
                404 !== e.status ? r(new Error("error while requesting validation key: " + e.statusText)) : r(new ValidationError("UNKNOWN_SIGNING_KEY"))
            }))
        }))
    }
    class ValidationError extends Error {
        constructor(e) {
            super(e), this.name = "ValidationError"
        }
    }

    function validate(e) {
        return new Promise((function(t, r) {
            e in codeProcessing ? r(new Error("ALREADY_IN_PROGRESS")) : (codeProcessing[e] = !0, validate$1(e, keyProvider).then((function(n) {
                if (!n.valid) return t({
                    valid: !1,
                    reason: "INVALID_CODE"
                }), void delete codeProcessing[e];
                loadValueset().then((function(s) {
                    const i = (n.content.v || [{}])[0].ci || (n.content.r || [{}])[0].ci || (n.content.t || [{}])[0].ci;
                    if (i && Array.isArray(s.certificateDenyList) && contains(s.certificateDenyList, i)) return t({
                        valid: !1,
                        reason: "INVALID_BUSINESS",
                        reasonDetails: "CERTIFICATE_CANCELED",
                        reasonDescription: "Sertifikāts ir anulēts",
                        content: n.content
                    }), void delete codeProcessing[e];
                    loadRules().then((function(s) {
                        try {
                            const e = validate$2(n.content, [selectedRole], s, lang);
                            t({
                                valid: e.valid,
                                reason: e.valid ? null : "INVALID_BUSINESS",
                                reasonDetails: e.valid ? null : e.reason,
                                reasonDescription: e.valid ? null : e.reasonBusinessDescription,
                                content: n.content
                            })
                        } catch (e) {
                            r(e)
                        }
                        delete codeProcessing[e]
                    })).catch((function(t) {
                        r(t), delete codeProcessing[e]
                    }))
                })).catch((function(t) {
                    r(t), delete codeProcessing[e]
                }))
            })).catch((function(n) {
                if ("ValidationError" === (n || {}).name) return t({
                    valid: !1,
                    reason: "UNKNOWN_SIGNING_KEY" === n.message ? "UNKNOWN_SIGNING_KEY" : "NOT_HCERT"
                }), void delete codeProcessing[e];
                r(n), delete codeProcessing[e]
            })))
        }))
    }

    function fillCertificateDetails(e, t) {
        e.querySelector(".data .person-name").innerText = ((t.nam.gn || "") + " " + (t.nam.fn || "")).trim();
        let r = t.dob ? dayjs.utc(t.dob) : null;
        r = t.dob && null !== r && r.isValid() ? 4 === t.dob.length ? r.format("YYYY.") : 7 === t.dob.length ? r.format("MM.YYYY.") : r.format("DD.MM.YYYY.") : "-", e.querySelector(".data .person-birth").innerText = r, e.querySelector(".data .certificate-type-v").style.display = "v" in t && t.v.length > 0 ? "block" : "none", e.querySelector(".data .certificate-type-r").style.display = "r" in t && t.r.length > 0 ? "block" : "none", e.querySelector(".data .certificate-type-t").style.display = "t" in t && t.t.length > 0 ? "block" : "none"
    }

    function getDeviceCameras() {
        return new Promise((function(e, t) {
            null === devliceList ? QrScanner.listCameras(!0).then((function(t) {
                if (null !== devliceList) return void e(devliceList, selectCamera);
                devliceList = [];
                const r = {};
                let n = !1;
                if (t && t.length) {
                    for (let e = 0; e < t.length; e += 1) t[e].id in r || (t[e].label.toLowerCase().indexOf("back") >= 0 ? devliceList.splice(0, 0, t[e]) : devliceList.push(t[e]), r[t[e].id] = !0), t[e].id === selectedCamera && (n = !0);
                    n && null !== selectedCamera || (selectedCamera = devliceList[0].id), e(devliceList, selectedCamera)
                }
            })).catch((function(e) {
                t(e)
            })) : e(devliceList, selectCamera)
        }))
    }

    function selectCamera(e) {
        selectedCamera !== e && (selectedCamera = e, null !== qrScanner && qrScanner.setCamera(e))
    }

    function getCamera() {
        return selectedCamera
    }

    function stopCamera() {
        return new Promise((function(e) {
            null !== qrScanner ? qrScanner.hasFlash().then((function(t) {
                t && qrScanner.isFlashOn() ? qrScanner.turnFlashOff().then((function() {
                    qrScanner.stop(), e()
                })).catch((function() {
                    qrScanner.stop(), e()
                })) : (qrScanner.stop(), e())
            })).catch((function() {
                qrScanner.stop(), e()
            })) : e()
        }))
    }

    function turnFlashOn(e) {
        null !== qrScanner && qrScanner.hasFlash().then((function(t) {
            t && qrScanner.turnFlashOn().then((function() {
                document.getElementById(e).querySelector(".flash-off").style.display = "none", document.getElementById(e).querySelector(".flash-on").style.display = "block"
            })).catch((function() {}))
        })).catch((function() {}))
    }

    function turnFlashOff(e) {
        null !== qrScanner && qrScanner.hasFlash().then((function(t) {
            t && qrScanner.turnFlashOff().then((function() {
                document.getElementById(e).querySelector(".flash-on").style.display = "none", document.getElementById(e).querySelector(".flash-off").style.display = "block"
            })).catch((function() {}))
        })).catch((function() {}))
    }

    function initCameraSelector(e, t, r) {
        return new Promise((function(n, s) {
            getDeviceCameras().then((function(s) {
                if (s && s.length) {
                    const n = e.getElementsByClassName("template")[0];
                    if (e.querySelectorAll(".bx--dropdown-link").length > 1) return;
                    for (let i = s.length - 1; i >= 0; i -= 1) {
                        const a = templateRepeat(n, n);
                        a.classList.remove("template"), fillValues(a, {
                            cameraName: s[i].label
                        });
                        const o = a.getElementsByClassName("bx--dropdown-link");
                        selectedCamera === s[i].id && (e.dataset.value = s[i].id, document.getElementById(t).innerText = s[i].label, a.classList.add("bx--dropdown--selected"), o.length > 0 && o[0].setAttribute("aria-checked", !0)), a.dataset.value = s[i].id, a.dataset.title = s[i].label, o.length > 0 ? o[0].addEventListener("click", r) : a.addEventListener("click", r)
                    }
                }
                n()
            })).catch((function(e) {
                s(e)
            }))
        }))
    }

    function initCamera(e, t, r) {
        return document.getElementById(e).querySelector(".flash-on").style.display = "none", document.getElementById(e).querySelector(".flash-off").style.display = "none", new Promise((function(n, s) {
            if (null !== qrScanner) return void qrScanner.start().then((function() {
                qrScanner.hasFlash().then((function(t) {
                    t && (qrScanner.isFlashOn() ? document.getElementById(e).querySelector(".flash-on").style.display = "block" : document.getElementById(e).querySelector(".flash-off").style.display = "block"), n()
                })).catch((function() {
                    n()
                }))
            })).catch((function(e) {
                s(e)
            }));
            const i = document.getElementById(e).querySelector("video");
            (qrScanner = new QrScanner(i, t, (function(e) {
                "No QR code found" !== e && "Scanner error: RangeError: Array size is not a small enough positive integer." !== e && r(e)
            }))).setCamera(getCamera()).then((function() {
                qrScanner.start().then((function() {
                    qrScanner.hasFlash().then((function(t) {
                        t && (qrScanner.isFlashOn() ? document.getElementById(e).querySelector(".flash-on").style.display = "block" : document.getElementById(e).querySelector(".flash-off").style.display = "block"), n()
                    })).catch((function() {
                        n()
                    }))
                })).catch((function(e) {
                    s(e)
                }))
            })).catch((function(e) {
                s(e)
            }))
        }))
    }

    function getPdfToImage(e) {
        return new Promise((function(t, r) {
            const n = new FileReader;
            n.onload = function(e) {
                const n = new Uint8Array(e.target.result);
                let s = pdf_1.getDocument(n);
                s.promise.then((function(e) {
                    e.getPage(1).then((function(e) {
                        let n = document.createElement("CANVAS");
                        const i = e.getViewport({
                            scale: 2
                        });
                        n.height = i.height, n.width = i.width, e.render({
                            canvasContext: n.getContext("2d"),
                            viewport: i
                        }).promise.then((function() {
                            const e = n.toDataURL("image/png");
                            s.destroy(), s = null, n.remove(), n = null, t(e)
                        })).catch((function(e) {
                            r(e)
                        }))
                    }))
                }))
            }, n.readAsArrayBuffer(e)
        }))
    }

    function getImageToCanvas(e, t, r) {
        return new Promise((function(n, s) {
            const i = window.URL || window.webkitURL;
            let a = new Image;
            a.onload = function() {
                let e = document.createElement("CANVAS");
                const s = r || 0;
                e.width = a.width * (t || 1) + 2 * s, e.height = a.height * (t || 1) + 2 * s;
                const i = e.getContext("2d");
                s > 0 && (i.fillStyle = "white", i.fillRect(0, 0, e.width, e.height)), i.drawImage(a, s, s, e.width - s, e.height - s);
                const o = e.toDataURL("image/png");
                e.remove(), e = null, a.remove(), a = null, n(o)
            }, a.onerror = function(e) {
                s(e)
            }, a.src = i.createObjectURL(e)
        }))
    }

    function scanFileInternal(e, t, r, n) {
        QrScanner.scanImage(t).then((function(e) {
            r(e)
        })).catch((function(e) {
            n(e)
        }))
    }

    function scanFile(e, t, r, n) {
        t && ("application/pdf" !== t.type ? scanFileInternal(e, t, r, (function(s) {
            "No QR code found" != s ? n(s) : function i(a, o) {
                if (a >= 7) {
                    if (0 !== o) return void n(s);
                    a = 2, o = 15
                }
                getImageToCanvas(t, a, 20).then((function(t) {
                    scanFileInternal(e, t, r, (function(e) {
                        "No QR code found" != e ? n(e) : i(a + 1, o * (a + 1))
                    }))
                })).catch((function() {
                    n(s)
                }))
            }(2, 0)
        })) : getPdfToImage(t).then((function(t) {
            scanFileInternal(e, t, r, n)
        })).catch((function(e) {
            n(e)
        })))
    }
    return exports.fillCertificateDetails = fillCertificateDetails, exports.getDeviceCameras = getDeviceCameras, exports.initCamera = initCamera, exports.initCameraSelector = initCameraSelector, exports.loadValueset = loadValueset, exports.preloadKeys = preloadKeys, exports.renderRoleList = renderRoleList, exports.scanFile = scanFile, exports.selectCamera = selectCamera, exports.selectRole = selectRole, exports.stopCamera = stopCamera, exports.turnFlashOff = turnFlashOff, exports.turnFlashOn = turnFlashOn, exports.validate = validate, Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports
}({});