var verify = function(exports) {
    "use strict";
    var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
        dayjs_min = {
            exports: {}
        };
    (function(i, r) {
        (function(n, s) {
            i.exports = s()
        })(commonjsGlobal$1, function() {
            var n = 1e3,
                s = 6e4,
                a = 36e5,
                o = "millisecond",
                c = "second",
                p = "minute",
                h = "hour",
                u = "day",
                l = "week",
                v = "month",
                w = "quarter",
                m = "year",
                S = "date",
                C = "Invalid Date",
                O = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
                x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                I = {
                    name: "en",
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
                },
                B = function(F, L, G) {
                    var M = String(F);
                    return !M || M.length >= L ? F : "" + Array(L + 1 - M.length).join(G) + F
                },
                b = {
                    s: B,
                    z: function(F) {
                        var L = -F.utcOffset(),
                            G = Math.abs(L),
                            M = Math.floor(G / 60),
                            _ = G % 60;
                        return (L <= 0 ? "+" : "-") + B(M, 2, "0") + ":" + B(_, 2, "0")
                    },
                    m: function F(L, G) {
                        if (L.date() < G.date()) return -F(G, L);
                        var M = 12 * (G.year() - L.year()) + (G.month() - L.month()),
                            _ = L.clone().add(M, v),
                            A = G - _ < 0,
                            y = L.clone().add(M + (A ? -1 : 1), v);
                        return +(-(M + (G - _) / (A ? _ - y : y - _)) || 0)
                    },
                    a: function(F) {
                        return F < 0 ? Math.ceil(F) || 0 : Math.floor(F)
                    },
                    p: function(F) {
                        return {
                            M: v,
                            y: m,
                            w: l,
                            d: u,
                            D: S,
                            h,
                            m: p,
                            s: c,
                            ms: o,
                            Q: w
                        } [F] || String(F || "").toLowerCase().replace(/s$/, "")
                    },
                    u: function(F) {
                        return F === void 0
                    }
                },
                f = "en",
                d = {};
            d[f] = I;
            var g = function(F) {
                    return F instanceof P
                },
                E = function F(L, G, M) {
                    var _;
                    if (!L) return f;
                    if (typeof L == "string") {
                        var A = L.toLowerCase();
                        d[A] && (_ = A), G && (d[A] = G, _ = A);
                        var y = L.split("-");
                        if (!_ && y.length > 1) return F(y[0])
                    } else {
                        var k = L.name;
                        d[k] = L, _ = k
                    }
                    return !M && _ && (f = _), _ || !M && f
                },
                T = function(F, L) {
                    if (g(F)) return F.clone();
                    var G = typeof L == "object" ? L : {};
                    return G.date = F, G.args = arguments, new P(G)
                },
                N = b;
            N.l = E, N.i = g, N.w = function(F, L) {
                return T(F, {
                    locale: L.$L,
                    utc: L.$u,
                    x: L.$x,
                    $offset: L.$offset
                })
            };
            var P = function() {
                    function F(G) {
                        this.$L = E(G.locale, null, !0), this.parse(G)
                    }
                    var L = F.prototype;
                    return L.parse = function(G) {
                        this.$d = function(M) {
                            var _ = M.date,
                                A = M.utc;
                            if (_ === null) return new Date(NaN);
                            if (N.u(_)) return new Date;
                            if (_ instanceof Date) return new Date(_);
                            if (typeof _ == "string" && !/Z$/i.test(_)) {
                                var y = _.match(O);
                                if (y) {
                                    var k = y[2] - 1 || 0,
                                        R = (y[7] || "0").substring(0, 3);
                                    return A ? new Date(Date.UTC(y[1], k, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, R)) : new Date(y[1], k, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, R)
                                }
                            }
                            return new Date(_)
                        }(G), this.$x = G.x || {}, this.init()
                    }, L.init = function() {
                        var G = this.$d;
                        this.$y = G.getFullYear(), this.$M = G.getMonth(), this.$D = G.getDate(), this.$W = G.getDay(), this.$H = G.getHours(), this.$m = G.getMinutes(), this.$s = G.getSeconds(), this.$ms = G.getMilliseconds()
                    }, L.$utils = function() {
                        return N
                    }, L.isValid = function() {
                        return this.$d.toString() !== C
                    }, L.isSame = function(G, M) {
                        var _ = T(G);
                        return this.startOf(M) <= _ && _ <= this.endOf(M)
                    }, L.isAfter = function(G, M) {
                        return T(G) < this.startOf(M)
                    }, L.isBefore = function(G, M) {
                        return this.endOf(M) < T(G)
                    }, L.$g = function(G, M, _) {
                        return N.u(G) ? this[M] : this.set(_, G)
                    }, L.unix = function() {
                        return Math.floor(this.valueOf() / 1e3)
                    }, L.valueOf = function() {
                        return this.$d.getTime()
                    }, L.startOf = function(G, M) {
                        var _ = this,
                            A = !!N.u(M) || M,
                            y = N.p(G),
                            k = function(K, Y) {
                                var Q = N.w(_.$u ? Date.UTC(_.$y, Y, K) : new Date(_.$y, Y, K), _);
                                return A ? Q : Q.endOf(u)
                            },
                            R = function(K, Y) {
                                return N.w(_.toDate()[K].apply(_.toDate("s"), (A ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Y)), _)
                            },
                            D = this.$W,
                            H = this.$M,
                            q = this.$D,
                            z = "set" + (this.$u ? "UTC" : "");
                        switch (y) {
                            case m:
                                return A ? k(1, 0) : k(31, 11);
                            case v:
                                return A ? k(1, H) : k(0, H + 1);
                            case l:
                                var j = this.$locale().weekStart || 0,
                                    V = (D < j ? D + 7 : D) - j;
                                return k(A ? q - V : q + (6 - V), H);
                            case u:
                            case S:
                                return R(z + "Hours", 0);
                            case h:
                                return R(z + "Minutes", 1);
                            case p:
                                return R(z + "Seconds", 2);
                            case c:
                                return R(z + "Milliseconds", 3);
                            default:
                                return this.clone()
                        }
                    }, L.endOf = function(G) {
                        return this.startOf(G, !1)
                    }, L.$set = function(G, M) {
                        var _, A = N.p(G),
                            y = "set" + (this.$u ? "UTC" : ""),
                            k = (_ = {}, _[u] = y + "Date", _[S] = y + "Date", _[v] = y + "Month", _[m] = y + "FullYear", _[h] = y + "Hours", _[p] = y + "Minutes", _[c] = y + "Seconds", _[o] = y + "Milliseconds", _)[A],
                            R = A === u ? this.$D + (M - this.$W) : M;
                        if (A === v || A === m) {
                            var D = this.clone().set(S, 1);
                            D.$d[k](R), D.init(), this.$d = D.set(S, Math.min(this.$D, D.daysInMonth())).$d
                        } else k && this.$d[k](R);
                        return this.init(), this
                    }, L.set = function(G, M) {
                        return this.clone().$set(G, M)
                    }, L.get = function(G) {
                        return this[N.p(G)]()
                    }, L.add = function(G, M) {
                        var _, A = this;
                        G = Number(G);
                        var y = N.p(M),
                            k = function(H) {
                                var q = T(A);
                                return N.w(q.date(q.date() + Math.round(H * G)), A)
                            };
                        if (y === v) return this.set(v, this.$M + G);
                        if (y === m) return this.set(m, this.$y + G);
                        if (y === u) return k(1);
                        if (y === l) return k(7);
                        var R = (_ = {}, _[p] = s, _[h] = a, _[c] = n, _)[y] || 1,
                            D = this.$d.getTime() + G * R;
                        return N.w(D, this)
                    }, L.subtract = function(G, M) {
                        return this.add(-1 * G, M)
                    }, L.format = function(G) {
                        var M = this,
                            _ = this.$locale();
                        if (!this.isValid()) return _.invalidDate || C;
                        var A = G || "YYYY-MM-DDTHH:mm:ssZ",
                            y = N.z(this),
                            k = this.$H,
                            R = this.$m,
                            D = this.$M,
                            H = _.weekdays,
                            q = _.months,
                            z = function(Y, Q, ee, J) {
                                return Y && (Y[Q] || Y(M, A)) || ee[Q].slice(0, J)
                            },
                            j = function(Y) {
                                return N.s(k % 12 || 12, Y, "0")
                            },
                            V = _.meridiem || function(Y, Q, ee) {
                                var J = Y < 12 ? "AM" : "PM";
                                return ee ? J.toLowerCase() : J
                            },
                            K = {
                                YY: String(this.$y).slice(-2),
                                YYYY: this.$y,
                                M: D + 1,
                                MM: N.s(D + 1, 2, "0"),
                                MMM: z(_.monthsShort, D, q, 3),
                                MMMM: z(q, D),
                                D: this.$D,
                                DD: N.s(this.$D, 2, "0"),
                                d: String(this.$W),
                                dd: z(_.weekdaysMin, this.$W, H, 2),
                                ddd: z(_.weekdaysShort, this.$W, H, 3),
                                dddd: H[this.$W],
                                H: String(k),
                                HH: N.s(k, 2, "0"),
                                h: j(1),
                                hh: j(2),
                                a: V(k, R, !0),
                                A: V(k, R, !1),
                                m: String(R),
                                mm: N.s(R, 2, "0"),
                                s: String(this.$s),
                                ss: N.s(this.$s, 2, "0"),
                                SSS: N.s(this.$ms, 3, "0"),
                                Z: y
                            };
                        return A.replace(x, function(Y, Q) {
                            return Q || K[Y] || y.replace(":", "")
                        })
                    }, L.utcOffset = function() {
                        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                    }, L.diff = function(G, M, _) {
                        var A, y = N.p(M),
                            k = T(G),
                            R = (k.utcOffset() - this.utcOffset()) * s,
                            D = this - k,
                            H = N.m(this, k);
                        return H = (A = {}, A[m] = H / 12, A[v] = H, A[w] = H / 3, A[l] = (D - R) / 6048e5, A[u] = (D - R) / 864e5, A[h] = D / a, A[p] = D / s, A[c] = D / n, A)[y] || D, _ ? H : N.a(H)
                    }, L.daysInMonth = function() {
                        return this.endOf(v).$D
                    }, L.$locale = function() {
                        return d[this.$L]
                    }, L.locale = function(G, M) {
                        if (!G) return this.$L;
                        var _ = this.clone(),
                            A = E(G, M, !0);
                        return A && (_.$L = A), _
                    }, L.clone = function() {
                        return N.w(this.$d, this)
                    }, L.toDate = function() {
                        return new Date(this.valueOf())
                    }, L.toJSON = function() {
                        return this.isValid() ? this.toISOString() : null
                    }, L.toISOString = function() {
                        return this.$d.toISOString()
                    }, L.toString = function() {
                        return this.$d.toUTCString()
                    }, F
                }(),
                U = P.prototype;
            return T.prototype = U, [
                ["$ms", o],
                ["$s", c],
                ["$m", p],
                ["$H", h],
                ["$W", u],
                ["$M", v],
                ["$y", m],
                ["$D", S]
            ].forEach(function(F) {
                U[F[1]] = function(L) {
                    return this.$g(L, F[0], F[1])
                }
            }), T.extend = function(F, L) {
                return F.$i || (F(L, P, T), F.$i = !0), T
            }, T.locale = E, T.isDayjs = g, T.unix = function(F) {
                return T(1e3 * F)
            }, T.en = d[f], T.Ls = d, T.p = {}, T
        })
    })(dayjs_min);
    const dayjs = dayjs_min.exports;
    var utc$1 = {
        exports: {}
    };
    (function(i, r) {
        (function(n, s) {
            i.exports = s()
        })(commonjsGlobal$1, function() {
            var n = "minute",
                s = /[+-]\d\d(?::?\d\d)?/g,
                a = /([+-]|\d\d)/g;
            return function(o, c, p) {
                var h = c.prototype;
                p.utc = function(C) {
                    var O = {
                        date: C,
                        utc: !0,
                        args: arguments
                    };
                    return new c(O)
                }, h.utc = function(C) {
                    var O = p(this.toDate(), {
                        locale: this.$L,
                        utc: !0
                    });
                    return C ? O.add(this.utcOffset(), n) : O
                }, h.local = function() {
                    return p(this.toDate(), {
                        locale: this.$L,
                        utc: !1
                    })
                };
                var u = h.parse;
                h.parse = function(C) {
                    C.utc && (this.$u = !0), this.$utils().u(C.$offset) || (this.$offset = C.$offset), u.call(this, C)
                };
                var l = h.init;
                h.init = function() {
                    if (this.$u) {
                        var C = this.$d;
                        this.$y = C.getUTCFullYear(), this.$M = C.getUTCMonth(), this.$D = C.getUTCDate(), this.$W = C.getUTCDay(), this.$H = C.getUTCHours(), this.$m = C.getUTCMinutes(), this.$s = C.getUTCSeconds(), this.$ms = C.getUTCMilliseconds()
                    } else l.call(this)
                };
                var v = h.utcOffset;
                h.utcOffset = function(C, O) {
                    var x = this.$utils().u;
                    if (x(C)) return this.$u ? 0 : x(this.$offset) ? v.call(this) : this.$offset;
                    if (typeof C == "string" && (C = function(f) {
                            f === void 0 && (f = "");
                            var d = f.match(s);
                            if (!d) return null;
                            var g = ("" + d[0]).match(a) || ["-", 0, 0],
                                E = g[0],
                                T = 60 * +g[1] + +g[2];
                            return T === 0 ? 0 : E === "+" ? T : -T
                        }(C), C === null)) return this;
                    var I = Math.abs(C) <= 16 ? 60 * C : C,
                        B = this;
                    if (O) return B.$offset = I, B.$u = C === 0, B;
                    if (C !== 0) {
                        var b = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                        (B = this.local().add(I + b, n)).$offset = I, B.$x.$localOffset = b
                    } else B = this.utc();
                    return B
                };
                var w = h.format;
                h.format = function(C) {
                    var O = C || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
                    return w.call(this, O)
                }, h.valueOf = function() {
                    var C = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
                    return this.$d.valueOf() - 6e4 * C
                }, h.isUTC = function() {
                    return !!this.$u
                }, h.toISOString = function() {
                    return this.toDate().toISOString()
                }, h.toString = function() {
                    return this.toDate().toUTCString()
                };
                var m = h.toDate;
                h.toDate = function(C) {
                    return C === "s" && this.$offset ? p(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : m.call(this)
                };
                var S = h.diff;
                h.diff = function(C, O, x) {
                    if (C && this.$u === C.$u) return S.call(this, C, O, x);
                    var I = this.local(),
                        B = p(C).local();
                    return S.call(I, B, O, x)
                }
            }
        })
    })(utc$1);
    const utc = utc$1.exports;
    class e {
        constructor(r, n, s, a, o) {
            this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE, this._preferredCamera = "environment", this._maxScansPerSecond = 25, this._lastScanTimestamp = -1, this._destroyed = this._flashOn = this._paused = this._active = !1, this.$video = r, this.$canvas = document.createElement("canvas"), s && typeof s == "object" ? this._onDecode = n : (console.warn(s || a || o ? "You're using a deprecated version of the QrScanner constructor which will be removed in the future" : "Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), this._legacyOnDecode = n), n = typeof s == "object" ? s : {}, this._onDecodeError = n.onDecodeError || (typeof s == "function" ? s : this._onDecodeError), this._calculateScanRegion = n.calculateScanRegion || (typeof a == "function" ? a : this._calculateScanRegion), this._preferredCamera = n.preferredCamera || o || this._preferredCamera, this._legacyCanvasSize = typeof s == "number" ? s : typeof a == "number" ? a : this._legacyCanvasSize, this._maxScansPerSecond = n.maxScansPerSecond || this._maxScansPerSecond, this._onPlay = this._onPlay.bind(this), this._onLoadedMetaData = this._onLoadedMetaData.bind(this), this._onVisibilityChange = this._onVisibilityChange.bind(this), this._updateOverlay = this._updateOverlay.bind(this), r.disablePictureInPicture = !0, r.playsInline = !0, r.muted = !0;
            let c = !1;
            if (r.hidden && (r.hidden = !1, c = !0), document.body.contains(r) || (document.body.appendChild(r), c = !0), s = r.parentElement, n.highlightScanRegion || n.highlightCodeOutline) {
                if (a = !!n.overlay, this.$overlay = n.overlay || document.createElement("div"), o = this.$overlay.style, o.position = "absolute", o.display = "none", o.pointerEvents = "none", this.$overlay.classList.add("scan-region-highlight"), !a && n.highlightScanRegion) {
                    this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
                    try {
                        this.$overlay.firstElementChild.animate({
                            transform: ["scale(.98)", "scale(1.01)"]
                        }, {
                            duration: 400,
                            iterations: 1 / 0,
                            direction: "alternate",
                            easing: "ease-in-out"
                        })
                    } catch {}
                    s.insertBefore(this.$overlay, this.$video.nextSibling)
                }
                n.highlightCodeOutline && (this.$overlay.insertAdjacentHTML("beforeend", '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild)
            }
            this._scanRegion = this._calculateScanRegion(r), requestAnimationFrame(() => {
                let p = window.getComputedStyle(r);
                p.display === "none" && (r.style.setProperty("display", "block", "important"), c = !0), p.visibility !== "visible" && (r.style.setProperty("visibility", "visible", "important"), c = !0), c && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), r.style.opacity = "0", r.style.width = "0", r.style.height = "0", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight), this.$overlay && this._updateOverlay()
            }), r.addEventListener("play", this._onPlay), r.addEventListener("loadedmetadata", this._onLoadedMetaData), document.addEventListener("visibilitychange", this._onVisibilityChange), window.addEventListener("resize", this._updateOverlay), this._qrEnginePromise = e.createQrEngine()
        }
        static set WORKER_PATH(r) {
            console.warn("Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.")
        }
        static async hasCamera() {
            try {
                return !!(await e.listCameras(!1)).length
            } catch {
                return !1
            }
        }
        static async listCameras(r = !1) {
            if (!navigator.mediaDevices) return [];
            let n = async () => (await navigator.mediaDevices.enumerateDevices()).filter(a => a.kind === "videoinput"), s;
            try {
                r && (await n()).every(a => !a.label) && (s = await navigator.mediaDevices.getUserMedia({
                    audio: !1,
                    video: !0
                }))
            } catch {}
            try {
                return (await n()).map((a, o) => ({
                    id: a.deviceId,
                    label: a.label || (o === 0 ? "Default Camera" : `Camera ${o+1}`)
                }))
            } finally {
                s && (console.warn("Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"), e._stopVideoStream(s))
            }
        }
        async hasFlash() {
            let r;
            try {
                if (this.$video.srcObject) {
                    if (!(this.$video.srcObject instanceof MediaStream)) return !1;
                    r = this.$video.srcObject
                } else r = (await this._getCameraStream()).stream;
                return "torch" in r.getVideoTracks()[0].getSettings()
            } catch {
                return !1
            } finally {
                r && r !== this.$video.srcObject && (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), e._stopVideoStream(r))
            }
        }
        isFlashOn() {
            return this._flashOn
        }
        async toggleFlash() {
            this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn()
        }
        async turnFlashOn() {
            if (!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused)) try {
                if (!await this.hasFlash()) throw "No flash available";
                await this.$video.srcObject.getVideoTracks()[0].applyConstraints({
                    advanced: [{
                        torch: !0
                    }]
                })
            } catch (r) {
                throw this._flashOn = !1, r
            }
        }
        async turnFlashOff() {
            this._flashOn && (this._flashOn = !1, await this._restartVideoStream())
        }
        destroy() {
            this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData), this.$video.removeEventListener("play", this._onPlay), document.removeEventListener("visibilitychange", this._onVisibilityChange), window.removeEventListener("resize", this._updateOverlay), this._destroyed = !0, this._flashOn = !1, this.stop(), e._postWorkerMessage(this._qrEnginePromise, "close")
        }
        async start() {
            if (this._destroyed) throw Error("The QR scanner can not be started as it had been destroyed.");
            if ((!this._active || this._paused) && (window.location.protocol !== "https:" && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = !0, !document.hidden))
                if (this._paused = !1, this.$video.srcObject) await this.$video.play();
                else try {
                    let {
                        stream: r,
                        facingMode: n
                    } = await this._getCameraStream();
                    !this._active || this._paused ? e._stopVideoStream(r) : (this._setVideoMirror(n), this.$video.srcObject = r, await this.$video.play(), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(() => {})))
                } catch (r) {
                    if (!this._paused) throw this._active = !1, r
                }
        }
        stop() {
            this.pause(), this._active = !1
        }
        async pause(r = !1) {
            if (this._paused = !0, !this._active) return !0;
            this.$video.pause(), this.$overlay && (this.$overlay.style.display = "none");
            let n = () => {
                this.$video.srcObject instanceof MediaStream && (e._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null)
            };
            return r ? (n(), !0) : (await new Promise(s => setTimeout(s, 300)), this._paused ? (n(), !0) : !1)
        }
        async setCamera(r) {
            r !== this._preferredCamera && (this._preferredCamera = r, await this._restartVideoStream())
        }
        static async scanImage(r, n, s, a, o = !1, c = !1) {
            let p, h = !1;
            n && ("scanRegion" in n || "qrEngine" in n || "canvas" in n || "disallowCanvasResizing" in n || "alsoTryWithoutScanRegion" in n || "returnDetailedScanResult" in n) ? (p = n.scanRegion, s = n.qrEngine, a = n.canvas, o = n.disallowCanvasResizing || !1, c = n.alsoTryWithoutScanRegion || !1, h = !0) : console.warn(n || s || a || o || c ? "You're using a deprecated api for scanImage which will be removed in the future." : "Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), n = !!s;
            try {
                let u, l;
                [s, u] = await Promise.all([s || e.createQrEngine(), e._loadImage(r)]), [a, l] = e._drawToCanvas(u, p, a, o);
                let v;
                if (s instanceof Worker) {
                    let w = s;
                    n || e._postWorkerMessageSync(w, "inversionMode", "both"), v = await new Promise((m, S) => {
                        let C, O, x, I = -1;
                        O = b => {
                            b.data.id === I && (w.removeEventListener("message", O), w.removeEventListener("error", x), clearTimeout(C), b.data.data !== null ? m({
                                data: b.data.data,
                                cornerPoints: e._convertPoints(b.data.cornerPoints, p)
                            }) : S(e.NO_QR_CODE_FOUND))
                        }, x = b => {
                            w.removeEventListener("message", O), w.removeEventListener("error", x), clearTimeout(C), S("Scanner error: " + (b ? b.message || b : "Unknown Error"))
                        }, w.addEventListener("message", O), w.addEventListener("error", x), C = setTimeout(() => x("timeout"), 1e4);
                        let B = l.getImageData(0, 0, a.width, a.height);
                        I = e._postWorkerMessageSync(w, "decode", B, [B.data.buffer])
                    })
                } else v = await Promise.race([new Promise((w, m) => window.setTimeout(() => m("Scanner error: timeout"), 1e4)), (async () => {
                    try {
                        var [w] = await s.detect(a);
                        if (!w) throw e.NO_QR_CODE_FOUND;
                        return {
                            data: w.rawValue,
                            cornerPoints: e._convertPoints(w.cornerPoints, p)
                        }
                    } catch (m) {
                        if (w = m.message || m, /not implemented|service unavailable/.test(w)) return e._disableBarcodeDetector = !0, e.scanImage(r, {
                            scanRegion: p,
                            canvas: a,
                            disallowCanvasResizing: o,
                            alsoTryWithoutScanRegion: c
                        });
                        throw `Scanner error: ${w}`
                    }
                })()]);
                return h ? v : v.data
            } catch (u) {
                if (!p || !c) throw u;
                let l = await e.scanImage(r, {
                    qrEngine: s,
                    canvas: a,
                    disallowCanvasResizing: o
                });
                return h ? l : l.data
            } finally {
                n || e._postWorkerMessage(s, "close")
            }
        }
        setGrayscaleWeights(r, n, s, a = !0) {
            e._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
                red: r,
                green: n,
                blue: s,
                useIntegerApproximation: a
            })
        }
        setInversionMode(r) {
            e._postWorkerMessage(this._qrEnginePromise, "inversionMode", r)
        }
        static async createQrEngine(r) {
            return r && console.warn("Specifying a worker path is not required and not supported anymore."), !e._disableBarcodeDetector && "BarcodeDetector" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes("qr_code") ? new BarcodeDetector({
                formats: ["qr_code"]
            }) : Promise.resolve().then(() => qrScannerWorker_min).then(n => n.createWorker())
        }
        _onPlay() {
            this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay(), this.$overlay && (this.$overlay.style.display = ""), this._scanFrame()
        }
        _onLoadedMetaData() {
            this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay()
        }
        _onVisibilityChange() {
            document.hidden ? this.pause() : this._active && this.start()
        }
        _calculateScanRegion(r) {
            let n = Math.round(.6666666666666666 * Math.min(r.videoWidth, r.videoHeight));
            return {
                x: Math.round((r.videoWidth - n) / 2),
                y: Math.round((r.videoHeight - n) / 2),
                width: n,
                height: n,
                downScaledWidth: this._legacyCanvasSize,
                downScaledHeight: this._legacyCanvasSize
            }
        }
        _updateOverlay() {
            requestAnimationFrame(() => {
                if (this.$overlay) {
                    var r = this.$video,
                        n = r.videoWidth,
                        s = r.videoHeight,
                        a = r.offsetWidth,
                        o = r.offsetHeight,
                        c = r.offsetLeft,
                        p = r.offsetTop,
                        h = window.getComputedStyle(r),
                        u = h.objectFit,
                        l = n / s,
                        v = a / o;
                    switch (u) {
                        case "none":
                            var w = n,
                                m = s;
                            break;
                        case "fill":
                            w = a, m = o;
                            break;
                        default:
                            (u === "cover" ? l > v : l < v) ? (m = o, w = m * l) : (w = a, m = w / l), u === "scale-down" && (w = Math.min(w, n), m = Math.min(m, s))
                    }
                    var [S, C] = h.objectPosition.split(" ").map((x, I) => {
                        const B = parseFloat(x);
                        return x.endsWith("%") ? (I ? o - m : a - w) * B / 100 : B
                    });
                    h = this._scanRegion.width || n, v = this._scanRegion.height || s, u = this._scanRegion.x || 0;
                    var O = this._scanRegion.y || 0;
                    l = this.$overlay.style, l.width = `${h/n*w}px`, l.height = `${v/s*m}px`, l.top = `${p+C+O/s*m}px`, s = /scaleX\(-1\)/.test(r.style.transform), l.left = `${c+(s?a-S-w:S)+(s?n-u-h:u)/n*w}px`, l.transform = r.style.transform
                }
            })
        }
        static _convertPoints(r, n) {
            if (!n) return r;
            let s = n.x || 0,
                a = n.y || 0,
                o = n.width && n.downScaledWidth ? n.width / n.downScaledWidth : 1;
            n = n.height && n.downScaledHeight ? n.height / n.downScaledHeight : 1;
            for (let c of r) c.x = c.x * o + s, c.y = c.y * n + a;
            return r
        }
        _scanFrame() {
            !this._active || this.$video.paused || this.$video.ended || ("requestVideoFrameCallback" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {
                if (!(1 >= this.$video.readyState)) {
                    var r = Date.now() - this._lastScanTimestamp,
                        n = 1e3 / this._maxScansPerSecond;
                    r < n && await new Promise(a => setTimeout(a, n - r)), this._lastScanTimestamp = Date.now();
                    try {
                        var s = await e.scanImage(this.$video, {
                            scanRegion: this._scanRegion,
                            qrEngine: this._qrEnginePromise,
                            canvas: this.$canvas
                        })
                    } catch (a) {
                        if (!this._active) return;
                        this._onDecodeError(a)
                    }!e._disableBarcodeDetector || await this._qrEnginePromise instanceof Worker || (this._qrEnginePromise = e.createQrEngine()), s ? (this._onDecode ? this._onDecode(s) : this._legacyOnDecode && this._legacyOnDecode(s.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute("viewBox", `${this._scanRegion.x||0} ${this._scanRegion.y||0} ${this._scanRegion.width||this.$video.videoWidth} ${this._scanRegion.height||this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute("points", s.cornerPoints.map(({
                        x: a,
                        y: o
                    }) => `${a},${o}`).join(" ")), this.$codeOutlineHighlight.style.display = "")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = "none", 100))
                }
                this._scanFrame()
            })
        }
        _onDecodeError(r) {
            r !== e.NO_QR_CODE_FOUND && console.log(r)
        }
        async _getCameraStream() {
            if (!navigator.mediaDevices) throw "Camera not found.";
            let r = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId",
                n = [{
                    width: {
                        min: 1024
                    }
                }, {
                    width: {
                        min: 768
                    }
                }, {}],
                s = n.map(a => Object.assign({}, a, {
                    [r]: {
                        exact: this._preferredCamera
                    }
                }));
            for (let a of [...s, ...n]) try {
                let o = await navigator.mediaDevices.getUserMedia({
                        video: a,
                        audio: !1
                    }),
                    c = this._getFacingMode(o) || (a.facingMode ? this._preferredCamera : this._preferredCamera === "environment" ? "user" : "environment");
                return {
                    stream: o,
                    facingMode: c
                }
            } catch {}
            throw "Camera not found."
        }
        async _restartVideoStream() {
            let r = this._paused;
            await this.pause(!0) && !r && this._active && await this.start()
        }
        static _stopVideoStream(r) {
            for (let n of r.getTracks()) n.stop(), r.removeTrack(n)
        }
        _setVideoMirror(r) {
            this.$video.style.transform = "scaleX(" + (r === "user" ? -1 : 1) + ")"
        }
        _getFacingMode(r) {
            return (r = r.getVideoTracks()[0]) ? /rear|back|environment/i.test(r.label) ? "environment" : /front|user|face/i.test(r.label) ? "user" : null : null
        }
        static _drawToCanvas(r, n, s, a = !1) {
            s = s || document.createElement("canvas");
            let o = n && n.x ? n.x : 0,
                c = n && n.y ? n.y : 0,
                p = n && n.width ? n.width : r.videoWidth || r.width,
                h = n && n.height ? n.height : r.videoHeight || r.height;
            return a || (a = n && n.downScaledWidth ? n.downScaledWidth : p, n = n && n.downScaledHeight ? n.downScaledHeight : h, s.width !== a && (s.width = a), s.height !== n && (s.height = n)), n = s.getContext("2d", {
                alpha: !1
            }), n.imageSmoothingEnabled = !1, n.drawImage(r, o, c, p, h, 0, 0, s.width, s.height), [s, n]
        }
        static async _loadImage(r) {
            if (r instanceof Image) return await e._awaitImageLoad(r), r;
            if (r instanceof HTMLVideoElement || r instanceof HTMLCanvasElement || r instanceof SVGImageElement || "OffscreenCanvas" in window && r instanceof OffscreenCanvas || "ImageBitmap" in window && r instanceof ImageBitmap) return r;
            if (r instanceof File || r instanceof Blob || r instanceof URL || typeof r == "string") {
                let n = new Image;
                n.src = r instanceof File || r instanceof Blob ? URL.createObjectURL(r) : r.toString();
                try {
                    return await e._awaitImageLoad(n), n
                } finally {
                    (r instanceof File || r instanceof Blob) && URL.revokeObjectURL(n.src)
                }
            } else throw "Unsupported image type."
        }
        static async _awaitImageLoad(r) {
            r.complete && r.naturalWidth !== 0 || await new Promise((n, s) => {
                let a = o => {
                    r.removeEventListener("load", a), r.removeEventListener("error", a), o instanceof ErrorEvent ? s("Image load error") : n()
                };
                r.addEventListener("load", a), r.addEventListener("error", a)
            })
        }
        static async _postWorkerMessage(r, n, s, a) {
            return e._postWorkerMessageSync(await r, n, s, a)
        }
        static _postWorkerMessageSync(r, n, s, a) {
            if (!(r instanceof Worker)) return -1;
            let o = e._workerMessageId++;
            return r.postMessage({
                id: o,
                type: n,
                data: s
            }, a), o
        }
    }
    e.DEFAULT_CANVAS_SIZE = 400, e.NO_QR_CODE_FOUND = "No QR code found", e._disableBarcodeDetector = !1, e._workerMessageId = 0;
    var global$1 = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};

    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined")
    }

    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined")
    }
    var cachedSetTimeout = defaultSetTimout,
        cachedClearTimeout = defaultClearTimeout;
    typeof global$1.setTimeout == "function" && (cachedSetTimeout = setTimeout), typeof global$1.clearTimeout == "function" && (cachedClearTimeout = clearTimeout);

    function runTimeout(i) {
        if (cachedSetTimeout === setTimeout) return setTimeout(i, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(i, 0);
        try {
            return cachedSetTimeout(i, 0)
        } catch {
            try {
                return cachedSetTimeout.call(null, i, 0)
            } catch {
                return cachedSetTimeout.call(this, i, 0)
            }
        }
    }

    function runClearTimeout(i) {
        if (cachedClearTimeout === clearTimeout) return clearTimeout(i);
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(i);
        try {
            return cachedClearTimeout(i)
        } catch {
            try {
                return cachedClearTimeout.call(null, i)
            } catch {
                return cachedClearTimeout.call(this, i)
            }
        }
    }
    var queue = [],
        draining = !1,
        currentQueue, queueIndex = -1;

    function cleanUpNextTick() {
        !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
    }

    function drainQueue() {
        if (!draining) {
            var i = runTimeout(cleanUpNextTick);
            draining = !0;
            for (var r = queue.length; r;) {
                for (currentQueue = queue, queue = []; ++queueIndex < r;) currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, r = queue.length
            }
            currentQueue = null, draining = !1, runClearTimeout(i)
        }
    }

    function nextTick(i) {
        var r = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++) r[n - 1] = arguments[n];
        queue.push(new Item(i, r)), queue.length === 1 && !draining && runTimeout(drainQueue)
    }

    function Item(i, r) {
        this.fun = i, this.array = r
    }
    Item.prototype.run = function() {
        this.fun.apply(null, this.array)
    };
    var title = "browser",
        platform = "browser",
        browser = !0,
        env = {},
        argv = [],
        version = "",
        versions = {},
        release = {},
        config = {};

    function noop() {}
    var on = noop,
        addListener = noop,
        once = noop,
        off = noop,
        removeListener = noop,
        removeAllListeners = noop,
        emit = noop;

    function binding(i) {
        throw new Error("process.binding is not supported")
    }

    function cwd() {
        return "/"
    }

    function chdir(i) {
        throw new Error("process.chdir is not supported")
    }

    function umask() {
        return 0
    }
    var performance = global$1.performance || {},
        performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
            return new Date().getTime()
        };

    function hrtime(i) {
        var r = performanceNow.call(performance) * .001,
            n = Math.floor(r),
            s = Math.floor(r % 1 * 1e9);
        return i && (n = n - i[0], s = s - i[1], s < 0 && (n--, s += 1e9)), [n, s]
    }
    var startTime = new Date;

    function uptime() {
        var i = new Date,
            r = i - startTime;
        return r / 1e3
    }
    var process$1 = {
            nextTick,
            title,
            browser,
            env,
            argv,
            version,
            versions,
            on,
            addListener,
            once,
            off,
            removeListener,
            removeAllListeners,
            emit,
            binding,
            cwd,
            chdir,
            umask,
            hrtime,
            platform,
            release,
            config,
            uptime
        },
        lookup = [],
        revLookup = [],
        Arr = typeof Uint8Array < "u" ? Uint8Array : Array,
        inited = !1;

    function init() {
        inited = !0;
        for (var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, n = i.length; r < n; ++r) lookup[r] = i[r], revLookup[i.charCodeAt(r)] = r;
        revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63
    }

    function toByteArray(i) {
        inited || init();
        var r, n, s, a, o, c, p = i.length;
        if (p % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        o = i[p - 2] === "=" ? 2 : i[p - 1] === "=" ? 1 : 0, c = new Arr(p * 3 / 4 - o), s = o > 0 ? p - 4 : p;
        var h = 0;
        for (r = 0, n = 0; r < s; r += 4, n += 3) a = revLookup[i.charCodeAt(r)] << 18 | revLookup[i.charCodeAt(r + 1)] << 12 | revLookup[i.charCodeAt(r + 2)] << 6 | revLookup[i.charCodeAt(r + 3)], c[h++] = a >> 16 & 255, c[h++] = a >> 8 & 255, c[h++] = a & 255;
        return o === 2 ? (a = revLookup[i.charCodeAt(r)] << 2 | revLookup[i.charCodeAt(r + 1)] >> 4, c[h++] = a & 255) : o === 1 && (a = revLookup[i.charCodeAt(r)] << 10 | revLookup[i.charCodeAt(r + 1)] << 4 | revLookup[i.charCodeAt(r + 2)] >> 2, c[h++] = a >> 8 & 255, c[h++] = a & 255), c
    }

    function tripletToBase64(i) {
        return lookup[i >> 18 & 63] + lookup[i >> 12 & 63] + lookup[i >> 6 & 63] + lookup[i & 63]
    }

    function encodeChunk(i, r, n) {
        for (var s, a = [], o = r; o < n; o += 3) s = (i[o] << 16) + (i[o + 1] << 8) + i[o + 2], a.push(tripletToBase64(s));
        return a.join("")
    }

    function fromByteArray(i) {
        inited || init();
        for (var r, n = i.length, s = n % 3, a = "", o = [], c = 16383, p = 0, h = n - s; p < h; p += c) o.push(encodeChunk(i, p, p + c > h ? h : p + c));
        return s === 1 ? (r = i[n - 1], a += lookup[r >> 2], a += lookup[r << 4 & 63], a += "==") : s === 2 && (r = (i[n - 2] << 8) + i[n - 1], a += lookup[r >> 10], a += lookup[r >> 4 & 63], a += lookup[r << 2 & 63], a += "="), o.push(a), o.join("")
    }

    function read(i, r, n, s, a) {
        var o, c, p = a * 8 - s - 1,
            h = (1 << p) - 1,
            u = h >> 1,
            l = -7,
            v = n ? a - 1 : 0,
            w = n ? -1 : 1,
            m = i[r + v];
        for (v += w, o = m & (1 << -l) - 1, m >>= -l, l += p; l > 0; o = o * 256 + i[r + v], v += w, l -= 8);
        for (c = o & (1 << -l) - 1, o >>= -l, l += s; l > 0; c = c * 256 + i[r + v], v += w, l -= 8);
        if (o === 0) o = 1 - u;
        else {
            if (o === h) return c ? NaN : (m ? -1 : 1) * (1 / 0);
            c = c + Math.pow(2, s), o = o - u
        }
        return (m ? -1 : 1) * c * Math.pow(2, o - s)
    }

    function write(i, r, n, s, a, o) {
        var c, p, h, u = o * 8 - a - 1,
            l = (1 << u) - 1,
            v = l >> 1,
            w = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            m = s ? 0 : o - 1,
            S = s ? 1 : -1,
            C = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (p = isNaN(r) ? 1 : 0, c = l) : (c = Math.floor(Math.log(r) / Math.LN2), r * (h = Math.pow(2, -c)) < 1 && (c--, h *= 2), c + v >= 1 ? r += w / h : r += w * Math.pow(2, 1 - v), r * h >= 2 && (c++, h /= 2), c + v >= l ? (p = 0, c = l) : c + v >= 1 ? (p = (r * h - 1) * Math.pow(2, a), c = c + v) : (p = r * Math.pow(2, v - 1) * Math.pow(2, a), c = 0)); a >= 8; i[n + m] = p & 255, m += S, p /= 256, a -= 8);
        for (c = c << a | p, u += a; u > 0; i[n + m] = c & 255, m += S, c /= 256, u -= 8);
        i[n + m - S] |= C * 128
    }
    var toString$2 = {}.toString,
        isArray = Array.isArray || function(i) {
            return toString$2.call(i) == "[object Array]"
        },
        INSPECT_MAX_BYTES = 50;
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : !0;

    function kMaxLength() {
        return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
    }

    function createBuffer(i, r) {
        if (kMaxLength() < r) throw new RangeError("Invalid typed array length");
        return Buffer.TYPED_ARRAY_SUPPORT ? (i = new Uint8Array(r), i.__proto__ = Buffer.prototype) : (i === null && (i = new Buffer(r)), i.length = r), i
    }

    function Buffer(i, r, n) {
        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) return new Buffer(i, r, n);
        if (typeof i == "number") {
            if (typeof r == "string") throw new Error("If encoding is specified then the first argument must be a string");
            return allocUnsafe(this, i)
        }
        return from(this, i, r, n)
    }
    Buffer.poolSize = 8192, Buffer._augment = function(i) {
        return i.__proto__ = Buffer.prototype, i
    };

    function from(i, r, n, s) {
        if (typeof r == "number") throw new TypeError('"value" argument must not be a number');
        return typeof ArrayBuffer < "u" && r instanceof ArrayBuffer ? fromArrayBuffer(i, r, n, s) : typeof r == "string" ? fromString(i, r, n) : fromObject(i, r)
    }
    Buffer.from = function(i, r, n) {
        return from(null, i, r, n)
    }, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array);

    function assertSize(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be a number');
        if (i < 0) throw new RangeError('"size" argument must not be negative')
    }

    function alloc(i, r, n, s) {
        return assertSize(r), r <= 0 ? createBuffer(i, r) : n !== void 0 ? typeof s == "string" ? createBuffer(i, r).fill(n, s) : createBuffer(i, r).fill(n) : createBuffer(i, r)
    }
    Buffer.alloc = function(i, r, n) {
        return alloc(null, i, r, n)
    };

    function allocUnsafe(i, r) {
        if (assertSize(r), i = createBuffer(i, r < 0 ? 0 : checked(r) | 0), !Buffer.TYPED_ARRAY_SUPPORT)
            for (var n = 0; n < r; ++n) i[n] = 0;
        return i
    }
    Buffer.allocUnsafe = function(i) {
        return allocUnsafe(null, i)
    }, Buffer.allocUnsafeSlow = function(i) {
        return allocUnsafe(null, i)
    };

    function fromString(i, r, n) {
        if ((typeof n != "string" || n === "") && (n = "utf8"), !Buffer.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
        var s = byteLength(r, n) | 0;
        i = createBuffer(i, s);
        var a = i.write(r, n);
        return a !== s && (i = i.slice(0, a)), i
    }

    function fromArrayLike(i, r) {
        var n = r.length < 0 ? 0 : checked(r.length) | 0;
        i = createBuffer(i, n);
        for (var s = 0; s < n; s += 1) i[s] = r[s] & 255;
        return i
    }

    function fromArrayBuffer(i, r, n, s) {
        if (r.byteLength, n < 0 || r.byteLength < n) throw new RangeError("'offset' is out of bounds");
        if (r.byteLength < n + (s || 0)) throw new RangeError("'length' is out of bounds");
        return n === void 0 && s === void 0 ? r = new Uint8Array(r) : s === void 0 ? r = new Uint8Array(r, n) : r = new Uint8Array(r, n, s), Buffer.TYPED_ARRAY_SUPPORT ? (i = r, i.__proto__ = Buffer.prototype) : i = fromArrayLike(i, r), i
    }

    function fromObject(i, r) {
        if (internalIsBuffer(r)) {
            var n = checked(r.length) | 0;
            return i = createBuffer(i, n), i.length === 0 || r.copy(i, 0, 0, n), i
        }
        if (r) {
            if (typeof ArrayBuffer < "u" && r.buffer instanceof ArrayBuffer || "length" in r) return typeof r.length != "number" || isnan(r.length) ? createBuffer(i, 0) : fromArrayLike(i, r);
            if (r.type === "Buffer" && isArray(r.data)) return fromArrayLike(i, r.data)
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
    }

    function checked(i) {
        if (i >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        return i | 0
    }
    Buffer.isBuffer = isBuffer;

    function internalIsBuffer(i) {
        return !!(i != null && i._isBuffer)
    }
    Buffer.compare = function(r, n) {
        if (!internalIsBuffer(r) || !internalIsBuffer(n)) throw new TypeError("Arguments must be Buffers");
        if (r === n) return 0;
        for (var s = r.length, a = n.length, o = 0, c = Math.min(s, a); o < c; ++o)
            if (r[o] !== n[o]) {
                s = r[o], a = n[o];
                break
            } return s < a ? -1 : a < s ? 1 : 0
    }, Buffer.isEncoding = function(r) {
        switch (String(r).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, Buffer.concat = function(r, n) {
        if (!isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return Buffer.alloc(0);
        var s;
        if (n === void 0)
            for (n = 0, s = 0; s < r.length; ++s) n += r[s].length;
        var a = Buffer.allocUnsafe(n),
            o = 0;
        for (s = 0; s < r.length; ++s) {
            var c = r[s];
            if (!internalIsBuffer(c)) throw new TypeError('"list" argument must be an Array of Buffers');
            c.copy(a, o), o += c.length
        }
        return a
    };

    function byteLength(i, r) {
        if (internalIsBuffer(i)) return i.length;
        if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(i) || i instanceof ArrayBuffer)) return i.byteLength;
        typeof i != "string" && (i = "" + i);
        var n = i.length;
        if (n === 0) return 0;
        for (var s = !1;;) switch (r) {
            case "ascii":
            case "latin1":
            case "binary":
                return n;
            case "utf8":
            case "utf-8":
            case void 0:
                return utf8ToBytes(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return n * 2;
            case "hex":
                return n >>> 1;
            case "base64":
                return base64ToBytes(i).length;
            default:
                if (s) return utf8ToBytes(i).length;
                r = ("" + r).toLowerCase(), s = !0
        }
    }
    Buffer.byteLength = byteLength;

    function slowToString(i, r, n) {
        var s = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((n === void 0 || n > this.length) && (n = this.length), n <= 0) || (n >>>= 0, r >>>= 0, n <= r)) return "";
        for (i || (i = "utf8");;) switch (i) {
            case "hex":
                return hexSlice(this, r, n);
            case "utf8":
            case "utf-8":
                return utf8Slice(this, r, n);
            case "ascii":
                return asciiSlice(this, r, n);
            case "latin1":
            case "binary":
                return latin1Slice(this, r, n);
            case "base64":
                return base64Slice(this, r, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return utf16leSlice(this, r, n);
            default:
                if (s) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), s = !0
        }
    }
    Buffer.prototype._isBuffer = !0;

    function swap(i, r, n) {
        var s = i[r];
        i[r] = i[n], i[n] = s
    }
    Buffer.prototype.swap16 = function() {
        var r = this.length;
        if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var n = 0; n < r; n += 2) swap(this, n, n + 1);
        return this
    }, Buffer.prototype.swap32 = function() {
        var r = this.length;
        if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var n = 0; n < r; n += 4) swap(this, n, n + 3), swap(this, n + 1, n + 2);
        return this
    }, Buffer.prototype.swap64 = function() {
        var r = this.length;
        if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var n = 0; n < r; n += 8) swap(this, n, n + 7), swap(this, n + 1, n + 6), swap(this, n + 2, n + 5), swap(this, n + 3, n + 4);
        return this
    }, Buffer.prototype.toString = function() {
        var r = this.length | 0;
        return r === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, r) : slowToString.apply(this, arguments)
    }, Buffer.prototype.equals = function(r) {
        if (!internalIsBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : Buffer.compare(this, r) === 0
    }, Buffer.prototype.inspect = function() {
        var r = "",
            n = INSPECT_MAX_BYTES;
        return this.length > 0 && (r = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (r += " ... ")), "<Buffer " + r + ">"
    }, Buffer.prototype.compare = function(r, n, s, a, o) {
        if (!internalIsBuffer(r)) throw new TypeError("Argument must be a Buffer");
        if (n === void 0 && (n = 0), s === void 0 && (s = r ? r.length : 0), a === void 0 && (a = 0), o === void 0 && (o = this.length), n < 0 || s > r.length || a < 0 || o > this.length) throw new RangeError("out of range index");
        if (a >= o && n >= s) return 0;
        if (a >= o) return -1;
        if (n >= s) return 1;
        if (n >>>= 0, s >>>= 0, a >>>= 0, o >>>= 0, this === r) return 0;
        for (var c = o - a, p = s - n, h = Math.min(c, p), u = this.slice(a, o), l = r.slice(n, s), v = 0; v < h; ++v)
            if (u[v] !== l[v]) {
                c = u[v], p = l[v];
                break
            } return c < p ? -1 : p < c ? 1 : 0
    };

    function bidirectionalIndexOf(i, r, n, s, a) {
        if (i.length === 0) return -1;
        if (typeof n == "string" ? (s = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = a ? 0 : i.length - 1), n < 0 && (n = i.length + n), n >= i.length) {
            if (a) return -1;
            n = i.length - 1
        } else if (n < 0)
            if (a) n = 0;
            else return -1;
        if (typeof r == "string" && (r = Buffer.from(r, s)), internalIsBuffer(r)) return r.length === 0 ? -1 : arrayIndexOf(i, r, n, s, a);
        if (typeof r == "number") return r = r & 255, Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? a ? Uint8Array.prototype.indexOf.call(i, r, n) : Uint8Array.prototype.lastIndexOf.call(i, r, n) : arrayIndexOf(i, [r], n, s, a);
        throw new TypeError("val must be string, number or Buffer")
    }

    function arrayIndexOf(i, r, n, s, a) {
        var o = 1,
            c = i.length,
            p = r.length;
        if (s !== void 0 && (s = String(s).toLowerCase(), s === "ucs2" || s === "ucs-2" || s === "utf16le" || s === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, c /= 2, p /= 2, n /= 2
        }

        function h(m, S) {
            return o === 1 ? m[S] : m.readUInt16BE(S * o)
        }
        var u;
        if (a) {
            var l = -1;
            for (u = n; u < c; u++)
                if (h(i, u) === h(r, l === -1 ? 0 : u - l)) {
                    if (l === -1 && (l = u), u - l + 1 === p) return l * o
                } else l !== -1 && (u -= u - l), l = -1
        } else
            for (n + p > c && (n = c - p), u = n; u >= 0; u--) {
                for (var v = !0, w = 0; w < p; w++)
                    if (h(i, u + w) !== h(r, w)) {
                        v = !1;
                        break
                    } if (v) return u
            }
        return -1
    }
    Buffer.prototype.includes = function(r, n, s) {
        return this.indexOf(r, n, s) !== -1
    }, Buffer.prototype.indexOf = function(r, n, s) {
        return bidirectionalIndexOf(this, r, n, s, !0)
    }, Buffer.prototype.lastIndexOf = function(r, n, s) {
        return bidirectionalIndexOf(this, r, n, s, !1)
    };

    function hexWrite(i, r, n, s) {
        n = Number(n) || 0;
        var a = i.length - n;
        s ? (s = Number(s), s > a && (s = a)) : s = a;
        var o = r.length;
        if (o % 2 !== 0) throw new TypeError("Invalid hex string");
        s > o / 2 && (s = o / 2);
        for (var c = 0; c < s; ++c) {
            var p = parseInt(r.substr(c * 2, 2), 16);
            if (isNaN(p)) return c;
            i[n + c] = p
        }
        return c
    }

    function utf8Write(i, r, n, s) {
        return blitBuffer(utf8ToBytes(r, i.length - n), i, n, s)
    }

    function asciiWrite(i, r, n, s) {
        return blitBuffer(asciiToBytes(r), i, n, s)
    }

    function latin1Write(i, r, n, s) {
        return asciiWrite(i, r, n, s)
    }

    function base64Write(i, r, n, s) {
        return blitBuffer(base64ToBytes(r), i, n, s)
    }

    function ucs2Write(i, r, n, s) {
        return blitBuffer(utf16leToBytes(r, i.length - n), i, n, s)
    }
    Buffer.prototype.write = function(r, n, s, a) {
        if (n === void 0) a = "utf8", s = this.length, n = 0;
        else if (s === void 0 && typeof n == "string") a = n, s = this.length, n = 0;
        else if (isFinite(n)) n = n | 0, isFinite(s) ? (s = s | 0, a === void 0 && (a = "utf8")) : (a = s, s = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        var o = this.length - n;
        if ((s === void 0 || s > o) && (s = o), r.length > 0 && (s < 0 || n < 0) || n > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        a || (a = "utf8");
        for (var c = !1;;) switch (a) {
            case "hex":
                return hexWrite(this, r, n, s);
            case "utf8":
            case "utf-8":
                return utf8Write(this, r, n, s);
            case "ascii":
                return asciiWrite(this, r, n, s);
            case "latin1":
            case "binary":
                return latin1Write(this, r, n, s);
            case "base64":
                return base64Write(this, r, n, s);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ucs2Write(this, r, n, s);
            default:
                if (c) throw new TypeError("Unknown encoding: " + a);
                a = ("" + a).toLowerCase(), c = !0
        }
    }, Buffer.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function base64Slice(i, r, n) {
        return r === 0 && n === i.length ? fromByteArray(i) : fromByteArray(i.slice(r, n))
    }

    function utf8Slice(i, r, n) {
        n = Math.min(i.length, n);
        for (var s = [], a = r; a < n;) {
            var o = i[a],
                c = null,
                p = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (a + p <= n) {
                var h, u, l, v;
                switch (p) {
                    case 1:
                        o < 128 && (c = o);
                        break;
                    case 2:
                        h = i[a + 1], (h & 192) === 128 && (v = (o & 31) << 6 | h & 63, v > 127 && (c = v));
                        break;
                    case 3:
                        h = i[a + 1], u = i[a + 2], (h & 192) === 128 && (u & 192) === 128 && (v = (o & 15) << 12 | (h & 63) << 6 | u & 63, v > 2047 && (v < 55296 || v > 57343) && (c = v));
                        break;
                    case 4:
                        h = i[a + 1], u = i[a + 2], l = i[a + 3], (h & 192) === 128 && (u & 192) === 128 && (l & 192) === 128 && (v = (o & 15) << 18 | (h & 63) << 12 | (u & 63) << 6 | l & 63, v > 65535 && v < 1114112 && (c = v))
                }
            }
            c === null ? (c = 65533, p = 1) : c > 65535 && (c -= 65536, s.push(c >>> 10 & 1023 | 55296), c = 56320 | c & 1023), s.push(c), a += p
        }
        return decodeCodePointsArray(s)
    }
    var MAX_ARGUMENTS_LENGTH = 4096;

    function decodeCodePointsArray(i) {
        var r = i.length;
        if (r <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, i);
        for (var n = "", s = 0; s < r;) n += String.fromCharCode.apply(String, i.slice(s, s += MAX_ARGUMENTS_LENGTH));
        return n
    }

    function asciiSlice(i, r, n) {
        var s = "";
        n = Math.min(i.length, n);
        for (var a = r; a < n; ++a) s += String.fromCharCode(i[a] & 127);
        return s
    }

    function latin1Slice(i, r, n) {
        var s = "";
        n = Math.min(i.length, n);
        for (var a = r; a < n; ++a) s += String.fromCharCode(i[a]);
        return s
    }

    function hexSlice(i, r, n) {
        var s = i.length;
        (!r || r < 0) && (r = 0), (!n || n < 0 || n > s) && (n = s);
        for (var a = "", o = r; o < n; ++o) a += toHex(i[o]);
        return a
    }

    function utf16leSlice(i, r, n) {
        for (var s = i.slice(r, n), a = "", o = 0; o < s.length; o += 2) a += String.fromCharCode(s[o] + s[o + 1] * 256);
        return a
    }
    Buffer.prototype.slice = function(r, n) {
        var s = this.length;
        r = ~~r, n = n === void 0 ? s : ~~n, r < 0 ? (r += s, r < 0 && (r = 0)) : r > s && (r = s), n < 0 ? (n += s, n < 0 && (n = 0)) : n > s && (n = s), n < r && (n = r);
        var a;
        if (Buffer.TYPED_ARRAY_SUPPORT) a = this.subarray(r, n), a.__proto__ = Buffer.prototype;
        else {
            var o = n - r;
            a = new Buffer(o, void 0);
            for (var c = 0; c < o; ++c) a[c] = this[c + r]
        }
        return a
    };

    function checkOffset(i, r, n) {
        if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > n) throw new RangeError("Trying to access beyond buffer length")
    }
    Buffer.prototype.readUIntLE = function(r, n, s) {
        r = r | 0, n = n | 0, s || checkOffset(r, n, this.length);
        for (var a = this[r], o = 1, c = 0; ++c < n && (o *= 256);) a += this[r + c] * o;
        return a
    }, Buffer.prototype.readUIntBE = function(r, n, s) {
        r = r | 0, n = n | 0, s || checkOffset(r, n, this.length);
        for (var a = this[r + --n], o = 1; n > 0 && (o *= 256);) a += this[r + --n] * o;
        return a
    }, Buffer.prototype.readUInt8 = function(r, n) {
        return n || checkOffset(r, 1, this.length), this[r]
    }, Buffer.prototype.readUInt16LE = function(r, n) {
        return n || checkOffset(r, 2, this.length), this[r] | this[r + 1] << 8
    }, Buffer.prototype.readUInt16BE = function(r, n) {
        return n || checkOffset(r, 2, this.length), this[r] << 8 | this[r + 1]
    }, Buffer.prototype.readUInt32LE = function(r, n) {
        return n || checkOffset(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216
    }, Buffer.prototype.readUInt32BE = function(r, n) {
        return n || checkOffset(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3])
    }, Buffer.prototype.readIntLE = function(r, n, s) {
        r = r | 0, n = n | 0, s || checkOffset(r, n, this.length);
        for (var a = this[r], o = 1, c = 0; ++c < n && (o *= 256);) a += this[r + c] * o;
        return o *= 128, a >= o && (a -= Math.pow(2, 8 * n)), a
    }, Buffer.prototype.readIntBE = function(r, n, s) {
        r = r | 0, n = n | 0, s || checkOffset(r, n, this.length);
        for (var a = n, o = 1, c = this[r + --a]; a > 0 && (o *= 256);) c += this[r + --a] * o;
        return o *= 128, c >= o && (c -= Math.pow(2, 8 * n)), c
    }, Buffer.prototype.readInt8 = function(r, n) {
        return n || checkOffset(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r]
    }, Buffer.prototype.readInt16LE = function(r, n) {
        n || checkOffset(r, 2, this.length);
        var s = this[r] | this[r + 1] << 8;
        return s & 32768 ? s | 4294901760 : s
    }, Buffer.prototype.readInt16BE = function(r, n) {
        n || checkOffset(r, 2, this.length);
        var s = this[r + 1] | this[r] << 8;
        return s & 32768 ? s | 4294901760 : s
    }, Buffer.prototype.readInt32LE = function(r, n) {
        return n || checkOffset(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24
    }, Buffer.prototype.readInt32BE = function(r, n) {
        return n || checkOffset(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]
    }, Buffer.prototype.readFloatLE = function(r, n) {
        return n || checkOffset(r, 4, this.length), read(this, r, !0, 23, 4)
    }, Buffer.prototype.readFloatBE = function(r, n) {
        return n || checkOffset(r, 4, this.length), read(this, r, !1, 23, 4)
    }, Buffer.prototype.readDoubleLE = function(r, n) {
        return n || checkOffset(r, 8, this.length), read(this, r, !0, 52, 8)
    }, Buffer.prototype.readDoubleBE = function(r, n) {
        return n || checkOffset(r, 8, this.length), read(this, r, !1, 52, 8)
    };

    function checkInt(i, r, n, s, a, o) {
        if (!internalIsBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > a || r < o) throw new RangeError('"value" argument is out of bounds');
        if (n + s > i.length) throw new RangeError("Index out of range")
    }
    Buffer.prototype.writeUIntLE = function(r, n, s, a) {
        if (r = +r, n = n | 0, s = s | 0, !a) {
            var o = Math.pow(2, 8 * s) - 1;
            checkInt(this, r, n, s, o, 0)
        }
        var c = 1,
            p = 0;
        for (this[n] = r & 255; ++p < s && (c *= 256);) this[n + p] = r / c & 255;
        return n + s
    }, Buffer.prototype.writeUIntBE = function(r, n, s, a) {
        if (r = +r, n = n | 0, s = s | 0, !a) {
            var o = Math.pow(2, 8 * s) - 1;
            checkInt(this, r, n, s, o, 0)
        }
        var c = s - 1,
            p = 1;
        for (this[n + c] = r & 255; --c >= 0 && (p *= 256);) this[n + c] = r / p & 255;
        return n + s
    }, Buffer.prototype.writeUInt8 = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), this[n] = r & 255, n + 1
    };

    function objectWriteUInt16(i, r, n, s) {
        r < 0 && (r = 65535 + r + 1);
        for (var a = 0, o = Math.min(i.length - n, 2); a < o; ++a) i[n + a] = (r & 255 << 8 * (s ? a : 1 - a)) >>> (s ? a : 1 - a) * 8
    }
    Buffer.prototype.writeUInt16LE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r & 255, this[n + 1] = r >>> 8) : objectWriteUInt16(this, r, n, !0), n + 2
    }, Buffer.prototype.writeUInt16BE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r >>> 8, this[n + 1] = r & 255) : objectWriteUInt16(this, r, n, !1), n + 2
    };

    function objectWriteUInt32(i, r, n, s) {
        r < 0 && (r = 4294967295 + r + 1);
        for (var a = 0, o = Math.min(i.length - n, 4); a < o; ++a) i[n + a] = r >>> (s ? a : 3 - a) * 8 & 255
    }
    Buffer.prototype.writeUInt32LE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[n + 3] = r >>> 24, this[n + 2] = r >>> 16, this[n + 1] = r >>> 8, this[n] = r & 255) : objectWriteUInt32(this, r, n, !0), n + 4
    }, Buffer.prototype.writeUInt32BE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r >>> 24, this[n + 1] = r >>> 16, this[n + 2] = r >>> 8, this[n + 3] = r & 255) : objectWriteUInt32(this, r, n, !1), n + 4
    }, Buffer.prototype.writeIntLE = function(r, n, s, a) {
        if (r = +r, n = n | 0, !a) {
            var o = Math.pow(2, 8 * s - 1);
            checkInt(this, r, n, s, o - 1, -o)
        }
        var c = 0,
            p = 1,
            h = 0;
        for (this[n] = r & 255; ++c < s && (p *= 256);) r < 0 && h === 0 && this[n + c - 1] !== 0 && (h = 1), this[n + c] = (r / p >> 0) - h & 255;
        return n + s
    }, Buffer.prototype.writeIntBE = function(r, n, s, a) {
        if (r = +r, n = n | 0, !a) {
            var o = Math.pow(2, 8 * s - 1);
            checkInt(this, r, n, s, o - 1, -o)
        }
        var c = s - 1,
            p = 1,
            h = 0;
        for (this[n + c] = r & 255; --c >= 0 && (p *= 256);) r < 0 && h === 0 && this[n + c + 1] !== 0 && (h = 1), this[n + c] = (r / p >> 0) - h & 255;
        return n + s
    }, Buffer.prototype.writeInt8 = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (r = Math.floor(r)), r < 0 && (r = 255 + r + 1), this[n] = r & 255, n + 1
    }, Buffer.prototype.writeInt16LE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r & 255, this[n + 1] = r >>> 8) : objectWriteUInt16(this, r, n, !0), n + 2
    }, Buffer.prototype.writeInt16BE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r >>> 8, this[n + 1] = r & 255) : objectWriteUInt16(this, r, n, !1), n + 2
    }, Buffer.prototype.writeInt32LE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r & 255, this[n + 1] = r >>> 8, this[n + 2] = r >>> 16, this[n + 3] = r >>> 24) : objectWriteUInt32(this, r, n, !0), n + 4
    }, Buffer.prototype.writeInt32BE = function(r, n, s) {
        return r = +r, n = n | 0, s || checkInt(this, r, n, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[n] = r >>> 24, this[n + 1] = r >>> 16, this[n + 2] = r >>> 8, this[n + 3] = r & 255) : objectWriteUInt32(this, r, n, !1), n + 4
    };

    function checkIEEE754(i, r, n, s, a, o) {
        if (n + s > i.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("Index out of range")
    }

    function writeFloat(i, r, n, s, a) {
        return a || checkIEEE754(i, r, n, 4), write(i, r, n, s, 23, 4), n + 4
    }
    Buffer.prototype.writeFloatLE = function(r, n, s) {
        return writeFloat(this, r, n, !0, s)
    }, Buffer.prototype.writeFloatBE = function(r, n, s) {
        return writeFloat(this, r, n, !1, s)
    };

    function writeDouble(i, r, n, s, a) {
        return a || checkIEEE754(i, r, n, 8), write(i, r, n, s, 52, 8), n + 8
    }
    Buffer.prototype.writeDoubleLE = function(r, n, s) {
        return writeDouble(this, r, n, !0, s)
    }, Buffer.prototype.writeDoubleBE = function(r, n, s) {
        return writeDouble(this, r, n, !1, s)
    }, Buffer.prototype.copy = function(r, n, s, a) {
        if (s || (s = 0), !a && a !== 0 && (a = this.length), n >= r.length && (n = r.length), n || (n = 0), a > 0 && a < s && (a = s), a === s || r.length === 0 || this.length === 0) return 0;
        if (n < 0) throw new RangeError("targetStart out of bounds");
        if (s < 0 || s >= this.length) throw new RangeError("sourceStart out of bounds");
        if (a < 0) throw new RangeError("sourceEnd out of bounds");
        a > this.length && (a = this.length), r.length - n < a - s && (a = r.length - n + s);
        var o = a - s,
            c;
        if (this === r && s < n && n < a)
            for (c = o - 1; c >= 0; --c) r[c + n] = this[c + s];
        else if (o < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
            for (c = 0; c < o; ++c) r[c + n] = this[c + s];
        else Uint8Array.prototype.set.call(r, this.subarray(s, s + o), n);
        return o
    }, Buffer.prototype.fill = function(r, n, s, a) {
        if (typeof r == "string") {
            if (typeof n == "string" ? (a = n, n = 0, s = this.length) : typeof s == "string" && (a = s, s = this.length), r.length === 1) {
                var o = r.charCodeAt(0);
                o < 256 && (r = o)
            }
            if (a !== void 0 && typeof a != "string") throw new TypeError("encoding must be a string");
            if (typeof a == "string" && !Buffer.isEncoding(a)) throw new TypeError("Unknown encoding: " + a)
        } else typeof r == "number" && (r = r & 255);
        if (n < 0 || this.length < n || this.length < s) throw new RangeError("Out of range index");
        if (s <= n) return this;
        n = n >>> 0, s = s === void 0 ? this.length : s >>> 0, r || (r = 0);
        var c;
        if (typeof r == "number")
            for (c = n; c < s; ++c) this[c] = r;
        else {
            var p = internalIsBuffer(r) ? r : utf8ToBytes(new Buffer(r, a).toString()),
                h = p.length;
            for (c = 0; c < s - n; ++c) this[c + n] = p[c % h]
        }
        return this
    };
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(i) {
        if (i = stringtrim(i).replace(INVALID_BASE64_RE, ""), i.length < 2) return "";
        for (; i.length % 4 !== 0;) i = i + "=";
        return i
    }

    function stringtrim(i) {
        return i.trim ? i.trim() : i.replace(/^\s+|\s+$/g, "")
    }

    function toHex(i) {
        return i < 16 ? "0" + i.toString(16) : i.toString(16)
    }

    function utf8ToBytes(i, r) {
        r = r || 1 / 0;
        for (var n, s = i.length, a = null, o = [], c = 0; c < s; ++c) {
            if (n = i.charCodeAt(c), n > 55295 && n < 57344) {
                if (!a) {
                    if (n > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    } else if (c + 1 === s) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    }
                    a = n;
                    continue
                }
                if (n < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), a = n;
                    continue
                }
                n = (a - 55296 << 10 | n - 56320) + 65536
            } else a && (r -= 3) > -1 && o.push(239, 191, 189);
            if (a = null, n < 128) {
                if ((r -= 1) < 0) break;
                o.push(n)
            } else if (n < 2048) {
                if ((r -= 2) < 0) break;
                o.push(n >> 6 | 192, n & 63 | 128)
            } else if (n < 65536) {
                if ((r -= 3) < 0) break;
                o.push(n >> 12 | 224, n >> 6 & 63 | 128, n & 63 | 128)
            } else if (n < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, n & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return o
    }

    function asciiToBytes(i) {
        for (var r = [], n = 0; n < i.length; ++n) r.push(i.charCodeAt(n) & 255);
        return r
    }

    function utf16leToBytes(i, r) {
        for (var n, s, a, o = [], c = 0; c < i.length && !((r -= 2) < 0); ++c) n = i.charCodeAt(c), s = n >> 8, a = n % 256, o.push(a), o.push(s);
        return o
    }

    function base64ToBytes(i) {
        return toByteArray(base64clean(i))
    }

    function blitBuffer(i, r, n, s) {
        for (var a = 0; a < s && !(a + n >= r.length || a >= i.length); ++a) r[a + n] = i[a];
        return a
    }

    function isnan(i) {
        return i !== i
    }

    function isBuffer(i) {
        return i != null && (!!i._isBuffer || isFastBuffer(i) || isSlowBuffer(i))
    }

    function isFastBuffer(i) {
        return !!i.constructor && typeof i.constructor.isBuffer == "function" && i.constructor.isBuffer(i)
    }

    function isSlowBuffer(i) {
        return typeof i.readFloatLE == "function" && typeof i.slice == "function" && isFastBuffer(i.slice(0, 0))
    }
    var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")
    }

    function unwrapExports(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
    }

    function createCommonjsModule(i, r) {
        return r = {
            exports: {}
        }, i(r, r.exports), r.exports
    }
    var require$$4 = {},
        pdf = createCommonjsModule(function(module, exports) {
            (function(r, n) {
                module.exports = n()
            })(commonjsGlobal, function() {
                return function(i) {
                    var r = {};

                    function n(s) {
                        if (r[s]) return r[s].exports;
                        var a = r[s] = {
                            i: s,
                            l: !1,
                            exports: {}
                        };
                        return i[s].call(a.exports, a, a.exports, n), a.l = !0, a.exports
                    }
                    return n.m = i, n.c = r, n.d = function(s, a, o) {
                        n.o(s, a) || Object.defineProperty(s, a, {
                            enumerable: !0,
                            get: o
                        })
                    }, n.r = function(s) {
                        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                            value: "Module"
                        }), Object.defineProperty(s, "__esModule", {
                            value: !0
                        })
                    }, n.t = function(s, a) {
                        if (a & 1 && (s = n(s)), a & 8 || a & 4 && typeof s == "object" && s && s.__esModule) return s;
                        var o = Object.create(null);
                        if (n.r(o), Object.defineProperty(o, "default", {
                                enumerable: !0,
                                value: s
                            }), a & 2 && typeof s != "string")
                            for (var c in s) n.d(o, c, function(p) {
                                return s[p]
                            }.bind(null, c));
                        return o
                    }, n.n = function(s) {
                        var a = s && s.__esModule ? function() {
                            return s.default
                        } : function() {
                            return s
                        };
                        return n.d(a, "a", a), a
                    }, n.o = function(s, a) {
                        return Object.prototype.hasOwnProperty.call(s, a)
                    }, n.p = "", n(n.s = 0)
                }([function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), Object.defineProperty(r, "addLinkAttributes", {
                        enumerable: !0,
                        get: function() {
                            return s.addLinkAttributes
                        }
                    }), Object.defineProperty(r, "getFilenameFromUrl", {
                        enumerable: !0,
                        get: function() {
                            return s.getFilenameFromUrl
                        }
                    }), Object.defineProperty(r, "LinkTarget", {
                        enumerable: !0,
                        get: function() {
                            return s.LinkTarget
                        }
                    }), Object.defineProperty(r, "loadScript", {
                        enumerable: !0,
                        get: function() {
                            return s.loadScript
                        }
                    }), Object.defineProperty(r, "PDFDateString", {
                        enumerable: !0,
                        get: function() {
                            return s.PDFDateString
                        }
                    }), Object.defineProperty(r, "RenderingCancelledException", {
                        enumerable: !0,
                        get: function() {
                            return s.RenderingCancelledException
                        }
                    }), Object.defineProperty(r, "build", {
                        enumerable: !0,
                        get: function() {
                            return a.build
                        }
                    }), Object.defineProperty(r, "getDocument", {
                        enumerable: !0,
                        get: function() {
                            return a.getDocument
                        }
                    }), Object.defineProperty(r, "LoopbackPort", {
                        enumerable: !0,
                        get: function() {
                            return a.LoopbackPort
                        }
                    }), Object.defineProperty(r, "PDFDataRangeTransport", {
                        enumerable: !0,
                        get: function() {
                            return a.PDFDataRangeTransport
                        }
                    }), Object.defineProperty(r, "PDFWorker", {
                        enumerable: !0,
                        get: function() {
                            return a.PDFWorker
                        }
                    }), Object.defineProperty(r, "version", {
                        enumerable: !0,
                        get: function() {
                            return a.version
                        }
                    }), Object.defineProperty(r, "CMapCompressionType", {
                        enumerable: !0,
                        get: function() {
                            return o.CMapCompressionType
                        }
                    }), Object.defineProperty(r, "createObjectURL", {
                        enumerable: !0,
                        get: function() {
                            return o.createObjectURL
                        }
                    }), Object.defineProperty(r, "createPromiseCapability", {
                        enumerable: !0,
                        get: function() {
                            return o.createPromiseCapability
                        }
                    }), Object.defineProperty(r, "createValidAbsoluteUrl", {
                        enumerable: !0,
                        get: function() {
                            return o.createValidAbsoluteUrl
                        }
                    }), Object.defineProperty(r, "InvalidPDFException", {
                        enumerable: !0,
                        get: function() {
                            return o.InvalidPDFException
                        }
                    }), Object.defineProperty(r, "MissingPDFException", {
                        enumerable: !0,
                        get: function() {
                            return o.MissingPDFException
                        }
                    }), Object.defineProperty(r, "OPS", {
                        enumerable: !0,
                        get: function() {
                            return o.OPS
                        }
                    }), Object.defineProperty(r, "PasswordResponses", {
                        enumerable: !0,
                        get: function() {
                            return o.PasswordResponses
                        }
                    }), Object.defineProperty(r, "PermissionFlag", {
                        enumerable: !0,
                        get: function() {
                            return o.PermissionFlag
                        }
                    }), Object.defineProperty(r, "removeNullCharacters", {
                        enumerable: !0,
                        get: function() {
                            return o.removeNullCharacters
                        }
                    }), Object.defineProperty(r, "shadow", {
                        enumerable: !0,
                        get: function() {
                            return o.shadow
                        }
                    }), Object.defineProperty(r, "UnexpectedResponseException", {
                        enumerable: !0,
                        get: function() {
                            return o.UnexpectedResponseException
                        }
                    }), Object.defineProperty(r, "UNSUPPORTED_FEATURES", {
                        enumerable: !0,
                        get: function() {
                            return o.UNSUPPORTED_FEATURES
                        }
                    }), Object.defineProperty(r, "Util", {
                        enumerable: !0,
                        get: function() {
                            return o.Util
                        }
                    }), Object.defineProperty(r, "VerbosityLevel", {
                        enumerable: !0,
                        get: function() {
                            return o.VerbosityLevel
                        }
                    }), Object.defineProperty(r, "AnnotationLayer", {
                        enumerable: !0,
                        get: function() {
                            return c.AnnotationLayer
                        }
                    }), Object.defineProperty(r, "apiCompatibilityParams", {
                        enumerable: !0,
                        get: function() {
                            return p.apiCompatibilityParams
                        }
                    }), Object.defineProperty(r, "GlobalWorkerOptions", {
                        enumerable: !0,
                        get: function() {
                            return h.GlobalWorkerOptions
                        }
                    }), Object.defineProperty(r, "renderTextLayer", {
                        enumerable: !0,
                        get: function() {
                            return u.renderTextLayer
                        }
                    }), Object.defineProperty(r, "SVGGraphics", {
                        enumerable: !0,
                        get: function() {
                            return l.SVGGraphics
                        }
                    });
                    var s = n(1),
                        a = n(5),
                        o = n(2),
                        c = n(16),
                        p = n(7),
                        h = n(10),
                        u = n(17),
                        l = n(18); {
                        const {
                            isNodeJS: v
                        } = n(4);
                        if (v) {
                            const w = n(19).PDFNodeStream;
                            (0, a.setPDFNetworkStreamFactory)(m => new w(m))
                        } else {
                            const w = n(22).PDFNetworkStream;
                            let m;
                            (0, s.isFetchSupported)() && (m = n(23).PDFFetchStream), (0, a.setPDFNetworkStreamFactory)(S => m && (0, s.isValidFetchUrl)(S.url) ? new m(S) : new w(S))
                        }
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.addLinkAttributes = w, r.getFilenameFromUrl = m, r.isFetchSupported = C, r.isValidFetchUrl = O, r.loadScript = x, r.deprecated = I, r.PDFDateString = r.StatTimer = r.DOMSVGFactory = r.DOMCMapReaderFactory = r.DOMCanvasFactory = r.DEFAULT_LINK_REL = r.LinkTarget = r.RenderingCancelledException = r.PageViewport = void 0;
                    var s = n(2);
                    const a = "noopener noreferrer nofollow";
                    r.DEFAULT_LINK_REL = a;
                    const o = "http://www.w3.org/2000/svg";
                    class c {
                        create(d, g) {
                            if (d <= 0 || g <= 0) throw new Error("Invalid canvas size");
                            const E = document.createElement("canvas"),
                                T = E.getContext("2d");
                            return E.width = d, E.height = g, {
                                canvas: E,
                                context: T
                            }
                        }
                        reset(d, g, E) {
                            if (!d.canvas) throw new Error("Canvas is not specified");
                            if (g <= 0 || E <= 0) throw new Error("Invalid canvas size");
                            d.canvas.width = g, d.canvas.height = E
                        }
                        destroy(d) {
                            if (!d.canvas) throw new Error("Canvas is not specified");
                            d.canvas.width = 0, d.canvas.height = 0, d.canvas = null, d.context = null
                        }
                    }
                    r.DOMCanvasFactory = c;
                    class p {
                        constructor({
                            baseUrl: d = null,
                            isCompressed: g = !1
                        }) {
                            this.baseUrl = d, this.isCompressed = g
                        }
                        async fetch({
                            name: d
                        }) {
                            if (!this.baseUrl) throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                            if (!d) throw new Error("CMap name must be specified.");
                            const g = this.baseUrl + d + (this.isCompressed ? ".bcmap" : ""),
                                E = this.isCompressed ? s.CMapCompressionType.BINARY : s.CMapCompressionType.NONE;
                            return C() && O(g, document.baseURI) ? fetch(g).then(async T => {
                                if (!T.ok) throw new Error(T.statusText);
                                let N;
                                return this.isCompressed ? N = new Uint8Array(await T.arrayBuffer()) : N = (0, s.stringToBytes)(await T.text()), {
                                    cMapData: N,
                                    compressionType: E
                                }
                            }).catch(T => {
                                throw new Error(`Unable to load ${this.isCompressed?"binary ":""}CMap at: ${g}`)
                            }) : new Promise((T, N) => {
                                const P = new XMLHttpRequest;
                                P.open("GET", g, !0), this.isCompressed && (P.responseType = "arraybuffer"), P.onreadystatechange = () => {
                                    if (P.readyState === XMLHttpRequest.DONE) {
                                        if (P.status === 200 || P.status === 0) {
                                            let U;
                                            if (this.isCompressed && P.response ? U = new Uint8Array(P.response) : !this.isCompressed && P.responseText && (U = (0, s.stringToBytes)(P.responseText)), U) {
                                                T({
                                                    cMapData: U,
                                                    compressionType: E
                                                });
                                                return
                                            }
                                        }
                                        N(new Error(P.statusText))
                                    }
                                }, P.send(null)
                            }).catch(T => {
                                throw new Error(`Unable to load ${this.isCompressed?"binary ":""}CMap at: ${g}`)
                            })
                        }
                    }
                    r.DOMCMapReaderFactory = p;
                    class h {
                        create(d, g) {
                            (0, s.assert)(d > 0 && g > 0, "Invalid SVG dimensions");
                            const E = document.createElementNS(o, "svg:svg");
                            return E.setAttribute("version", "1.1"), E.setAttribute("width", d + "px"), E.setAttribute("height", g + "px"), E.setAttribute("preserveAspectRatio", "none"), E.setAttribute("viewBox", "0 0 " + d + " " + g), E
                        }
                        createElement(d) {
                            return (0, s.assert)(typeof d == "string", "Invalid SVG element type"), document.createElementNS(o, d)
                        }
                    }
                    r.DOMSVGFactory = h;
                    class u {
                        constructor({
                            viewBox: d,
                            scale: g,
                            rotation: E,
                            offsetX: T = 0,
                            offsetY: N = 0,
                            dontFlip: P = !1
                        }) {
                            this.viewBox = d, this.scale = g, this.rotation = E, this.offsetX = T, this.offsetY = N;
                            const U = (d[2] + d[0]) / 2,
                                F = (d[3] + d[1]) / 2;
                            let L, G, M, _;
                            switch (E = E % 360, E = E < 0 ? E + 360 : E, E) {
                                case 180:
                                    L = -1, G = 0, M = 0, _ = 1;
                                    break;
                                case 90:
                                    L = 0, G = 1, M = 1, _ = 0;
                                    break;
                                case 270:
                                    L = 0, G = -1, M = -1, _ = 0;
                                    break;
                                case 0:
                                    L = 1, G = 0, M = 0, _ = -1;
                                    break;
                                default:
                                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.")
                            }
                            P && (M = -M, _ = -_);
                            let A, y, k, R;
                            L === 0 ? (A = Math.abs(F - d[1]) * g + T, y = Math.abs(U - d[0]) * g + N, k = Math.abs(d[3] - d[1]) * g, R = Math.abs(d[2] - d[0]) * g) : (A = Math.abs(U - d[0]) * g + T, y = Math.abs(F - d[1]) * g + N, k = Math.abs(d[2] - d[0]) * g, R = Math.abs(d[3] - d[1]) * g), this.transform = [L * g, G * g, M * g, _ * g, A - L * g * U - M * g * F, y - G * g * U - _ * g * F], this.width = k, this.height = R
                        }
                        clone({
                            scale: d = this.scale,
                            rotation: g = this.rotation,
                            offsetX: E = this.offsetX,
                            offsetY: T = this.offsetY,
                            dontFlip: N = !1
                        } = {}) {
                            return new u({
                                viewBox: this.viewBox.slice(),
                                scale: d,
                                rotation: g,
                                offsetX: E,
                                offsetY: T,
                                dontFlip: N
                            })
                        }
                        convertToViewportPoint(d, g) {
                            return s.Util.applyTransform([d, g], this.transform)
                        }
                        convertToViewportRectangle(d) {
                            const g = s.Util.applyTransform([d[0], d[1]], this.transform),
                                E = s.Util.applyTransform([d[2], d[3]], this.transform);
                            return [g[0], g[1], E[0], E[1]]
                        }
                        convertToPdfPoint(d, g) {
                            return s.Util.applyInverseTransform([d, g], this.transform)
                        }
                    }
                    r.PageViewport = u;
                    class l extends s.BaseException {
                        constructor(d, g) {
                            super(d), this.type = g
                        }
                    }
                    r.RenderingCancelledException = l;
                    const v = {
                        NONE: 0,
                        SELF: 1,
                        BLANK: 2,
                        PARENT: 3,
                        TOP: 4
                    };
                    r.LinkTarget = v;

                    function w(f, {
                        url: d,
                        target: g,
                        rel: E,
                        enabled: T = !0
                    } = {}) {
                        (0, s.assert)(d && typeof d == "string", 'addLinkAttributes: A valid "url" parameter must provided.');
                        const N = (0, s.removeNullCharacters)(d);
                        T ? f.href = f.title = N : (f.href = "", f.title = `Disabled: ${N}`, f.onclick = () => !1);
                        let P = "";
                        switch (g) {
                            case v.NONE:
                                break;
                            case v.SELF:
                                P = "_self";
                                break;
                            case v.BLANK:
                                P = "_blank";
                                break;
                            case v.PARENT:
                                P = "_parent";
                                break;
                            case v.TOP:
                                P = "_top";
                                break
                        }
                        f.target = P, f.rel = typeof E == "string" ? E : a
                    }

                    function m(f) {
                        const d = f.indexOf("#"),
                            g = f.indexOf("?"),
                            E = Math.min(d > 0 ? d : f.length, g > 0 ? g : f.length);
                        return f.substring(f.lastIndexOf("/", E) + 1, E)
                    }
                    class S {
                        constructor() {
                            this.started = Object.create(null), this.times = []
                        }
                        time(d) {
                            d in this.started && (0, s.warn)(`Timer is already running for ${d}`), this.started[d] = Date.now()
                        }
                        timeEnd(d) {
                            d in this.started || (0, s.warn)(`Timer has not been started for ${d}`), this.times.push({
                                name: d,
                                start: this.started[d],
                                end: Date.now()
                            }), delete this.started[d]
                        }
                        toString() {
                            const d = [];
                            let g = 0;
                            for (const E of this.times) {
                                const T = E.name;
                                T.length > g && (g = T.length)
                            }
                            for (const E of this.times) {
                                const T = E.end - E.start;
                                d.push(`${E.name.padEnd(g)} ${T}ms
`)
                            }
                            return d.join("")
                        }
                    }
                    r.StatTimer = S;

                    function C() {
                        return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype && typeof ReadableStream < "u"
                    }

                    function O(f, d) {
                        try {
                            const {
                                protocol: g
                            } = d ? new URL(f, d) : new URL(f);
                            return g === "http:" || g === "https:"
                        } catch {
                            return !1
                        }
                    }

                    function x(f) {
                        return new Promise((d, g) => {
                            const E = document.createElement("script");
                            E.src = f, E.onload = d, E.onerror = function() {
                                g(new Error(`Cannot load script at: ${E.src}`))
                            }, (document.head || document.documentElement).appendChild(E)
                        })
                    }

                    function I(f) {
                        console.log("Deprecated API usage: " + f)
                    }
                    let B;
                    class b {
                        static toDateObject(d) {
                            if (!d || !(0, s.isString)(d)) return null;
                            B || (B = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                            const g = B.exec(d);
                            if (!g) return null;
                            const E = parseInt(g[1], 10);
                            let T = parseInt(g[2], 10);
                            T = T >= 1 && T <= 12 ? T - 1 : 0;
                            let N = parseInt(g[3], 10);
                            N = N >= 1 && N <= 31 ? N : 1;
                            let P = parseInt(g[4], 10);
                            P = P >= 0 && P <= 23 ? P : 0;
                            let U = parseInt(g[5], 10);
                            U = U >= 0 && U <= 59 ? U : 0;
                            let F = parseInt(g[6], 10);
                            F = F >= 0 && F <= 59 ? F : 0;
                            const L = g[7] || "Z";
                            let G = parseInt(g[8], 10);
                            G = G >= 0 && G <= 23 ? G : 0;
                            let M = parseInt(g[9], 10) || 0;
                            return M = M >= 0 && M <= 59 ? M : 0, L === "-" ? (P += G, U += M) : L === "+" && (P -= G, U -= M), new Date(Date.UTC(E, T, N, P, U, F))
                        }
                    }
                    r.PDFDateString = b
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.arrayByteLength = Q, r.arraysToBytes = ee, r.assert = F, r.bytesToString = K, r.createPromiseCapability = ke, r.getVerbosityLevel = T, r.info = N, r.isArrayBuffer = Ee, r.isArrayEqual = Ce, r.isBool = Ae, r.isEmptyObj = we, r.isNum = _e, r.isString = ve, r.isSameOrigin = L, r.createValidAbsoluteUrl = M, r.removeNullCharacters = V, r.setVerbosityLevel = E, r.shadow = _, r.string32 = J, r.stringToBytes = Y, r.stringToPDFString = de, r.stringToUTF8String = oe, r.utf8StringToString = ye, r.warn = P, r.unreachable = U, r.IsEvalSupportedCached = r.IsLittleEndianCached = r.createObjectURL = r.FormatError = r.Util = r.UnknownErrorException = r.UnexpectedResponseException = r.TextRenderingMode = r.StreamType = r.PermissionFlag = r.PasswordResponses = r.PasswordException = r.MissingPDFException = r.InvalidPDFException = r.AbortException = r.CMapCompressionType = r.ImageKind = r.FontType = r.AnnotationType = r.AnnotationStateModelType = r.AnnotationReviewState = r.AnnotationReplyType = r.AnnotationMarkedState = r.AnnotationFlag = r.AnnotationFieldFlag = r.AnnotationBorderStyleType = r.UNSUPPORTED_FEATURES = r.VerbosityLevel = r.OPS = r.IDENTITY_MATRIX = r.FONT_IDENTITY_MATRIX = r.BaseException = void 0, n(3);
                    const s = [1, 0, 0, 1, 0, 0];
                    r.IDENTITY_MATRIX = s;
                    const a = [.001, 0, 0, .001, 0, 0];
                    r.FONT_IDENTITY_MATRIX = a;
                    const o = {
                        PRINT: 4,
                        MODIFY_CONTENTS: 8,
                        COPY: 16,
                        MODIFY_ANNOTATIONS: 32,
                        FILL_INTERACTIVE_FORMS: 256,
                        COPY_FOR_ACCESSIBILITY: 512,
                        ASSEMBLE: 1024,
                        PRINT_HIGH_QUALITY: 2048
                    };
                    r.PermissionFlag = o;
                    const c = {
                        FILL: 0,
                        STROKE: 1,
                        FILL_STROKE: 2,
                        INVISIBLE: 3,
                        FILL_ADD_TO_PATH: 4,
                        STROKE_ADD_TO_PATH: 5,
                        FILL_STROKE_ADD_TO_PATH: 6,
                        ADD_TO_PATH: 7,
                        FILL_STROKE_MASK: 3,
                        ADD_TO_PATH_FLAG: 4
                    };
                    r.TextRenderingMode = c;
                    const p = {
                        GRAYSCALE_1BPP: 1,
                        RGB_24BPP: 2,
                        RGBA_32BPP: 3
                    };
                    r.ImageKind = p;
                    const h = {
                        TEXT: 1,
                        LINK: 2,
                        FREETEXT: 3,
                        LINE: 4,
                        SQUARE: 5,
                        CIRCLE: 6,
                        POLYGON: 7,
                        POLYLINE: 8,
                        HIGHLIGHT: 9,
                        UNDERLINE: 10,
                        SQUIGGLY: 11,
                        STRIKEOUT: 12,
                        STAMP: 13,
                        CARET: 14,
                        INK: 15,
                        POPUP: 16,
                        FILEATTACHMENT: 17,
                        SOUND: 18,
                        MOVIE: 19,
                        WIDGET: 20,
                        SCREEN: 21,
                        PRINTERMARK: 22,
                        TRAPNET: 23,
                        WATERMARK: 24,
                        THREED: 25,
                        REDACT: 26
                    };
                    r.AnnotationType = h;
                    const u = {
                        MARKED: "Marked",
                        REVIEW: "Review"
                    };
                    r.AnnotationStateModelType = u;
                    const l = {
                        MARKED: "Marked",
                        UNMARKED: "Unmarked"
                    };
                    r.AnnotationMarkedState = l;
                    const v = {
                        ACCEPTED: "Accepted",
                        REJECTED: "Rejected",
                        CANCELLED: "Cancelled",
                        COMPLETED: "Completed",
                        NONE: "None"
                    };
                    r.AnnotationReviewState = v;
                    const w = {
                        GROUP: "Group",
                        REPLY: "R"
                    };
                    r.AnnotationReplyType = w;
                    const m = {
                        INVISIBLE: 1,
                        HIDDEN: 2,
                        PRINT: 4,
                        NOZOOM: 8,
                        NOROTATE: 16,
                        NOVIEW: 32,
                        READONLY: 64,
                        LOCKED: 128,
                        TOGGLENOVIEW: 256,
                        LOCKEDCONTENTS: 512
                    };
                    r.AnnotationFlag = m;
                    const S = {
                        READONLY: 1,
                        REQUIRED: 2,
                        NOEXPORT: 4,
                        MULTILINE: 4096,
                        PASSWORD: 8192,
                        NOTOGGLETOOFF: 16384,
                        RADIO: 32768,
                        PUSHBUTTON: 65536,
                        COMBO: 131072,
                        EDIT: 262144,
                        SORT: 524288,
                        FILESELECT: 1048576,
                        MULTISELECT: 2097152,
                        DONOTSPELLCHECK: 4194304,
                        DONOTSCROLL: 8388608,
                        COMB: 16777216,
                        RICHTEXT: 33554432,
                        RADIOSINUNISON: 33554432,
                        COMMITONSELCHANGE: 67108864
                    };
                    r.AnnotationFieldFlag = S;
                    const C = {
                        SOLID: 1,
                        DASHED: 2,
                        BEVELED: 3,
                        INSET: 4,
                        UNDERLINE: 5
                    };
                    r.AnnotationBorderStyleType = C;
                    const O = {
                        UNKNOWN: "UNKNOWN",
                        FLATE: "FLATE",
                        LZW: "LZW",
                        DCT: "DCT",
                        JPX: "JPX",
                        JBIG: "JBIG",
                        A85: "A85",
                        AHX: "AHX",
                        CCF: "CCF",
                        RLX: "RLX"
                    };
                    r.StreamType = O;
                    const x = {
                        UNKNOWN: "UNKNOWN",
                        TYPE1: "TYPE1",
                        TYPE1C: "TYPE1C",
                        CIDFONTTYPE0: "CIDFONTTYPE0",
                        CIDFONTTYPE0C: "CIDFONTTYPE0C",
                        TRUETYPE: "TRUETYPE",
                        CIDFONTTYPE2: "CIDFONTTYPE2",
                        TYPE3: "TYPE3",
                        OPENTYPE: "OPENTYPE",
                        TYPE0: "TYPE0",
                        MMTYPE1: "MMTYPE1"
                    };
                    r.FontType = x;
                    const I = {
                        ERRORS: 0,
                        WARNINGS: 1,
                        INFOS: 5
                    };
                    r.VerbosityLevel = I;
                    const B = {
                        NONE: 0,
                        BINARY: 1,
                        STREAM: 2
                    };
                    r.CMapCompressionType = B;
                    const b = {
                        dependency: 1,
                        setLineWidth: 2,
                        setLineCap: 3,
                        setLineJoin: 4,
                        setMiterLimit: 5,
                        setDash: 6,
                        setRenderingIntent: 7,
                        setFlatness: 8,
                        setGState: 9,
                        save: 10,
                        restore: 11,
                        transform: 12,
                        moveTo: 13,
                        lineTo: 14,
                        curveTo: 15,
                        curveTo2: 16,
                        curveTo3: 17,
                        closePath: 18,
                        rectangle: 19,
                        stroke: 20,
                        closeStroke: 21,
                        fill: 22,
                        eoFill: 23,
                        fillStroke: 24,
                        eoFillStroke: 25,
                        closeFillStroke: 26,
                        closeEOFillStroke: 27,
                        endPath: 28,
                        clip: 29,
                        eoClip: 30,
                        beginText: 31,
                        endText: 32,
                        setCharSpacing: 33,
                        setWordSpacing: 34,
                        setHScale: 35,
                        setLeading: 36,
                        setFont: 37,
                        setTextRenderingMode: 38,
                        setTextRise: 39,
                        moveText: 40,
                        setLeadingMoveText: 41,
                        setTextMatrix: 42,
                        nextLine: 43,
                        showText: 44,
                        showSpacedText: 45,
                        nextLineShowText: 46,
                        nextLineSetSpacingShowText: 47,
                        setCharWidth: 48,
                        setCharWidthAndBounds: 49,
                        setStrokeColorSpace: 50,
                        setFillColorSpace: 51,
                        setStrokeColor: 52,
                        setStrokeColorN: 53,
                        setFillColor: 54,
                        setFillColorN: 55,
                        setStrokeGray: 56,
                        setFillGray: 57,
                        setStrokeRGBColor: 58,
                        setFillRGBColor: 59,
                        setStrokeCMYKColor: 60,
                        setFillCMYKColor: 61,
                        shadingFill: 62,
                        beginInlineImage: 63,
                        beginImageData: 64,
                        endInlineImage: 65,
                        paintXObject: 66,
                        markPoint: 67,
                        markPointProps: 68,
                        beginMarkedContent: 69,
                        beginMarkedContentProps: 70,
                        endMarkedContent: 71,
                        beginCompat: 72,
                        endCompat: 73,
                        paintFormXObjectBegin: 74,
                        paintFormXObjectEnd: 75,
                        beginGroup: 76,
                        endGroup: 77,
                        beginAnnotations: 78,
                        endAnnotations: 79,
                        beginAnnotation: 80,
                        endAnnotation: 81,
                        paintJpegXObject: 82,
                        paintImageMaskXObject: 83,
                        paintImageMaskXObjectGroup: 84,
                        paintImageXObject: 85,
                        paintInlineImageXObject: 86,
                        paintInlineImageXObjectGroup: 87,
                        paintImageXObjectRepeat: 88,
                        paintImageMaskXObjectRepeat: 89,
                        paintSolidColorImageMask: 90,
                        constructPath: 91
                    };
                    r.OPS = b;
                    const f = {
                        unknown: "unknown",
                        forms: "forms",
                        javaScript: "javaScript",
                        smask: "smask",
                        shadingPattern: "shadingPattern",
                        font: "font",
                        errorTilingPattern: "errorTilingPattern",
                        errorExtGState: "errorExtGState",
                        errorXObject: "errorXObject",
                        errorFontLoadType3: "errorFontLoadType3",
                        errorFontState: "errorFontState",
                        errorFontMissing: "errorFontMissing",
                        errorFontTranslate: "errorFontTranslate",
                        errorColorSpace: "errorColorSpace",
                        errorOperatorList: "errorOperatorList",
                        errorFontToUnicode: "errorFontToUnicode",
                        errorFontLoadNative: "errorFontLoadNative",
                        errorFontGetPath: "errorFontGetPath"
                    };
                    r.UNSUPPORTED_FEATURES = f;
                    const d = {
                        NEED_PASSWORD: 1,
                        INCORRECT_PASSWORD: 2
                    };
                    r.PasswordResponses = d;
                    let g = I.WARNINGS;

                    function E(Z) {
                        Number.isInteger(Z) && (g = Z)
                    }

                    function T() {
                        return g
                    }

                    function N(Z) {
                        g >= I.INFOS && console.log(`Info: ${Z}`)
                    }

                    function P(Z) {
                        g >= I.WARNINGS && console.log(`Warning: ${Z}`)
                    }

                    function U(Z) {
                        throw new Error(Z)
                    }

                    function F(Z, W) {
                        Z || U(W)
                    }

                    function L(Z, W) {
                        let X;
                        try {
                            if (X = new URL(Z), !X.origin || X.origin === "null") return !1
                        } catch {
                            return !1
                        }
                        const te = new URL(W, X);
                        return X.origin === te.origin
                    }

                    function G(Z) {
                        if (!Z) return !1;
                        switch (Z.protocol) {
                            case "http:":
                            case "https:":
                            case "ftp:":
                            case "mailto:":
                            case "tel:":
                                return !0;
                            default:
                                return !1
                        }
                    }

                    function M(Z, W) {
                        if (!Z) return null;
                        try {
                            const X = W ? new URL(Z, W) : new URL(Z);
                            if (G(X)) return X
                        } catch {}
                        return null
                    }

                    function _(Z, W, X) {
                        return Object.defineProperty(Z, W, {
                            value: X,
                            enumerable: !0,
                            configurable: !0,
                            writable: !1
                        }), X
                    }
                    const A = function() {
                        function W(X) {
                            this.constructor === W && U("Cannot initialize BaseException."), this.message = X, this.name = this.constructor.name
                        }
                        return W.prototype = new Error, W.constructor = W, W
                    }();
                    r.BaseException = A;
                    class y extends A {
                        constructor(W, X) {
                            super(W), this.code = X
                        }
                    }
                    r.PasswordException = y;
                    class k extends A {
                        constructor(W, X) {
                            super(W), this.details = X
                        }
                    }
                    r.UnknownErrorException = k;
                    class R extends A {}
                    r.InvalidPDFException = R;
                    class D extends A {}
                    r.MissingPDFException = D;
                    class H extends A {
                        constructor(W, X) {
                            super(W), this.status = X
                        }
                    }
                    r.UnexpectedResponseException = H;
                    class q extends A {}
                    r.FormatError = q;
                    class z extends A {}
                    r.AbortException = z;
                    const j = /\x00/g;

                    function V(Z) {
                        return typeof Z != "string" ? (P("The argument for removeNullCharacters must be a string."), Z) : Z.replace(j, "")
                    }

                    function K(Z) {
                        F(Z !== null && typeof Z == "object" && Z.length !== void 0, "Invalid argument for bytesToString");
                        const W = Z.length,
                            X = 8192;
                        if (W < X) return String.fromCharCode.apply(null, Z);
                        const te = [];
                        for (let ae = 0; ae < W; ae += X) {
                            const ce = Math.min(ae + X, W),
                                ue = Z.subarray(ae, ce);
                            te.push(String.fromCharCode.apply(null, ue))
                        }
                        return te.join("")
                    }

                    function Y(Z) {
                        F(typeof Z == "string", "Invalid argument for stringToBytes");
                        const W = Z.length,
                            X = new Uint8Array(W);
                        for (let te = 0; te < W; ++te) X[te] = Z.charCodeAt(te) & 255;
                        return X
                    }

                    function Q(Z) {
                        return Z.length !== void 0 ? Z.length : (F(Z.byteLength !== void 0, "arrayByteLength - invalid argument."), Z.byteLength)
                    }

                    function ee(Z) {
                        const W = Z.length;
                        if (W === 1 && Z[0] instanceof Uint8Array) return Z[0];
                        let X = 0;
                        for (let ce = 0; ce < W; ce++) X += Q(Z[ce]);
                        let te = 0;
                        const ae = new Uint8Array(X);
                        for (let ce = 0; ce < W; ce++) {
                            let ue = Z[ce];
                            ue instanceof Uint8Array || (typeof ue == "string" ? ue = Y(ue) : ue = new Uint8Array(ue));
                            const ge = ue.byteLength;
                            ae.set(ue, te), te += ge
                        }
                        return ae
                    }

                    function J(Z) {
                        return String.fromCharCode(Z >> 24 & 255, Z >> 16 & 255, Z >> 8 & 255, Z & 255)
                    }

                    function ne() {
                        const Z = new Uint8Array(4);
                        return Z[0] = 1, new Uint32Array(Z.buffer, 0, 1)[0] === 1
                    }
                    const se = {
                        get value() {
                            return _(this, "value", ne())
                        }
                    };
                    r.IsLittleEndianCached = se;

                    function ie() {
                        try {
                            return new Function(""), !0
                        } catch {
                            return !1
                        }
                    }
                    const he = {
                        get value() {
                            return _(this, "value", ie())
                        }
                    };
                    r.IsEvalSupportedCached = he;
                    const fe = ["rgb(", 0, ",", 0, ",", 0, ")"];
                    class le {
                        static makeCssRgb(W, X, te) {
                            return fe[1] = W, fe[3] = X, fe[5] = te, fe.join("")
                        }
                        static transform(W, X) {
                            return [W[0] * X[0] + W[2] * X[1], W[1] * X[0] + W[3] * X[1], W[0] * X[2] + W[2] * X[3], W[1] * X[2] + W[3] * X[3], W[0] * X[4] + W[2] * X[5] + W[4], W[1] * X[4] + W[3] * X[5] + W[5]]
                        }
                        static applyTransform(W, X) {
                            const te = W[0] * X[0] + W[1] * X[2] + X[4],
                                ae = W[0] * X[1] + W[1] * X[3] + X[5];
                            return [te, ae]
                        }
                        static applyInverseTransform(W, X) {
                            const te = X[0] * X[3] - X[1] * X[2],
                                ae = (W[0] * X[3] - W[1] * X[2] + X[2] * X[5] - X[4] * X[3]) / te,
                                ce = (-W[0] * X[1] + W[1] * X[0] + X[4] * X[1] - X[5] * X[0]) / te;
                            return [ae, ce]
                        }
                        static getAxialAlignedBoundingBox(W, X) {
                            const te = le.applyTransform(W, X),
                                ae = le.applyTransform(W.slice(2, 4), X),
                                ce = le.applyTransform([W[0], W[3]], X),
                                ue = le.applyTransform([W[2], W[1]], X);
                            return [Math.min(te[0], ae[0], ce[0], ue[0]), Math.min(te[1], ae[1], ce[1], ue[1]), Math.max(te[0], ae[0], ce[0], ue[0]), Math.max(te[1], ae[1], ce[1], ue[1])]
                        }
                        static inverseTransform(W) {
                            const X = W[0] * W[3] - W[1] * W[2];
                            return [W[3] / X, -W[1] / X, -W[2] / X, W[0] / X, (W[2] * W[5] - W[4] * W[3]) / X, (W[4] * W[1] - W[5] * W[0]) / X]
                        }
                        static apply3dTransform(W, X) {
                            return [W[0] * X[0] + W[1] * X[1] + W[2] * X[2], W[3] * X[0] + W[4] * X[1] + W[5] * X[2], W[6] * X[0] + W[7] * X[1] + W[8] * X[2]]
                        }
                        static singularValueDecompose2dScale(W) {
                            const X = [W[0], W[2], W[1], W[3]],
                                te = W[0] * X[0] + W[1] * X[2],
                                ae = W[0] * X[1] + W[1] * X[3],
                                ce = W[2] * X[0] + W[3] * X[2],
                                ue = W[2] * X[1] + W[3] * X[3],
                                ge = (te + ue) / 2,
                                be = Math.sqrt((te + ue) * (te + ue) - 4 * (te * ue - ce * ae)) / 2,
                                Se = ge + be || 1,
                                Te = ge - be || 1;
                            return [Math.sqrt(Se), Math.sqrt(Te)]
                        }
                        static normalizeRect(W) {
                            const X = W.slice(0);
                            return W[0] > W[2] && (X[0] = W[2], X[2] = W[0]), W[1] > W[3] && (X[1] = W[3], X[3] = W[1]), X
                        }
                        static intersect(W, X) {
                            function te(ge, be) {
                                return ge - be
                            }
                            const ae = [W[0], W[2], X[0], X[2]].sort(te),
                                ce = [W[1], W[3], X[1], X[3]].sort(te),
                                ue = [];
                            if (W = le.normalizeRect(W), X = le.normalizeRect(X), ae[0] === W[0] && ae[1] === X[0] || ae[0] === X[0] && ae[1] === W[0]) ue[0] = ae[1], ue[2] = ae[2];
                            else return null;
                            if (ce[0] === W[1] && ce[1] === X[1] || ce[0] === X[1] && ce[1] === W[1]) ue[1] = ce[1], ue[3] = ce[2];
                            else return null;
                            return ue
                        }
                    }
                    r.Util = le;
                    const pe = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];

                    function de(Z) {
                        const W = Z.length,
                            X = [];
                        if (Z[0] === "\xFE" && Z[1] === "\xFF")
                            for (let te = 2; te < W; te += 2) X.push(String.fromCharCode(Z.charCodeAt(te) << 8 | Z.charCodeAt(te + 1)));
                        else if (Z[0] === "\xFF" && Z[1] === "\xFE")
                            for (let te = 2; te < W; te += 2) X.push(String.fromCharCode(Z.charCodeAt(te + 1) << 8 | Z.charCodeAt(te)));
                        else
                            for (let te = 0; te < W; ++te) {
                                const ae = pe[Z.charCodeAt(te)];
                                X.push(ae ? String.fromCharCode(ae) : Z.charAt(te))
                            }
                        return X.join("")
                    }

                    function oe(Z) {
                        return decodeURIComponent(escape(Z))
                    }

                    function ye(Z) {
                        return unescape(encodeURIComponent(Z))
                    }

                    function we(Z) {
                        for (const W in Z) return !1;
                        return !0
                    }

                    function Ae(Z) {
                        return typeof Z == "boolean"
                    }

                    function _e(Z) {
                        return typeof Z == "number"
                    }

                    function ve(Z) {
                        return typeof Z == "string"
                    }

                    function Ee(Z) {
                        return typeof Z == "object" && Z !== null && Z.byteLength !== void 0
                    }

                    function Ce(Z, W) {
                        return Z.length !== W.length ? !1 : Z.every(function(X, te) {
                            return X === W[te]
                        })
                    }

                    function ke() {
                        const Z = Object.create(null);
                        let W = !1;
                        return Object.defineProperty(Z, "settled", {
                            get() {
                                return W
                            }
                        }), Z.promise = new Promise(function(X, te) {
                            Z.resolve = function(ae) {
                                W = !0, X(ae)
                            }, Z.reject = function(ae) {
                                W = !0, te(ae)
                            }
                        }), Z
                    }
                    const me = function() {
                        const W = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                        return function(te, ae, ce = !1) {
                            if (!ce && URL.createObjectURL) {
                                const ge = new Blob([te], {
                                    type: ae
                                });
                                return URL.createObjectURL(ge)
                            }
                            let ue = `data:${ae};base64,`;
                            for (let ge = 0, be = te.length; ge < be; ge += 3) {
                                const Se = te[ge] & 255,
                                    Te = te[ge + 1] & 255,
                                    xe = te[ge + 2] & 255,
                                    Re = Se >> 2,
                                    Pe = (Se & 3) << 4 | Te >> 4,
                                    Ie = ge + 1 < be ? (Te & 15) << 2 | xe >> 6 : 64,
                                    Be = ge + 2 < be ? xe & 63 : 64;
                                ue += W[Re] + W[Pe] + W[Ie] + W[Be]
                            }
                            return ue
                        }
                    }();
                    r.createObjectURL = me
                }, function(i, r, n) {
                    n(4)
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.isNodeJS = void 0;
                    const s = typeof process$1 == "object" && process$1 + "" == "[object process]" && !process$1.versions.nw && !process$1.versions.electron;
                    r.isNodeJS = s
                }, function(module, exports, __w_pdfjs_require__) {
                    Object.defineProperty(exports, "__esModule", {
                        value: !0
                    }), exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;
                    var _util = __w_pdfjs_require__(2),
                        _display_utils = __w_pdfjs_require__(1),
                        _font_loader = __w_pdfjs_require__(6),
                        _api_compatibility = __w_pdfjs_require__(7),
                        _canvas = __w_pdfjs_require__(8),
                        _worker_options = __w_pdfjs_require__(10),
                        _is_node = __w_pdfjs_require__(4),
                        _message_handler = __w_pdfjs_require__(11),
                        _metadata = __w_pdfjs_require__(12),
                        _transport_stream = __w_pdfjs_require__(14),
                        _webgl = __w_pdfjs_require__(15);
                    const DEFAULT_RANGE_CHUNK_SIZE = 65536,
                        RENDERING_CANCELLED_TIMEOUT = 100;
                    let createPDFNetworkStream;

                    function setPDFNetworkStreamFactory(i) {
                        createPDFNetworkStream = i
                    }

                    function getDocument(i) {
                        const r = new PDFDocumentLoadingTask;
                        let n;
                        if (typeof i == "string") n = {
                            url: i
                        };
                        else if ((0, _util.isArrayBuffer)(i)) n = {
                            data: i
                        };
                        else if (i instanceof PDFDataRangeTransport) n = {
                            range: i
                        };
                        else {
                            if (typeof i != "object") throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                            if (!i.url && !i.data && !i.range) throw new Error("Invalid parameter object: need either .data, .range or .url");
                            n = i
                        }
                        const s = Object.create(null);
                        let a = null,
                            o = null;
                        for (const p in n) {
                            if (p === "url" && typeof window < "u") {
                                s[p] = new URL(n[p], window.location).href;
                                continue
                            } else if (p === "range") {
                                a = n[p];
                                continue
                            } else if (p === "worker") {
                                o = n[p];
                                continue
                            } else if (p === "data" && !(n[p] instanceof Uint8Array)) {
                                const h = n[p];
                                if (typeof h == "string") s[p] = (0, _util.stringToBytes)(h);
                                else if (typeof h == "object" && h !== null && !isNaN(h.length)) s[p] = new Uint8Array(h);
                                else if ((0, _util.isArrayBuffer)(h)) s[p] = new Uint8Array(h);
                                else throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                                continue
                            }
                            s[p] = n[p]
                        }
                        if (s.rangeChunkSize = s.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE, s.CMapReaderFactory = s.CMapReaderFactory || _display_utils.DOMCMapReaderFactory, s.ignoreErrors = s.stopAtErrors !== !0, s.fontExtraProperties = s.fontExtraProperties === !0, s.pdfBug = s.pdfBug === !0, Number.isInteger(s.maxImageSize) || (s.maxImageSize = -1), typeof s.isEvalSupported != "boolean" && (s.isEvalSupported = !0), typeof s.disableFontFace != "boolean" && (s.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || !1), typeof s.disableRange != "boolean" && (s.disableRange = !1), typeof s.disableStream != "boolean" && (s.disableStream = !1), typeof s.disableAutoFetch != "boolean" && (s.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(s.verbosity), !o) {
                            const p = {
                                verbosity: s.verbosity,
                                port: _worker_options.GlobalWorkerOptions.workerPort
                            };
                            o = p.port ? PDFWorker.fromPort(p) : new PDFWorker(p), r._worker = o
                        }
                        const c = r.docId;
                        return o.promise.then(function() {
                            if (r.destroyed) throw new Error("Loading aborted");
                            const p = _fetchDocument(o, s, a, c),
                                h = new Promise(function(u) {
                                    let l;
                                    a ? l = new _transport_stream.PDFDataTransportStream({
                                        length: s.length,
                                        initialData: s.initialData,
                                        progressiveDone: s.progressiveDone,
                                        disableRange: s.disableRange,
                                        disableStream: s.disableStream
                                    }, a) : s.data || (l = createPDFNetworkStream({
                                        url: s.url,
                                        length: s.length,
                                        httpHeaders: s.httpHeaders,
                                        withCredentials: s.withCredentials,
                                        rangeChunkSize: s.rangeChunkSize,
                                        disableRange: s.disableRange,
                                        disableStream: s.disableStream
                                    })), u(l)
                                });
                            return Promise.all([p, h]).then(function([u, l]) {
                                if (r.destroyed) throw new Error("Loading aborted");
                                const v = new _message_handler.MessageHandler(c, u, o.port);
                                v.postMessageTransfers = o.postMessageTransfers;
                                const w = new WorkerTransport(v, r, l, s);
                                r._transport = w, v.send("Ready", null)
                            })
                        }).catch(r._capability.reject), r
                    }

                    function _fetchDocument(i, r, n, s) {
                        return i.destroyed ? Promise.reject(new Error("Worker was destroyed")) : (n && (r.length = n.length, r.initialData = n.initialData, r.progressiveDone = n.progressiveDone), i.messageHandler.sendWithPromise("GetDocRequest", {
                            docId: s,
                            apiVersion: "2.5.207",
                            source: {
                                data: r.data,
                                url: r.url,
                                password: r.password,
                                disableAutoFetch: r.disableAutoFetch,
                                rangeChunkSize: r.rangeChunkSize,
                                length: r.length
                            },
                            maxImageSize: r.maxImageSize,
                            disableFontFace: r.disableFontFace,
                            postMessageTransfers: i.postMessageTransfers,
                            docBaseUrl: r.docBaseUrl,
                            ignoreErrors: r.ignoreErrors,
                            isEvalSupported: r.isEvalSupported,
                            fontExtraProperties: r.fontExtraProperties
                        }).then(function(a) {
                            if (i.destroyed) throw new Error("Worker was destroyed");
                            return a
                        }))
                    }
                    const PDFDocumentLoadingTask = function() {
                        let r = 0;
                        class n {
                            constructor() {
                                this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = "d" + r++, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null
                            }
                            get promise() {
                                return this._capability.promise
                            }
                            destroy() {
                                return this.destroyed = !0, (this._transport ? this._transport.destroy() : Promise.resolve()).then(() => {
                                    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null)
                                })
                            }
                        }
                        return n
                    }();
                    class PDFDataRangeTransport {
                        constructor(r, n, s = !1) {
                            this.length = r, this.initialData = n, this.progressiveDone = s, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)()
                        }
                        addRangeListener(r) {
                            this._rangeListeners.push(r)
                        }
                        addProgressListener(r) {
                            this._progressListeners.push(r)
                        }
                        addProgressiveReadListener(r) {
                            this._progressiveReadListeners.push(r)
                        }
                        addProgressiveDoneListener(r) {
                            this._progressiveDoneListeners.push(r)
                        }
                        onDataRange(r, n) {
                            for (const s of this._rangeListeners) s(r, n)
                        }
                        onDataProgress(r, n) {
                            this._readyCapability.promise.then(() => {
                                for (const s of this._progressListeners) s(r, n)
                            })
                        }
                        onDataProgressiveRead(r) {
                            this._readyCapability.promise.then(() => {
                                for (const n of this._progressiveReadListeners) n(r)
                            })
                        }
                        onDataProgressiveDone() {
                            this._readyCapability.promise.then(() => {
                                for (const r of this._progressiveDoneListeners) r()
                            })
                        }
                        transportReady() {
                            this._readyCapability.resolve()
                        }
                        requestDataRange(r, n) {
                            (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange")
                        }
                        abort() {}
                    }
                    exports.PDFDataRangeTransport = PDFDataRangeTransport;
                    class PDFDocumentProxy {
                        constructor(r, n) {
                            this._pdfInfo = r, this._transport = n
                        }
                        get numPages() {
                            return this._pdfInfo.numPages
                        }
                        get fingerprint() {
                            return this._pdfInfo.fingerprint
                        }
                        getPage(r) {
                            return this._transport.getPage(r)
                        }
                        getPageIndex(r) {
                            return this._transport.getPageIndex(r)
                        }
                        getDestinations() {
                            return this._transport.getDestinations()
                        }
                        getDestination(r) {
                            return this._transport.getDestination(r)
                        }
                        getPageLabels() {
                            return this._transport.getPageLabels()
                        }
                        getPageLayout() {
                            return this._transport.getPageLayout()
                        }
                        getPageMode() {
                            return this._transport.getPageMode()
                        }
                        getViewerPreferences() {
                            return this._transport.getViewerPreferences()
                        }
                        getOpenAction() {
                            return this._transport.getOpenAction()
                        }
                        getOpenActionDestination() {
                            return (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead."), this.getOpenAction().then(function(r) {
                                return r && r.dest ? r.dest : null
                            })
                        }
                        getAttachments() {
                            return this._transport.getAttachments()
                        }
                        getJavaScript() {
                            return this._transport.getJavaScript()
                        }
                        getOutline() {
                            return this._transport.getOutline()
                        }
                        getPermissions() {
                            return this._transport.getPermissions()
                        }
                        getMetadata() {
                            return this._transport.getMetadata()
                        }
                        getData() {
                            return this._transport.getData()
                        }
                        getDownloadInfo() {
                            return this._transport.downloadInfoCapability.promise
                        }
                        getStats() {
                            return this._transport.getStats()
                        }
                        cleanup() {
                            return this._transport.startCleanup()
                        }
                        destroy() {
                            return this.loadingTask.destroy()
                        }
                        get loadingParams() {
                            return this._transport.loadingParams
                        }
                        get loadingTask() {
                            return this._transport.loadingTask
                        }
                    }
                    exports.PDFDocumentProxy = PDFDocumentProxy;
                    class PDFPageProxy {
                        constructor(r, n, s, a = !1) {
                            this._pageIndex = r, this._pageInfo = n, this._transport = s, this._stats = a ? new _display_utils.StatTimer : null, this._pdfBug = a, this.commonObjs = s.commonObjs, this.objs = new PDFObjects, this.cleanupAfterRender = !1, this.pendingCleanup = !1, this.intentStates = Object.create(null), this.destroyed = !1
                        }
                        get pageNumber() {
                            return this._pageIndex + 1
                        }
                        get rotate() {
                            return this._pageInfo.rotate
                        }
                        get ref() {
                            return this._pageInfo.ref
                        }
                        get userUnit() {
                            return this._pageInfo.userUnit
                        }
                        get view() {
                            return this._pageInfo.view
                        }
                        getViewport({
                            scale: r,
                            rotation: n = this.rotate,
                            offsetX: s = 0,
                            offsetY: a = 0,
                            dontFlip: o = !1
                        } = {}) {
                            return new _display_utils.PageViewport({
                                viewBox: this.view,
                                scale: r,
                                rotation: n,
                                offsetX: s,
                                offsetY: a,
                                dontFlip: o
                            })
                        }
                        getAnnotations({
                            intent: r = null
                        } = {}) {
                            return (!this.annotationsPromise || this.annotationsIntent !== r) && (this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, r), this.annotationsIntent = r), this.annotationsPromise
                        }
                        render({
                            canvasContext: r,
                            viewport: n,
                            intent: s = "display",
                            enableWebGL: a = !1,
                            renderInteractiveForms: o = !1,
                            transform: c = null,
                            imageLayer: p = null,
                            canvasFactory: h = null,
                            background: u = null
                        }) {
                            this._stats && this._stats.time("Overall");
                            const l = s === "print" ? "print" : "display";
                            this.pendingCleanup = !1, this.intentStates[l] || (this.intentStates[l] = Object.create(null));
                            const v = this.intentStates[l];
                            v.streamReaderCancelTimeout && (clearTimeout(v.streamReaderCancelTimeout), v.streamReaderCancelTimeout = null);
                            const w = h || new _display_utils.DOMCanvasFactory,
                                m = new _webgl.WebGLContext({
                                    enable: a
                                });
                            v.displayReadyCapability || (v.displayReadyCapability = (0, _util.createPromiseCapability)(), v.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: !1
                            }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList({
                                pageIndex: this._pageIndex,
                                intent: l,
                                renderInteractiveForms: o === !0
                            }));
                            const S = x => {
                                    const I = v.renderTasks.indexOf(C);
                                    I >= 0 && v.renderTasks.splice(I, 1), (this.cleanupAfterRender || l === "print") && (this.pendingCleanup = !0), this._tryCleanup(), x ? (C.capability.reject(x), this._abortOperatorList({
                                        intentState: v,
                                        reason: x
                                    })) : C.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"))
                                },
                                C = new InternalRenderTask({
                                    callback: S,
                                    params: {
                                        canvasContext: r,
                                        viewport: n,
                                        transform: c,
                                        imageLayer: p,
                                        background: u
                                    },
                                    objs: this.objs,
                                    commonObjs: this.commonObjs,
                                    operatorList: v.operatorList,
                                    pageIndex: this._pageIndex,
                                    canvasFactory: w,
                                    webGLContext: m,
                                    useRequestAnimationFrame: l !== "print",
                                    pdfBug: this._pdfBug
                                });
                            v.renderTasks || (v.renderTasks = []), v.renderTasks.push(C);
                            const O = C.task;
                            return v.displayReadyCapability.promise.then(x => {
                                if (this.pendingCleanup) {
                                    S();
                                    return
                                }
                                this._stats && this._stats.time("Rendering"), C.initializeGraphics(x), C.operatorListChanged()
                            }).catch(S), O
                        }
                        getOperatorList() {
                            function r() {
                                if (s.operatorList.lastChunk) {
                                    s.opListReadCapability.resolve(s.operatorList);
                                    const o = s.renderTasks.indexOf(a);
                                    o >= 0 && s.renderTasks.splice(o, 1)
                                }
                            }
                            const n = "oplist";
                            this.intentStates[n] || (this.intentStates[n] = Object.create(null));
                            const s = this.intentStates[n];
                            let a;
                            return s.opListReadCapability || (a = {}, a.operatorListChanged = r, s.opListReadCapability = (0, _util.createPromiseCapability)(), s.renderTasks = [], s.renderTasks.push(a), s.operatorList = {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: !1
                            }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList({
                                pageIndex: this._pageIndex,
                                intent: n
                            })), s.opListReadCapability.promise
                        }
                        streamTextContent({
                            normalizeWhitespace: r = !1,
                            disableCombineTextItems: n = !1
                        } = {}) {
                            return this._transport.messageHandler.sendWithStream("GetTextContent", {
                                pageIndex: this._pageIndex,
                                normalizeWhitespace: r === !0,
                                combineTextItems: n !== !0
                            }, {
                                highWaterMark: 100,
                                size(a) {
                                    return a.items.length
                                }
                            })
                        }
                        getTextContent(r = {}) {
                            const n = this.streamTextContent(r);
                            return new Promise(function(s, a) {
                                function o() {
                                    c.read().then(function({
                                        value: h,
                                        done: u
                                    }) {
                                        if (u) {
                                            s(p);
                                            return
                                        }
                                        Object.assign(p.styles, h.styles), p.items.push(...h.items), o()
                                    }, a)
                                }
                                const c = n.getReader(),
                                    p = {
                                        items: [],
                                        styles: Object.create(null)
                                    };
                                o()
                            })
                        }
                        _destroy() {
                            this.destroyed = !0, this._transport.pageCache[this._pageIndex] = null;
                            const r = [];
                            return Object.keys(this.intentStates).forEach(n => {
                                const s = this.intentStates[n];
                                this._abortOperatorList({
                                    intentState: s,
                                    reason: new Error("Page was destroyed."),
                                    force: !0
                                }), n !== "oplist" && s.renderTasks.forEach(function(a) {
                                    const o = a.capability.promise.catch(function() {});
                                    r.push(o), a.cancel()
                                })
                            }), this.objs.clear(), this.annotationsPromise = null, this.pendingCleanup = !1, Promise.all(r)
                        }
                        cleanup(r = !1) {
                            return this.pendingCleanup = !0, this._tryCleanup(r)
                        }
                        _tryCleanup(r = !1) {
                            return !this.pendingCleanup || Object.keys(this.intentStates).some(n => {
                                const s = this.intentStates[n];
                                return s.renderTasks.length !== 0 || !s.operatorList.lastChunk
                            }) ? !1 : (Object.keys(this.intentStates).forEach(n => {
                                delete this.intentStates[n]
                            }), this.objs.clear(), this.annotationsPromise = null, r && this._stats && (this._stats = new _display_utils.StatTimer), this.pendingCleanup = !1, !0)
                        }
                        _startRenderPage(r, n) {
                            const s = this.intentStates[n];
                            !s || (this._stats && this._stats.timeEnd("Page Request"), s.displayReadyCapability && s.displayReadyCapability.resolve(r))
                        }
                        _renderPageChunk(r, n) {
                            for (let s = 0, a = r.length; s < a; s++) n.operatorList.fnArray.push(r.fnArray[s]), n.operatorList.argsArray.push(r.argsArray[s]);
                            n.operatorList.lastChunk = r.lastChunk;
                            for (let s = 0; s < n.renderTasks.length; s++) n.renderTasks[s].operatorListChanged();
                            r.lastChunk && this._tryCleanup()
                        }
                        _pumpOperatorList(r) {
                            (0, _util.assert)(r.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                            const s = this._transport.messageHandler.sendWithStream("GetOperatorList", r).getReader(),
                                a = this.intentStates[r.intent];
                            a.streamReader = s;
                            const o = () => {
                                s.read().then(({
                                    value: c,
                                    done: p
                                }) => {
                                    if (p) {
                                        a.streamReader = null;
                                        return
                                    }
                                    this._transport.destroyed || (this._renderPageChunk(c, a), o())
                                }, c => {
                                    if (a.streamReader = null, !this._transport.destroyed) {
                                        if (a.operatorList) {
                                            a.operatorList.lastChunk = !0;
                                            for (let p = 0; p < a.renderTasks.length; p++) a.renderTasks[p].operatorListChanged();
                                            this._tryCleanup()
                                        }
                                        if (a.displayReadyCapability) a.displayReadyCapability.reject(c);
                                        else if (a.opListReadCapability) a.opListReadCapability.reject(c);
                                        else throw c
                                    }
                                })
                            };
                            o()
                        }
                        _abortOperatorList({
                            intentState: r,
                            reason: n,
                            force: s = !1
                        }) {
                            if ((0, _util.assert)(n instanceof Error || typeof n == "object" && n !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.'), !!r.streamReader) {
                                if (!s) {
                                    if (r.renderTasks.length !== 0) return;
                                    if (n instanceof _display_utils.RenderingCancelledException) {
                                        r.streamReaderCancelTimeout = setTimeout(() => {
                                            this._abortOperatorList({
                                                intentState: r,
                                                reason: n,
                                                force: !0
                                            }), r.streamReaderCancelTimeout = null
                                        }, RENDERING_CANCELLED_TIMEOUT);
                                        return
                                    }
                                }
                                r.streamReader.cancel(new _util.AbortException(n && n.message)), r.streamReader = null, !this._transport.destroyed && (Object.keys(this.intentStates).some(a => this.intentStates[a] === r ? (delete this.intentStates[a], !0) : !1), this.cleanup())
                            }
                        }
                        get stats() {
                            return this._stats
                        }
                    }
                    exports.PDFPageProxy = PDFPageProxy;
                    class LoopbackPort {
                        constructor(r = !0) {
                            this._listeners = [], this._defer = r, this._deferred = Promise.resolve(void 0)
                        }
                        postMessage(r, n) {
                            function s(c) {
                                if (typeof c != "object" || c === null) return c;
                                if (a.has(c)) return a.get(c);
                                let p, h;
                                if ((p = c.buffer) && (0, _util.isArrayBuffer)(p)) return n && n.includes(p) ? h = new c.constructor(p, c.byteOffset, c.byteLength) : h = new c.constructor(c), a.set(c, h), h;
                                h = Array.isArray(c) ? [] : {}, a.set(c, h);
                                for (const u in c) {
                                    let l, v = c;
                                    for (; !(l = Object.getOwnPropertyDescriptor(v, u));) v = Object.getPrototypeOf(v);
                                    if (!(typeof l.value > "u")) {
                                        if (typeof l.value == "function") {
                                            if (c.hasOwnProperty && c.hasOwnProperty(u)) throw new Error(`LoopbackPort.postMessage - cannot clone: ${c[u]}`);
                                            continue
                                        }
                                        h[u] = s(l.value)
                                    }
                                }
                                return h
                            }
                            if (!this._defer) {
                                this._listeners.forEach(c => {
                                    c.call(this, {
                                        data: r
                                    })
                                });
                                return
                            }
                            const a = new WeakMap,
                                o = {
                                    data: s(r)
                                };
                            this._deferred.then(() => {
                                this._listeners.forEach(c => {
                                    c.call(this, o)
                                })
                            })
                        }
                        addEventListener(r, n) {
                            this._listeners.push(n)
                        }
                        removeEventListener(r, n) {
                            const s = this._listeners.indexOf(n);
                            this._listeners.splice(s, 1)
                        }
                        terminate() {
                            this._listeners.length = 0
                        }
                    }
                    exports.LoopbackPort = LoopbackPort;
                    const PDFWorker = function PDFWorkerClosure() {
                        const pdfWorkerPorts = new WeakMap;
                        let isWorkerDisabled = !1,
                            fallbackWorkerSrc, nextFakeWorkerId = 0,
                            fakeWorkerCapability;
                        if (_is_node.isNodeJS && typeof commonjsRequire == "function") isWorkerDisabled = !0, fallbackWorkerSrc = "./pdf.worker.js";
                        else if (typeof document == "object" && "currentScript" in document) {
                            const i = document.currentScript && document.currentScript.src;
                            i && (fallbackWorkerSrc = i.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"))
                        }

                        function getWorkerSrc() {
                            if (_worker_options.GlobalWorkerOptions.workerSrc) return _worker_options.GlobalWorkerOptions.workerSrc;
                            if (typeof fallbackWorkerSrc < "u") return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), fallbackWorkerSrc;
                            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.')
                        }

                        function getMainThreadWorkerMessageHandler() {
                            let i;
                            try {
                                i = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler
                            } catch {}
                            return i || null
                        }

                        function setupFakeWorkerGlobal() {
                            if (fakeWorkerCapability) return fakeWorkerCapability.promise;
                            fakeWorkerCapability = (0, _util.createPromiseCapability)();
                            const loader = async function() {
                                const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                                if (mainWorkerMessageHandler) return mainWorkerMessageHandler;
                                if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
                                    const worker = eval("require")(getWorkerSrc());
                                    return worker.WorkerMessageHandler
                                }
                                return await (0, _display_utils.loadScript)(getWorkerSrc()), window.pdfjsWorker.WorkerMessageHandler
                            };
                            return loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject), fakeWorkerCapability.promise
                        }

                        function createCDNWrapper(i) {
                            const r = "importScripts('" + i + "');";
                            return URL.createObjectURL(new Blob([r]))
                        }
                        class PDFWorker {
                            constructor({
                                name: r = null,
                                port: n = null,
                                verbosity: s = (0, _util.getVerbosityLevel)()
                            } = {}) {
                                if (n && pdfWorkerPorts.has(n)) throw new Error("Cannot use more than one PDFWorker per port");
                                if (this.name = r, this.destroyed = !1, this.postMessageTransfers = !0, this.verbosity = s, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, n) {
                                    pdfWorkerPorts.set(n, this), this._initializeFromPort(n);
                                    return
                                }
                                this._initialize()
                            }
                            get promise() {
                                return this._readyCapability.promise
                            }
                            get port() {
                                return this._port
                            }
                            get messageHandler() {
                                return this._messageHandler
                            }
                            _initializeFromPort(r) {
                                this._port = r, this._messageHandler = new _message_handler.MessageHandler("main", "worker", r), this._messageHandler.on("ready", function() {}), this._readyCapability.resolve()
                            }
                            _initialize() {
                                if (typeof Worker < "u" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                                    let r = getWorkerSrc();
                                    try {
                                        (0, _util.isSameOrigin)(window.location.href, r) || (r = createCDNWrapper(new URL(r, window.location).href));
                                        const n = new Worker(r),
                                            s = new _message_handler.MessageHandler("main", "worker", n),
                                            a = () => {
                                                n.removeEventListener("error", o), s.destroy(), n.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker()
                                            },
                                            o = () => {
                                                this._webWorker || a()
                                            };
                                        n.addEventListener("error", o), s.on("test", p => {
                                            if (n.removeEventListener("error", o), this.destroyed) {
                                                a();
                                                return
                                            }
                                            p ? (this._messageHandler = s, this._port = n, this._webWorker = n, p.supportTransfers || (this.postMessageTransfers = !1), this._readyCapability.resolve(), s.send("configure", {
                                                verbosity: this.verbosity
                                            })) : (this._setupFakeWorker(), s.destroy(), n.terminate())
                                        }), s.on("ready", p => {
                                            if (n.removeEventListener("error", o), this.destroyed) {
                                                a();
                                                return
                                            }
                                            try {
                                                c()
                                            } catch {
                                                this._setupFakeWorker()
                                            }
                                        });
                                        const c = () => {
                                            const p = new Uint8Array([this.postMessageTransfers ? 255 : 0]);
                                            try {
                                                s.send("test", p, [p.buffer])
                                            } catch {
                                                (0, _util.warn)("Cannot use postMessage transfers."), p[0] = 0, s.send("test", p)
                                            }
                                        };
                                        c();
                                        return
                                    } catch {
                                        (0, _util.info)("The worker has been disabled.")
                                    }
                                }
                                this._setupFakeWorker()
                            }
                            _setupFakeWorker() {
                                isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), isWorkerDisabled = !0), setupFakeWorkerGlobal().then(r => {
                                    if (this.destroyed) {
                                        this._readyCapability.reject(new Error("Worker was destroyed"));
                                        return
                                    }
                                    const n = new LoopbackPort;
                                    this._port = n;
                                    const s = "fake" + nextFakeWorkerId++,
                                        a = new _message_handler.MessageHandler(s + "_worker", s, n);
                                    r.setup(a, n);
                                    const o = new _message_handler.MessageHandler(s, s + "_worker", n);
                                    this._messageHandler = o, this._readyCapability.resolve(), o.send("configure", {
                                        verbosity: this.verbosity
                                    })
                                }).catch(r => {
                                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${r.message}".`))
                                })
                            }
                            destroy() {
                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), pdfWorkerPorts.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null)
                            }
                            static fromPort(r) {
                                if (!r || !r.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
                                return pdfWorkerPorts.has(r.port) ? pdfWorkerPorts.get(r.port) : new PDFWorker(r)
                            }
                            static getWorkerSrc() {
                                return getWorkerSrc()
                            }
                        }
                        return PDFWorker
                    }();
                    exports.PDFWorker = PDFWorker;
                    class WorkerTransport {
                        constructor(r, n, s, a) {
                            this.messageHandler = r, this.loadingTask = n, this.commonObjs = new PDFObjects, this.fontLoader = new _font_loader.FontLoader({
                                docId: n.docId,
                                onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
                            }), this._params = a, this.CMapReaderFactory = new a.CMapReaderFactory({
                                baseUrl: a.cMapUrl,
                                isCompressed: a.cMapPacked
                            }), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.pageCache = [], this.pagePromises = [], this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler()
                        }
                        destroy() {
                            if (this.destroyCapability) return this.destroyCapability.promise;
                            this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                            const r = [];
                            this.pageCache.forEach(function(s) {
                                s && r.push(s._destroy())
                            }), this.pageCache.length = 0, this.pagePromises.length = 0;
                            const n = this.messageHandler.sendWithPromise("Terminate", null);
                            return r.push(n), Promise.all(r).then(() => {
                                this.fontLoader.clear(), this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve()
                            }, this.destroyCapability.reject), this.destroyCapability.promise
                        }
                        setupMessageHandler() {
                            const {
                                messageHandler: r,
                                loadingTask: n
                            } = this;
                            r.on("GetReader", (s, a) => {
                                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = o => {
                                    this._lastProgress = {
                                        loaded: o.loaded,
                                        total: o.total
                                    }
                                }, a.onPull = () => {
                                    this._fullReader.read().then(function({
                                        value: o,
                                        done: c
                                    }) {
                                        if (c) {
                                            a.close();
                                            return
                                        }(0, _util.assert)((0, _util.isArrayBuffer)(o), "GetReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(o), 1, [o])
                                    }).catch(o => {
                                        a.error(o)
                                    })
                                }, a.onCancel = o => {
                                    this._fullReader.cancel(o)
                                }
                            }), r.on("ReaderHeadersReady", s => {
                                const a = (0, _util.createPromiseCapability)(),
                                    o = this._fullReader;
                                return o.headersReady.then(() => {
                                    (!o.isStreamingSupported || !o.isRangeSupported) && (this._lastProgress && n.onProgress && n.onProgress(this._lastProgress), o.onProgress = c => {
                                        n.onProgress && n.onProgress({
                                            loaded: c.loaded,
                                            total: c.total
                                        })
                                    }), a.resolve({
                                        isStreamingSupported: o.isStreamingSupported,
                                        isRangeSupported: o.isRangeSupported,
                                        contentLength: o.contentLength
                                    })
                                }, a.reject), a.promise
                            }), r.on("GetRangeReader", (s, a) => {
                                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                                const o = this._networkStream.getRangeReader(s.begin, s.end);
                                if (!o) {
                                    a.close();
                                    return
                                }
                                a.onPull = () => {
                                    o.read().then(function({
                                        value: c,
                                        done: p
                                    }) {
                                        if (p) {
                                            a.close();
                                            return
                                        }(0, _util.assert)((0, _util.isArrayBuffer)(c), "GetRangeReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(c), 1, [c])
                                    }).catch(c => {
                                        a.error(c)
                                    })
                                }, a.onCancel = c => {
                                    o.cancel(c)
                                }
                            }), r.on("GetDoc", ({
                                pdfInfo: s
                            }) => {
                                this._numPages = s.numPages, n._capability.resolve(new PDFDocumentProxy(s, this))
                            }), r.on("DocException", function(s) {
                                let a;
                                switch (s.name) {
                                    case "PasswordException":
                                        a = new _util.PasswordException(s.message, s.code);
                                        break;
                                    case "InvalidPDFException":
                                        a = new _util.InvalidPDFException(s.message);
                                        break;
                                    case "MissingPDFException":
                                        a = new _util.MissingPDFException(s.message);
                                        break;
                                    case "UnexpectedResponseException":
                                        a = new _util.UnexpectedResponseException(s.message, s.status);
                                        break;
                                    case "UnknownErrorException":
                                        a = new _util.UnknownErrorException(s.message, s.details);
                                        break
                                }
                                n._capability.reject(a)
                            }), r.on("PasswordRequest", s => {
                                if (this._passwordCapability = (0, _util.createPromiseCapability)(), n.onPassword) {
                                    const a = o => {
                                        this._passwordCapability.resolve({
                                            password: o
                                        })
                                    };
                                    try {
                                        n.onPassword(a, s.code)
                                    } catch (o) {
                                        this._passwordCapability.reject(o)
                                    }
                                } else this._passwordCapability.reject(new _util.PasswordException(s.message, s.code));
                                return this._passwordCapability.promise
                            }), r.on("DataLoaded", s => {
                                n.onProgress && n.onProgress({
                                    loaded: s.length,
                                    total: s.length
                                }), this.downloadInfoCapability.resolve(s)
                            }), r.on("StartRenderPage", s => {
                                if (this.destroyed) return;
                                this.pageCache[s.pageIndex]._startRenderPage(s.transparency, s.intent)
                            }), r.on("commonobj", s => {
                                if (this.destroyed) return;
                                const [a, o, c] = s;
                                if (!this.commonObjs.has(a)) switch (o) {
                                    case "Font":
                                        const p = this._params;
                                        if ("error" in c) {
                                            const l = c.error;
                                            (0, _util.warn)(`Error during font loading: ${l}`), this.commonObjs.resolve(a, l);
                                            break
                                        }
                                        let h = null;
                                        p.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled && (h = {
                                            registerFont(l, v) {
                                                globalThis.FontInspector.fontAdded(l, v)
                                            }
                                        });
                                        const u = new _font_loader.FontFaceObject(c, {
                                            isEvalSupported: p.isEvalSupported,
                                            disableFontFace: p.disableFontFace,
                                            ignoreErrors: p.ignoreErrors,
                                            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                                            fontRegistry: h
                                        });
                                        this.fontLoader.bind(u).catch(l => r.sendWithPromise("FontFallback", {
                                            id: a
                                        })).finally(() => {
                                            !p.fontExtraProperties && u.data && (u.data = null), this.commonObjs.resolve(a, u)
                                        });
                                        break;
                                    case "FontPath":
                                    case "FontType3Res":
                                    case "Image":
                                        this.commonObjs.resolve(a, c);
                                        break;
                                    default:
                                        throw new Error(`Got unknown common object type ${o}`)
                                }
                            }), r.on("obj", s => {
                                if (this.destroyed) return;
                                const [a, o, c, p] = s, h = this.pageCache[o];
                                if (!h.objs.has(a)) switch (c) {
                                    case "Image":
                                        h.objs.resolve(a, p);
                                        const u = 8e6;
                                        p && "data" in p && p.data.length > u && (h.cleanupAfterRender = !0);
                                        break;
                                    default:
                                        throw new Error(`Got unknown object type ${c}`)
                                }
                            }), r.on("DocProgress", s => {
                                this.destroyed || n.onProgress && n.onProgress({
                                    loaded: s.loaded,
                                    total: s.total
                                })
                            }), r.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), r.on("FetchBuiltInCMap", (s, a) => {
                                if (this.destroyed) {
                                    a.error(new Error("Worker was destroyed"));
                                    return
                                }
                                let o = !1;
                                a.onPull = () => {
                                    if (o) {
                                        a.close();
                                        return
                                    }
                                    o = !0, this.CMapReaderFactory.fetch(s).then(function(c) {
                                        a.enqueue(c, 1, [c.cMapData.buffer])
                                    }).catch(function(c) {
                                        a.error(c)
                                    })
                                }
                            })
                        }
                        _onUnsupportedFeature({
                            featureId: r
                        }) {
                            this.destroyed || this.loadingTask.onUnsupportedFeature && this.loadingTask.onUnsupportedFeature(r)
                        }
                        getData() {
                            return this.messageHandler.sendWithPromise("GetData", null)
                        }
                        getPage(r) {
                            if (!Number.isInteger(r) || r <= 0 || r > this._numPages) return Promise.reject(new Error("Invalid page request"));
                            const n = r - 1;
                            if (n in this.pagePromises) return this.pagePromises[n];
                            const s = this.messageHandler.sendWithPromise("GetPage", {
                                pageIndex: n
                            }).then(a => {
                                if (this.destroyed) throw new Error("Transport destroyed");
                                const o = new PDFPageProxy(n, a, this, this._params.pdfBug);
                                return this.pageCache[n] = o, o
                            });
                            return this.pagePromises[n] = s, s
                        }
                        getPageIndex(r) {
                            return this.messageHandler.sendWithPromise("GetPageIndex", {
                                ref: r
                            }).catch(function(n) {
                                return Promise.reject(new Error(n))
                            })
                        }
                        getAnnotations(r, n) {
                            return this.messageHandler.sendWithPromise("GetAnnotations", {
                                pageIndex: r,
                                intent: n
                            })
                        }
                        getDestinations() {
                            return this.messageHandler.sendWithPromise("GetDestinations", null)
                        }
                        getDestination(r) {
                            return typeof r != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                                id: r
                            })
                        }
                        getPageLabels() {
                            return this.messageHandler.sendWithPromise("GetPageLabels", null)
                        }
                        getPageLayout() {
                            return this.messageHandler.sendWithPromise("GetPageLayout", null)
                        }
                        getPageMode() {
                            return this.messageHandler.sendWithPromise("GetPageMode", null)
                        }
                        getViewerPreferences() {
                            return this.messageHandler.sendWithPromise("GetViewerPreferences", null)
                        }
                        getOpenAction() {
                            return this.messageHandler.sendWithPromise("GetOpenAction", null)
                        }
                        getAttachments() {
                            return this.messageHandler.sendWithPromise("GetAttachments", null)
                        }
                        getJavaScript() {
                            return this.messageHandler.sendWithPromise("GetJavaScript", null)
                        }
                        getOutline() {
                            return this.messageHandler.sendWithPromise("GetOutline", null)
                        }
                        getPermissions() {
                            return this.messageHandler.sendWithPromise("GetPermissions", null)
                        }
                        getMetadata() {
                            return this.messageHandler.sendWithPromise("GetMetadata", null).then(r => ({
                                info: r[0],
                                metadata: r[1] ? new _metadata.Metadata(r[1]) : null,
                                contentDispositionFilename: this._fullReader ? this._fullReader.filename : null
                            }))
                        }
                        getStats() {
                            return this.messageHandler.sendWithPromise("GetStats", null)
                        }
                        startCleanup() {
                            return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {
                                for (let r = 0, n = this.pageCache.length; r < n; r++) {
                                    const s = this.pageCache[r];
                                    if (s && !s.cleanup()) throw new Error(`startCleanup: Page ${r+1} is currently rendering.`)
                                }
                                this.commonObjs.clear(), this.fontLoader.clear()
                            })
                        }
                        get loadingParams() {
                            const r = this._params;
                            return (0, _util.shadow)(this, "loadingParams", {
                                disableAutoFetch: r.disableAutoFetch,
                                disableFontFace: r.disableFontFace
                            })
                        }
                    }
                    class PDFObjects {
                        constructor() {
                            this._objs = Object.create(null)
                        }
                        _ensureObj(r) {
                            return this._objs[r] ? this._objs[r] : this._objs[r] = {
                                capability: (0, _util.createPromiseCapability)(),
                                data: null,
                                resolved: !1
                            }
                        }
                        get(r, n = null) {
                            if (n) return this._ensureObj(r).capability.promise.then(n), null;
                            const s = this._objs[r];
                            if (!s || !s.resolved) throw new Error(`Requesting object that isn't resolved yet ${r}.`);
                            return s.data
                        }
                        has(r) {
                            const n = this._objs[r];
                            return n ? n.resolved : !1
                        }
                        resolve(r, n) {
                            const s = this._ensureObj(r);
                            s.resolved = !0, s.data = n, s.capability.resolve(n)
                        }
                        clear() {
                            this._objs = Object.create(null)
                        }
                    }
                    class RenderTask {
                        constructor(r) {
                            this._internalRenderTask = r, this.onContinue = null
                        }
                        get promise() {
                            return this._internalRenderTask.capability.promise
                        }
                        cancel() {
                            this._internalRenderTask.cancel()
                        }
                    }
                    const InternalRenderTask = function i() {
                            const r = new WeakSet;
                            class n {
                                constructor({
                                    callback: a,
                                    params: o,
                                    objs: c,
                                    commonObjs: p,
                                    operatorList: h,
                                    pageIndex: u,
                                    canvasFactory: l,
                                    webGLContext: v,
                                    useRequestAnimationFrame: w = !1,
                                    pdfBug: m = !1
                                }) {
                                    this.callback = a, this.params = o, this.objs = c, this.commonObjs = p, this.operatorListIdx = null, this.operatorList = h, this._pageIndex = u, this.canvasFactory = l, this.webGLContext = v, this._pdfBug = m, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = w === !0 && typeof window < "u", this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = o.canvasContext.canvas
                                }
                                initializeGraphics(a = !1) {
                                    if (this.cancelled) return;
                                    if (this._canvas) {
                                        if (r.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                                        r.add(this._canvas)
                                    }
                                    this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
                                    const {
                                        canvasContext: o,
                                        viewport: c,
                                        transform: p,
                                        imageLayer: h,
                                        background: u
                                    } = this.params;
                                    this.gfx = new _canvas.CanvasGraphics(o, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, h), this.gfx.beginDrawing({
                                        transform: p,
                                        viewport: c,
                                        transparency: a,
                                        background: u
                                    }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback()
                                }
                                cancel(a = null) {
                                    this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && r.delete(this._canvas), this.callback(a || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex+1}`, "canvas"))
                                }
                                operatorListChanged() {
                                    if (!this.graphicsReady) {
                                        this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                                        return
                                    }
                                    this.stepper && this.stepper.updateOperatorList(this.operatorList), !this.running && this._continue()
                                }
                                _continue() {
                                    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext())
                                }
                                _scheduleNext() {
                                    this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                                        this._nextBound().catch(this.cancel.bind(this))
                                    }) : Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this))
                                }
                                async _next() {
                                    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && r.delete(this._canvas), this.callback())))
                                }
                            }
                            return n
                        }(),
                        version = "2.5.207";
                    exports.version = version;
                    const build = "0974d605";
                    exports.build = build
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.FontLoader = r.FontFaceObject = void 0;
                    var s = n(2);
                    class a {
                        constructor({
                            docId: h,
                            onUnsupportedFeature: u
                        }) {
                            this.constructor === a && (0, s.unreachable)("Cannot initialize BaseFontLoader."), this.docId = h, this._onUnsupportedFeature = u, this.nativeFontFaces = [], this.styleElement = null
                        }
                        addNativeFontFace(h) {
                            this.nativeFontFaces.push(h), document.fonts.add(h)
                        }
                        insertRule(h) {
                            let u = this.styleElement;
                            u || (u = this.styleElement = document.createElement("style"), u.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, document.documentElement.getElementsByTagName("head")[0].appendChild(u));
                            const l = u.sheet;
                            l.insertRule(h, l.cssRules.length)
                        }
                        clear() {
                            this.nativeFontFaces.forEach(function(h) {
                                document.fonts.delete(h)
                            }), this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null)
                        }
                        async bind(h) {
                            if (h.attached || h.missingFile) return;
                            if (h.attached = !0, this.isFontLoadingAPISupported) {
                                const l = h.createNativeFontFace();
                                if (l) {
                                    this.addNativeFontFace(l);
                                    try {
                                        await l.loaded
                                    } catch (v) {
                                        throw this._onUnsupportedFeature({
                                            featureId: s.UNSUPPORTED_FEATURES.errorFontLoadNative
                                        }), (0, s.warn)(`Failed to load font '${l.family}': '${v}'.`), h.disableFontFace = !0, v
                                    }
                                }
                                return
                            }
                            const u = h.createFontFaceRule();
                            if (u) {
                                if (this.insertRule(u), this.isSyncFontLoadingSupported) return;
                                await new Promise(l => {
                                    const v = this._queueLoadingCallback(l);
                                    this._prepareFontLoadEvent([u], [h], v)
                                })
                            }
                        }
                        _queueLoadingCallback(h) {
                            (0, s.unreachable)("Abstract method `_queueLoadingCallback`.")
                        }
                        get isFontLoadingAPISupported() {
                            const h = typeof document < "u" && !!document.fonts;
                            return (0, s.shadow)(this, "isFontLoadingAPISupported", h)
                        }
                        get isSyncFontLoadingSupported() {
                            (0, s.unreachable)("Abstract method `isSyncFontLoadingSupported`.")
                        }
                        get _loadTestFont() {
                            (0, s.unreachable)("Abstract method `_loadTestFont`.")
                        }
                        _prepareFontLoadEvent(h, u, l) {
                            (0, s.unreachable)("Abstract method `_prepareFontLoadEvent`.")
                        }
                    }
                    let o;
                    r.FontLoader = o, r.FontLoader = o = class extends a {
                        constructor(h) {
                            super(h), this.loadingContext = {
                                requests: [],
                                nextRequestId: 0
                            }, this.loadTestFontId = 0
                        }
                        get isSyncFontLoadingSupported() {
                            let h = !1;
                            if (typeof navigator > "u") h = !0;
                            else {
                                const u = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                                u && u[1] >= 14 && (h = !0)
                            }
                            return (0, s.shadow)(this, "isSyncFontLoadingSupported", h)
                        }
                        _queueLoadingCallback(h) {
                            function u() {
                                for ((0, s.assert)(!v.done, "completeRequest() cannot be called twice."), v.done = !0; l.requests.length > 0 && l.requests[0].done;) {
                                    const w = l.requests.shift();
                                    setTimeout(w.callback, 0)
                                }
                            }
                            const l = this.loadingContext,
                                v = {
                                    id: `pdfjs-font-loading-${l.nextRequestId++}`,
                                    done: !1,
                                    complete: u,
                                    callback: h
                                };
                            return l.requests.push(v), v
                        }
                        get _loadTestFont() {
                            const h = function() {
                                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==")
                            };
                            return (0, s.shadow)(this, "_loadTestFont", h())
                        }
                        _prepareFontLoadEvent(h, u, l) {
                            function v(F, L) {
                                return F.charCodeAt(L) << 24 | F.charCodeAt(L + 1) << 16 | F.charCodeAt(L + 2) << 8 | F.charCodeAt(L + 3) & 255
                            }

                            function w(F, L, G, M) {
                                const _ = F.substring(0, L),
                                    A = F.substring(L + G);
                                return _ + M + A
                            }
                            let m, S;
                            const C = document.createElement("canvas");
                            C.width = 1, C.height = 1;
                            const O = C.getContext("2d");
                            let x = 0;

                            function I(F, L) {
                                if (x++, x > 30) {
                                    (0, s.warn)("Load test font never loaded."), L();
                                    return
                                }
                                if (O.font = "30px " + F, O.fillText(".", 0, 20), O.getImageData(0, 0, 1, 1).data[3] > 0) {
                                    L();
                                    return
                                }
                                setTimeout(I.bind(null, F, L))
                            }
                            const B = `lt${Date.now()}${this.loadTestFontId++}`;
                            let b = this._loadTestFont;
                            b = w(b, 976, B.length, B);
                            const d = 16,
                                g = 1482184792;
                            let E = v(b, d);
                            for (m = 0, S = B.length - 3; m < S; m += 4) E = E - g + v(B, m) | 0;
                            m < B.length && (E = E - g + v(B + "XXX", m) | 0), b = w(b, d, 4, (0, s.string32)(E));
                            const T = `url(data:font/opentype;base64,${btoa(b)});`,
                                N = `@font-face {font-family:"${B}";src:${T}}`;
                            this.insertRule(N);
                            const P = [];
                            for (m = 0, S = u.length; m < S; m++) P.push(u[m].loadedName);
                            P.push(B);
                            const U = document.createElement("div");
                            for (U.style.visibility = "hidden", U.style.width = U.style.height = "10px", U.style.position = "absolute", U.style.top = U.style.left = "0px", m = 0, S = P.length; m < S; ++m) {
                                const F = document.createElement("span");
                                F.textContent = "Hi", F.style.fontFamily = P[m], U.appendChild(F)
                            }
                            document.body.appendChild(U), I(B, function() {
                                document.body.removeChild(U), l.complete()
                            })
                        }
                    };
                    class c {
                        constructor(h, {
                            isEvalSupported: u = !0,
                            disableFontFace: l = !1,
                            ignoreErrors: v = !1,
                            onUnsupportedFeature: w = null,
                            fontRegistry: m = null
                        }) {
                            this.compiledGlyphs = Object.create(null);
                            for (const S in h) this[S] = h[S];
                            this.isEvalSupported = u !== !1, this.disableFontFace = l === !0, this.ignoreErrors = v === !0, this._onUnsupportedFeature = w, this.fontRegistry = m
                        }
                        createNativeFontFace() {
                            if (!this.data || this.disableFontFace) return null;
                            const h = new FontFace(this.loadedName, this.data, {});
                            return this.fontRegistry && this.fontRegistry.registerFont(this), h
                        }
                        createFontFaceRule() {
                            if (!this.data || this.disableFontFace) return null;
                            const h = (0, s.bytesToString)(new Uint8Array(this.data)),
                                u = `url(data:${this.mimetype};base64,${btoa(h)});`,
                                l = `@font-face {font-family:"${this.loadedName}";src:${u}}`;
                            return this.fontRegistry && this.fontRegistry.registerFont(this, u), l
                        }
                        getPathGenerator(h, u) {
                            if (this.compiledGlyphs[u] !== void 0) return this.compiledGlyphs[u];
                            let l, v;
                            try {
                                l = h.get(this.loadedName + "_path_" + u)
                            } catch (w) {
                                if (!this.ignoreErrors) throw w;
                                return this._onUnsupportedFeature && this._onUnsupportedFeature({
                                    featureId: s.UNSUPPORTED_FEATURES.errorFontGetPath
                                }), (0, s.warn)(`getPathGenerator - ignoring character: "${w}".`), this.compiledGlyphs[u] = function(m, S) {}
                            }
                            if (this.isEvalSupported && s.IsEvalSupportedCached.value) {
                                let w, m = "";
                                for (let S = 0, C = l.length; S < C; S++) v = l[S], v.args !== void 0 ? w = v.args.join(",") : w = "", m += "c." + v.cmd + "(" + w + `);
`;
                                return this.compiledGlyphs[u] = new Function("c", "size", m)
                            }
                            return this.compiledGlyphs[u] = function(w, m) {
                                for (let S = 0, C = l.length; S < C; S++) v = l[S], v.cmd === "scale" && (v.args = [m, -m]), w[v.cmd].apply(w, v.args)
                            }
                        }
                    }
                    r.FontFaceObject = c
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.apiCompatibilityParams = void 0;
                    var s = n(4);
                    const a = Object.create(null);
                    (function() {
                        s.isNodeJS && (a.disableFontFace = !0)
                    })();
                    const o = Object.freeze(a);
                    r.apiCompatibilityParams = o
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.CanvasGraphics = void 0;
                    var s = n(2),
                        a = n(9),
                        o = 16,
                        c = 100,
                        p = 4096,
                        h = .65,
                        u = 1e3,
                        l = 16;

                    function v(O) {
                        O.mozCurrentTransform || (O._originalSave = O.save, O._originalRestore = O.restore, O._originalRotate = O.rotate, O._originalScale = O.scale, O._originalTranslate = O.translate, O._originalTransform = O.transform, O._originalSetTransform = O.setTransform, O._transformMatrix = O._transformMatrix || [1, 0, 0, 1, 0, 0], O._transformStack = [], Object.defineProperty(O, "mozCurrentTransform", {
                            get: function() {
                                return this._transformMatrix
                            }
                        }), Object.defineProperty(O, "mozCurrentTransformInverse", {
                            get: function() {
                                var I = this._transformMatrix,
                                    B = I[0],
                                    b = I[1],
                                    f = I[2],
                                    d = I[3],
                                    g = I[4],
                                    E = I[5],
                                    T = B * d - b * f,
                                    N = b * f - B * d;
                                return [d / T, b / N, f / N, B / T, (d * g - f * E) / N, (b * g - B * E) / T]
                            }
                        }), O.save = function() {
                            var I = this._transformMatrix;
                            this._transformStack.push(I), this._transformMatrix = I.slice(0, 6), this._originalSave()
                        }, O.restore = function() {
                            var I = this._transformStack.pop();
                            I && (this._transformMatrix = I, this._originalRestore())
                        }, O.translate = function(I, B) {
                            var b = this._transformMatrix;
                            b[4] = b[0] * I + b[2] * B + b[4], b[5] = b[1] * I + b[3] * B + b[5], this._originalTranslate(I, B)
                        }, O.scale = function(I, B) {
                            var b = this._transformMatrix;
                            b[0] = b[0] * I, b[1] = b[1] * I, b[2] = b[2] * B, b[3] = b[3] * B, this._originalScale(I, B)
                        }, O.transform = function(I, B, b, f, d, g) {
                            var E = this._transformMatrix;
                            this._transformMatrix = [E[0] * I + E[2] * B, E[1] * I + E[3] * B, E[0] * b + E[2] * f, E[1] * b + E[3] * f, E[0] * d + E[2] * g + E[4], E[1] * d + E[3] * g + E[5]], O._originalTransform(I, B, b, f, d, g)
                        }, O.setTransform = function(I, B, b, f, d, g) {
                            this._transformMatrix = [I, B, b, f, d, g], O._originalSetTransform(I, B, b, f, d, g)
                        }, O.rotate = function(I) {
                            var B = Math.cos(I),
                                b = Math.sin(I),
                                f = this._transformMatrix;
                            this._transformMatrix = [f[0] * B + f[2] * b, f[1] * B + f[3] * b, f[0] * -b + f[2] * B, f[1] * -b + f[3] * B, f[4], f[5]], this._originalRotate(I)
                        })
                    }
                    var w = function() {
                        function x(I) {
                            this.canvasFactory = I, this.cache = Object.create(null)
                        }
                        return x.prototype = {
                            getCanvas: function(B, b, f, d) {
                                var g;
                                return this.cache[B] !== void 0 ? (g = this.cache[B], this.canvasFactory.reset(g, b, f), g.context.setTransform(1, 0, 0, 1, 0, 0)) : (g = this.canvasFactory.create(b, f), this.cache[B] = g), d && v(g.context), g
                            },
                            clear() {
                                for (var I in this.cache) {
                                    var B = this.cache[I];
                                    this.canvasFactory.destroy(B), delete this.cache[I]
                                }
                            }
                        }, x
                    }();

                    function m(O) {
                        var x = 1e3,
                            I = O.width,
                            B = O.height,
                            b, f, d, g = I + 1,
                            E = new Uint8Array(g * (B + 1)),
                            T = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
                            N = I + 7 & -8,
                            P = O.data,
                            U = new Uint8Array(N * B),
                            F = 0,
                            L;
                        for (b = 0, L = P.length; b < L; b++)
                            for (var G = 128, M = P[b]; G > 0;) U[F++] = M & G ? 0 : 255, G >>= 1;
                        var _ = 0;
                        for (F = 0, U[F] !== 0 && (E[0] = 1, ++_), f = 1; f < I; f++) U[F] !== U[F + 1] && (E[f] = U[F] ? 2 : 1, ++_), F++;
                        for (U[F] !== 0 && (E[f] = 2, ++_), b = 1; b < B; b++) {
                            F = b * N, d = b * g, U[F - N] !== U[F] && (E[d] = U[F] ? 1 : 8, ++_);
                            var A = (U[F] ? 4 : 0) + (U[F - N] ? 8 : 0);
                            for (f = 1; f < I; f++) A = (A >> 2) + (U[F + 1] ? 4 : 0) + (U[F - N + 1] ? 8 : 0), T[A] && (E[d + f] = T[A], ++_), F++;
                            if (U[F - N] !== U[F] && (E[d + f] = U[F] ? 2 : 4, ++_), _ > x) return null
                        }
                        for (F = N * (B - 1), d = b * g, U[F] !== 0 && (E[d] = 8, ++_), f = 1; f < I; f++) U[F] !== U[F + 1] && (E[d + f] = U[F] ? 4 : 8, ++_), F++;
                        if (U[F] !== 0 && (E[d + f] = 4, ++_), _ > x) return null;
                        var y = new Int32Array([0, g, -1, 0, -g, 0, 0, 0, 1]),
                            k = [];
                        for (b = 0; _ && b <= B; b++) {
                            for (var R = b * g, D = R + I; R < D && !E[R];) R++;
                            if (R !== D) {
                                var H = [R % g, b],
                                    q = E[R],
                                    z = R,
                                    j;
                                do {
                                    var V = y[q];
                                    do R += V; while (!E[R]);
                                    j = E[R], j !== 5 && j !== 10 ? (q = j, E[R] = 0) : (q = j & 51 * q >> 4, E[R] &= q >> 2 | q << 2), H.push(R % g), H.push(R / g | 0), E[R] || --_
                                } while (z !== R);
                                k.push(H), --b
                            }
                        }
                        var K = function(Y) {
                            Y.save(), Y.scale(1 / I, -1 / B), Y.translate(0, -B), Y.beginPath();
                            for (let ee = 0, J = k.length; ee < J; ee++) {
                                var Q = k[ee];
                                Y.moveTo(Q[0], Q[1]);
                                for (let ne = 2, se = Q.length; ne < se; ne += 2) Y.lineTo(Q[ne], Q[ne + 1])
                            }
                            Y.fill(), Y.beginPath(), Y.restore()
                        };
                        return K
                    }
                    var S = function() {
                            function x() {
                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = s.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = s.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = s.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.resumeSMaskCtx = null
                            }
                            return x.prototype = {
                                clone: function() {
                                    return Object.create(this)
                                },
                                setCurrentPoint: function(B, b) {
                                    this.x = B, this.y = b
                                }
                            }, x
                        }(),
                        C = function() {
                            var x = 15,
                                I = 10;

                            function B(A, y, k, R, D, H) {
                                this.ctx = A, this.current = new S, this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = y, this.objs = k, this.canvasFactory = R, this.webGLContext = D, this.imageLayer = H, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.cachedCanvases = new w(this.canvasFactory), A && v(A), this._cachedGetSinglePixelWidth = null
                            }

                            function b(A, y) {
                                if (typeof ImageData < "u" && y instanceof ImageData) {
                                    A.putImageData(y, 0, 0);
                                    return
                                }
                                var k = y.height,
                                    R = y.width,
                                    D = k % l,
                                    H = (k - D) / l,
                                    q = D === 0 ? H : H + 1,
                                    z = A.createImageData(R, l),
                                    j = 0,
                                    V, K = y.data,
                                    Y = z.data,
                                    Q, ee, J, ne;
                                if (y.kind === s.ImageKind.GRAYSCALE_1BPP) {
                                    var se = K.byteLength,
                                        ie = new Uint32Array(Y.buffer, 0, Y.byteLength >> 2),
                                        he = ie.length,
                                        fe = R + 7 >> 3,
                                        le = 4294967295,
                                        pe = s.IsLittleEndianCached.value ? 4278190080 : 255;
                                    for (Q = 0; Q < q; Q++) {
                                        for (J = Q < H ? l : D, V = 0, ee = 0; ee < J; ee++) {
                                            for (var de = se - j, oe = 0, ye = de > fe ? R : de * 8 - 7, we = ye & -8, Ae = 0, _e = 0; oe < we; oe += 8) _e = K[j++], ie[V++] = _e & 128 ? le : pe, ie[V++] = _e & 64 ? le : pe, ie[V++] = _e & 32 ? le : pe, ie[V++] = _e & 16 ? le : pe, ie[V++] = _e & 8 ? le : pe, ie[V++] = _e & 4 ? le : pe, ie[V++] = _e & 2 ? le : pe, ie[V++] = _e & 1 ? le : pe;
                                            for (; oe < ye; oe++) Ae === 0 && (_e = K[j++], Ae = 128), ie[V++] = _e & Ae ? le : pe, Ae >>= 1
                                        }
                                        for (; V < he;) ie[V++] = 0;
                                        A.putImageData(z, 0, Q * l)
                                    }
                                } else if (y.kind === s.ImageKind.RGBA_32BPP) {
                                    for (ee = 0, ne = R * l * 4, Q = 0; Q < H; Q++) Y.set(K.subarray(j, j + ne)), j += ne, A.putImageData(z, 0, ee), ee += l;
                                    Q < q && (ne = R * D * 4, Y.set(K.subarray(j, j + ne)), A.putImageData(z, 0, ee))
                                } else if (y.kind === s.ImageKind.RGB_24BPP)
                                    for (J = l, ne = R * J, Q = 0; Q < q; Q++) {
                                        for (Q >= H && (J = D, ne = R * J), V = 0, ee = ne; ee--;) Y[V++] = K[j++], Y[V++] = K[j++], Y[V++] = K[j++], Y[V++] = 255;
                                        A.putImageData(z, 0, Q * l)
                                    } else throw new Error(`bad image kind: ${y.kind}`)
                            }

                            function f(A, y) {
                                for (var k = y.height, R = y.width, D = k % l, H = (k - D) / l, q = D === 0 ? H : H + 1, z = A.createImageData(R, l), j = 0, V = y.data, K = z.data, Y = 0; Y < q; Y++) {
                                    for (var Q = Y < H ? l : D, ee = 3, J = 0; J < Q; J++)
                                        for (var ne = 0, se = 0; se < R; se++) {
                                            if (!ne) {
                                                var ie = V[j++];
                                                ne = 128
                                            }
                                            K[ee] = ie & ne ? 0 : 255, ee += 4, ne >>= 1
                                        }
                                    A.putImageData(z, 0, Y * l)
                                }
                            }

                            function d(A, y) {
                                for (var k = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"], R = 0, D = k.length; R < D; R++) {
                                    var H = k[R];
                                    A[H] !== void 0 && (y[H] = A[H])
                                }
                                A.setLineDash !== void 0 && (y.setLineDash(A.getLineDash()), y.lineDashOffset = A.lineDashOffset)
                            }

                            function g(A) {
                                A.strokeStyle = "#000000", A.fillStyle = "#000000", A.fillRule = "nonzero", A.globalAlpha = 1, A.lineWidth = 1, A.lineCap = "butt", A.lineJoin = "miter", A.miterLimit = 10, A.globalCompositeOperation = "source-over", A.font = "10px sans-serif", A.setLineDash !== void 0 && (A.setLineDash([]), A.lineDashOffset = 0)
                            }

                            function E(A, y, k, R) {
                                for (var D = A.length, H = 3; H < D; H += 4) {
                                    var q = A[H];
                                    if (q === 0) A[H - 3] = y, A[H - 2] = k, A[H - 1] = R;
                                    else if (q < 255) {
                                        var z = 255 - q;
                                        A[H - 3] = A[H - 3] * q + y * z >> 8, A[H - 2] = A[H - 2] * q + k * z >> 8, A[H - 1] = A[H - 1] * q + R * z >> 8
                                    }
                                }
                            }

                            function T(A, y, k) {
                                for (var R = A.length, D = 1 / 255, H = 3; H < R; H += 4) {
                                    var q = k ? k[A[H]] : A[H];
                                    y[H] = y[H] * q * D | 0
                                }
                            }

                            function N(A, y, k) {
                                for (var R = A.length, D = 3; D < R; D += 4) {
                                    var H = A[D - 3] * 77 + A[D - 2] * 152 + A[D - 1] * 28;
                                    y[D] = k ? y[D] * k[H >> 8] >> 8 : y[D] * H >> 16
                                }
                            }

                            function P(A, y, k, R, D, H, q) {
                                var z = !!H,
                                    j = z ? H[0] : 0,
                                    V = z ? H[1] : 0,
                                    K = z ? H[2] : 0,
                                    Y;
                                D === "Luminosity" ? Y = N : Y = T;
                                for (var Q = 1048576, ee = Math.min(R, Math.ceil(Q / k)), J = 0; J < R; J += ee) {
                                    var ne = Math.min(ee, R - J),
                                        se = A.getImageData(0, J, k, ne),
                                        ie = y.getImageData(0, J, k, ne);
                                    z && E(se.data, j, V, K), Y(se.data, ie.data, q), A.putImageData(ie, 0, J)
                                }
                            }

                            function U(A, y, k, R) {
                                var D = y.canvas,
                                    H = y.context;
                                A.setTransform(y.scaleX, 0, 0, y.scaleY, y.offsetX, y.offsetY);
                                var q = y.backdrop || null;
                                if (!y.transferMap && R.isEnabled) {
                                    const z = R.composeSMask({
                                        layer: k.canvas,
                                        mask: D,
                                        properties: {
                                            subtype: y.subtype,
                                            backdrop: q
                                        }
                                    });
                                    A.setTransform(1, 0, 0, 1, 0, 0), A.drawImage(z, y.offsetX, y.offsetY);
                                    return
                                }
                                P(H, k, D.width, D.height, y.subtype, q, y.transferMap), A.drawImage(D, 0, 0)
                            }
                            var F = ["butt", "round", "square"],
                                L = ["miter", "round", "bevel"],
                                G = {},
                                M = {};
                            B.prototype = {
                                beginDrawing({
                                    transform: A,
                                    viewport: y,
                                    transparency: k = !1,
                                    background: R = null
                                }) {
                                    var D = this.ctx.canvas.width,
                                        H = this.ctx.canvas.height;
                                    if (this.ctx.save(), this.ctx.fillStyle = R || "rgb(255, 255, 255)", this.ctx.fillRect(0, 0, D, H), this.ctx.restore(), k) {
                                        var q = this.cachedCanvases.getCanvas("transparent", D, H, !0);
                                        this.compositeCtx = this.ctx, this.transparentCanvas = q.canvas, this.ctx = q.context, this.ctx.save(), this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform)
                                    }
                                    this.ctx.save(), g(this.ctx), A && this.ctx.transform.apply(this.ctx, A), this.ctx.transform.apply(this.ctx, y.transform), this.baseTransform = this.ctx.mozCurrentTransform.slice(), this.imageLayer && this.imageLayer.beginLayout()
                                },
                                executeOperatorList: function(y, k, R, D) {
                                    var H = y.argsArray,
                                        q = y.fnArray,
                                        z = k || 0,
                                        j = H.length;
                                    if (j === z) return z;
                                    for (var V = j - z > I && typeof R == "function", K = V ? Date.now() + x : 0, Y = 0, Q = this.commonObjs, ee = this.objs, J;;) {
                                        if (D !== void 0 && z === D.nextBreakPoint) return D.breakIt(z, R), z;
                                        if (J = q[z], J !== s.OPS.dependency) this[J].apply(this, H[z]);
                                        else
                                            for (const ne of H[z]) {
                                                const se = ne.startsWith("g_") ? Q : ee;
                                                if (!se.has(ne)) return se.get(ne, R), z
                                            }
                                        if (z++, z === j) return z;
                                        if (V && ++Y > I) {
                                            if (Date.now() > K) return R(), z;
                                            Y = 0
                                        }
                                    }
                                },
                                endDrawing: function() {
                                    this.current.activeSMask !== null && this.endSMaskGroup(), this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null), this.cachedCanvases.clear(), this.webGLContext.clear(), this.imageLayer && this.imageLayer.endLayout()
                                },
                                setLineWidth: function(y) {
                                    this.current.lineWidth = y, this.ctx.lineWidth = y
                                },
                                setLineCap: function(y) {
                                    this.ctx.lineCap = F[y]
                                },
                                setLineJoin: function(y) {
                                    this.ctx.lineJoin = L[y]
                                },
                                setMiterLimit: function(y) {
                                    this.ctx.miterLimit = y
                                },
                                setDash: function(y, k) {
                                    var R = this.ctx;
                                    R.setLineDash !== void 0 && (R.setLineDash(y), R.lineDashOffset = k)
                                },
                                setRenderingIntent(A) {},
                                setFlatness(A) {},
                                setGState: function(y) {
                                    for (var k = 0, R = y.length; k < R; k++) {
                                        var D = y[k],
                                            H = D[0],
                                            q = D[1];
                                        switch (H) {
                                            case "LW":
                                                this.setLineWidth(q);
                                                break;
                                            case "LC":
                                                this.setLineCap(q);
                                                break;
                                            case "LJ":
                                                this.setLineJoin(q);
                                                break;
                                            case "ML":
                                                this.setMiterLimit(q);
                                                break;
                                            case "D":
                                                this.setDash(q[0], q[1]);
                                                break;
                                            case "RI":
                                                this.setRenderingIntent(q);
                                                break;
                                            case "FL":
                                                this.setFlatness(q);
                                                break;
                                            case "Font":
                                                this.setFont(q[0], q[1]);
                                                break;
                                            case "CA":
                                                this.current.strokeAlpha = D[1];
                                                break;
                                            case "ca":
                                                this.current.fillAlpha = D[1], this.ctx.globalAlpha = D[1];
                                                break;
                                            case "BM":
                                                this.ctx.globalCompositeOperation = q;
                                                break;
                                            case "SMask":
                                                this.current.activeSMask && (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask ? this.suspendSMaskGroup() : this.endSMaskGroup()), this.current.activeSMask = q ? this.tempSMask : null, this.current.activeSMask && this.beginSMaskGroup(), this.tempSMask = null;
                                                break
                                        }
                                    }
                                },
                                beginSMaskGroup: function() {
                                    var y = this.current.activeSMask,
                                        k = y.canvas.width,
                                        R = y.canvas.height,
                                        D = "smaskGroupAt" + this.groupLevel,
                                        H = this.cachedCanvases.getCanvas(D, k, R, !0),
                                        q = this.ctx,
                                        z = q.mozCurrentTransform;
                                    this.ctx.save();
                                    var j = H.context;
                                    j.scale(1 / y.scaleX, 1 / y.scaleY), j.translate(-y.offsetX, -y.offsetY), j.transform.apply(j, z), y.startTransformInverse = j.mozCurrentTransformInverse, d(q, j), this.ctx = j, this.setGState([
                                        ["BM", "source-over"],
                                        ["ca", 1],
                                        ["CA", 1]
                                    ]), this.groupStack.push(q), this.groupLevel++
                                },
                                suspendSMaskGroup: function() {
                                    var y = this.ctx;
                                    this.groupLevel--, this.ctx = this.groupStack.pop(), U(this.ctx, this.current.activeSMask, y, this.webGLContext), this.ctx.restore(), this.ctx.save(), d(y, this.ctx), this.current.resumeSMaskCtx = y;
                                    var k = s.Util.transform(this.current.activeSMask.startTransformInverse, y.mozCurrentTransform);
                                    this.ctx.transform.apply(this.ctx, k), y.save(), y.setTransform(1, 0, 0, 1, 0, 0), y.clearRect(0, 0, y.canvas.width, y.canvas.height), y.restore()
                                },
                                resumeSMaskGroup: function() {
                                    var y = this.current.resumeSMaskCtx,
                                        k = this.ctx;
                                    this.ctx = y, this.groupStack.push(k), this.groupLevel++
                                },
                                endSMaskGroup: function() {
                                    var y = this.ctx;
                                    this.groupLevel--, this.ctx = this.groupStack.pop(), U(this.ctx, this.current.activeSMask, y, this.webGLContext), this.ctx.restore(), d(y, this.ctx);
                                    var k = s.Util.transform(this.current.activeSMask.startTransformInverse, y.mozCurrentTransform);
                                    this.ctx.transform.apply(this.ctx, k)
                                },
                                save: function() {
                                    this.ctx.save();
                                    var y = this.current;
                                    this.stateStack.push(y), this.current = y.clone(), this.current.resumeSMaskCtx = null
                                },
                                restore: function() {
                                    this.current.resumeSMaskCtx && this.resumeSMaskGroup(), this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask) && this.endSMaskGroup(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.ctx.restore(), this.pendingClip = null, this._cachedGetSinglePixelWidth = null)
                                },
                                transform: function(y, k, R, D, H, q) {
                                    this.ctx.transform(y, k, R, D, H, q), this._cachedGetSinglePixelWidth = null
                                },
                                constructPath: function(y, k) {
                                    for (var R = this.ctx, D = this.current, H = D.x, q = D.y, z = 0, j = 0, V = y.length; z < V; z++) switch (y[z] | 0) {
                                        case s.OPS.rectangle:
                                            H = k[j++], q = k[j++];
                                            var K = k[j++],
                                                Y = k[j++];
                                            K === 0 && (K = this.getSinglePixelWidth()), Y === 0 && (Y = this.getSinglePixelWidth());
                                            var Q = H + K,
                                                ee = q + Y;
                                            this.ctx.moveTo(H, q), this.ctx.lineTo(Q, q), this.ctx.lineTo(Q, ee), this.ctx.lineTo(H, ee), this.ctx.lineTo(H, q), this.ctx.closePath();
                                            break;
                                        case s.OPS.moveTo:
                                            H = k[j++], q = k[j++], R.moveTo(H, q);
                                            break;
                                        case s.OPS.lineTo:
                                            H = k[j++], q = k[j++], R.lineTo(H, q);
                                            break;
                                        case s.OPS.curveTo:
                                            H = k[j + 4], q = k[j + 5], R.bezierCurveTo(k[j], k[j + 1], k[j + 2], k[j + 3], H, q), j += 6;
                                            break;
                                        case s.OPS.curveTo2:
                                            R.bezierCurveTo(H, q, k[j], k[j + 1], k[j + 2], k[j + 3]), H = k[j + 2], q = k[j + 3], j += 4;
                                            break;
                                        case s.OPS.curveTo3:
                                            H = k[j + 2], q = k[j + 3], R.bezierCurveTo(k[j], k[j + 1], H, q, H, q), j += 4;
                                            break;
                                        case s.OPS.closePath:
                                            R.closePath();
                                            break
                                    }
                                    D.setCurrentPoint(H, q)
                                },
                                closePath: function() {
                                    this.ctx.closePath()
                                },
                                stroke: function(y) {
                                    y = typeof y < "u" ? y : !0;
                                    var k = this.ctx,
                                        R = this.current.strokeColor;
                                    if (k.globalAlpha = this.current.strokeAlpha, R && R.hasOwnProperty("type") && R.type === "Pattern") {
                                        k.save();
                                        const D = k.mozCurrentTransform,
                                            H = s.Util.singularValueDecompose2dScale(D)[0];
                                        k.strokeStyle = R.getPattern(k, this), k.lineWidth = Math.max(this.getSinglePixelWidth() * h, this.current.lineWidth * H), k.stroke(), k.restore()
                                    } else k.lineWidth = Math.max(this.getSinglePixelWidth() * h, this.current.lineWidth), k.stroke();
                                    y && this.consumePath(), k.globalAlpha = this.current.fillAlpha
                                },
                                closeStroke: function() {
                                    this.closePath(), this.stroke()
                                },
                                fill: function(y) {
                                    y = typeof y < "u" ? y : !0;
                                    var k = this.ctx,
                                        R = this.current.fillColor,
                                        D = this.current.patternFill,
                                        H = !1;
                                    D && (k.save(), this.baseTransform && k.setTransform.apply(k, this.baseTransform), k.fillStyle = R.getPattern(k, this), H = !0), this.pendingEOFill ? (k.fill("evenodd"), this.pendingEOFill = !1) : k.fill(), H && k.restore(), y && this.consumePath()
                                },
                                eoFill: function() {
                                    this.pendingEOFill = !0, this.fill()
                                },
                                fillStroke: function() {
                                    this.fill(!1), this.stroke(!1), this.consumePath()
                                },
                                eoFillStroke: function() {
                                    this.pendingEOFill = !0, this.fillStroke()
                                },
                                closeFillStroke: function() {
                                    this.closePath(), this.fillStroke()
                                },
                                closeEOFillStroke: function() {
                                    this.pendingEOFill = !0, this.closePath(), this.fillStroke()
                                },
                                endPath: function() {
                                    this.consumePath()
                                },
                                clip: function() {
                                    this.pendingClip = G
                                },
                                eoClip: function() {
                                    this.pendingClip = M
                                },
                                beginText: function() {
                                    this.current.textMatrix = s.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0
                                },
                                endText: function() {
                                    var y = this.pendingTextPaths,
                                        k = this.ctx;
                                    if (y === void 0) {
                                        k.beginPath();
                                        return
                                    }
                                    k.save(), k.beginPath();
                                    for (var R = 0; R < y.length; R++) {
                                        var D = y[R];
                                        k.setTransform.apply(k, D.transform), k.translate(D.x, D.y), D.addToPath(k, D.fontSize)
                                    }
                                    k.restore(), k.clip(), k.beginPath(), delete this.pendingTextPaths
                                },
                                setCharSpacing: function(y) {
                                    this.current.charSpacing = y
                                },
                                setWordSpacing: function(y) {
                                    this.current.wordSpacing = y
                                },
                                setHScale: function(y) {
                                    this.current.textHScale = y / 100
                                },
                                setLeading: function(y) {
                                    this.current.leading = -y
                                },
                                setFont: function(y, k) {
                                    var R = this.commonObjs.get(y),
                                        D = this.current;
                                    if (!R) throw new Error(`Can't find font for ${y}`);
                                    if (D.fontMatrix = R.fontMatrix ? R.fontMatrix : s.FONT_IDENTITY_MATRIX, (D.fontMatrix[0] === 0 || D.fontMatrix[3] === 0) && (0, s.warn)("Invalid font matrix for font " + y), k < 0 ? (k = -k, D.fontDirection = -1) : D.fontDirection = 1, this.current.font = R, this.current.fontSize = k, R.isType3Font) return;
                                    var H = R.loadedName || "sans-serif";
                                    let q = "normal";
                                    R.black ? q = "900" : R.bold && (q = "bold");
                                    var z = R.italic ? "italic" : "normal",
                                        j = `"${H}", ${R.fallbackName}`;
                                    let V = k;
                                    k < o ? V = o : k > c && (V = c), this.current.fontSizeScale = k / V, this.ctx.font = `${z} ${q} ${V}px ${j}`
                                },
                                setTextRenderingMode: function(y) {
                                    this.current.textRenderingMode = y
                                },
                                setTextRise: function(y) {
                                    this.current.textRise = y
                                },
                                moveText: function(y, k) {
                                    this.current.x = this.current.lineX += y, this.current.y = this.current.lineY += k
                                },
                                setLeadingMoveText: function(y, k) {
                                    this.setLeading(-k), this.moveText(y, k)
                                },
                                setTextMatrix: function(y, k, R, D, H, q) {
                                    this.current.textMatrix = [y, k, R, D, H, q], this.current.textMatrixScale = Math.sqrt(y * y + k * k), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0
                                },
                                nextLine: function() {
                                    this.moveText(0, this.current.leading)
                                },
                                paintChar(A, y, k, R) {
                                    var D = this.ctx,
                                        H = this.current,
                                        q = H.font,
                                        z = H.textRenderingMode,
                                        j = H.fontSize / H.fontSizeScale,
                                        V = z & s.TextRenderingMode.FILL_STROKE_MASK,
                                        K = !!(z & s.TextRenderingMode.ADD_TO_PATH_FLAG);
                                    const Y = H.patternFill && !q.missingFile;
                                    var Q;
                                    if ((q.disableFontFace || K || Y) && (Q = q.getPathGenerator(this.commonObjs, A)), q.disableFontFace || Y ? (D.save(), D.translate(y, k), D.beginPath(), Q(D, j), R && D.setTransform.apply(D, R), (V === s.TextRenderingMode.FILL || V === s.TextRenderingMode.FILL_STROKE) && D.fill(), (V === s.TextRenderingMode.STROKE || V === s.TextRenderingMode.FILL_STROKE) && D.stroke(), D.restore()) : ((V === s.TextRenderingMode.FILL || V === s.TextRenderingMode.FILL_STROKE) && D.fillText(A, y, k), (V === s.TextRenderingMode.STROKE || V === s.TextRenderingMode.FILL_STROKE) && D.strokeText(A, y, k)), K) {
                                        var ee = this.pendingTextPaths || (this.pendingTextPaths = []);
                                        ee.push({
                                            transform: D.mozCurrentTransform,
                                            x: y,
                                            y: k,
                                            fontSize: j,
                                            addToPath: Q
                                        })
                                    }
                                },
                                get isFontSubpixelAAEnabled() {
                                    const {
                                        context: A
                                    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                                    A.scale(1.5, 1), A.fillText("I", 0, 10);
                                    for (var y = A.getImageData(0, 0, 10, 10).data, k = !1, R = 3; R < y.length; R += 4)
                                        if (y[R] > 0 && y[R] < 255) {
                                            k = !0;
                                            break
                                        } return (0, s.shadow)(this, "isFontSubpixelAAEnabled", k)
                                },
                                showText: function(y) {
                                    var k = this.current,
                                        R = k.font;
                                    if (R.isType3Font) return this.showType3Text(y);
                                    var D = k.fontSize;
                                    if (D === 0) return;
                                    var H = this.ctx,
                                        q = k.fontSizeScale,
                                        z = k.charSpacing,
                                        j = k.wordSpacing,
                                        V = k.fontDirection,
                                        K = k.textHScale * V,
                                        Y = y.length,
                                        Q = R.vertical,
                                        ee = Q ? 1 : -1,
                                        J = R.defaultVMetrics,
                                        ne = D * k.fontMatrix[0],
                                        se = k.textRenderingMode === s.TextRenderingMode.FILL && !R.disableFontFace && !k.patternFill;
                                    H.save();
                                    let ie;
                                    if (k.patternFill) {
                                        H.save();
                                        const ue = k.fillColor.getPattern(H, this);
                                        ie = H.mozCurrentTransform, H.restore(), H.fillStyle = ue
                                    }
                                    H.transform.apply(H, k.textMatrix), H.translate(k.x, k.y + k.textRise), V > 0 ? H.scale(K, -1) : H.scale(K, 1);
                                    var he = k.lineWidth,
                                        fe = k.textMatrixScale;
                                    if (fe === 0 || he === 0) {
                                        var le = k.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK;
                                        (le === s.TextRenderingMode.STROKE || le === s.TextRenderingMode.FILL_STROKE) && (this._cachedGetSinglePixelWidth = null, he = this.getSinglePixelWidth() * h)
                                    } else he /= fe;
                                    q !== 1 && (H.scale(q, q), he /= q), H.lineWidth = he;
                                    var pe = 0,
                                        de;
                                    for (de = 0; de < Y; ++de) {
                                        var oe = y[de];
                                        if ((0, s.isNum)(oe)) {
                                            pe += ee * oe * D / 1e3;
                                            continue
                                        }
                                        var ye = !1,
                                            we = (oe.isSpace ? j : 0) + z,
                                            Ae = oe.fontChar,
                                            _e = oe.accent,
                                            ve, Ee, Ce, ke, me = oe.width;
                                        if (Q) {
                                            var Z, W, X;
                                            Z = oe.vmetric || J, W = oe.vmetric ? Z[1] : me * .5, W = -W * ne, X = Z[2] * ne, me = Z ? -Z[0] : me, ve = W / q, Ee = (pe + X) / q
                                        } else ve = pe / q, Ee = 0;
                                        if (R.remeasure && me > 0) {
                                            var te = H.measureText(Ae).width * 1e3 / D * q;
                                            if (me < te && this.isFontSubpixelAAEnabled) {
                                                var ae = me / te;
                                                ye = !0, H.save(), H.scale(ae, 1), ve /= ae
                                            } else me !== te && (ve += (me - te) / 2e3 * D / q)
                                        }(oe.isInFont || R.missingFile) && (se && !_e ? H.fillText(Ae, ve, Ee) : (this.paintChar(Ae, ve, Ee, ie), _e && (Ce = ve + _e.offset.x / q, ke = Ee - _e.offset.y / q, this.paintChar(_e.fontChar, Ce, ke, ie))));
                                        var ce;
                                        Q ? ce = me * ne - we * V : ce = me * ne + we * V, pe += ce, ye && H.restore()
                                    }
                                    Q ? k.y -= pe : k.x += pe * K, H.restore()
                                },
                                showType3Text: function(y) {
                                    var k = this.ctx,
                                        R = this.current,
                                        D = R.font,
                                        H = R.fontSize,
                                        q = R.fontDirection,
                                        z = D.vertical ? 1 : -1,
                                        j = R.charSpacing,
                                        V = R.wordSpacing,
                                        K = R.textHScale * q,
                                        Y = R.fontMatrix || s.FONT_IDENTITY_MATRIX,
                                        Q = y.length,
                                        ee = R.textRenderingMode === s.TextRenderingMode.INVISIBLE,
                                        J, ne, se, ie;
                                    if (!(ee || H === 0)) {
                                        for (this._cachedGetSinglePixelWidth = null, k.save(), k.transform.apply(k, R.textMatrix), k.translate(R.x, R.y), k.scale(K, q), J = 0; J < Q; ++J) {
                                            if (ne = y[J], (0, s.isNum)(ne)) {
                                                ie = z * ne * H / 1e3, this.ctx.translate(ie, 0), R.x += ie * K;
                                                continue
                                            }
                                            var he = (ne.isSpace ? V : 0) + j,
                                                fe = D.charProcOperatorList[ne.operatorListId];
                                            if (!fe) {
                                                (0, s.warn)(`Type3 character "${ne.operatorListId}" is not available.`);
                                                continue
                                            }
                                            this.processingType3 = ne, this.save(), k.scale(H, H), k.transform.apply(k, Y), this.executeOperatorList(fe), this.restore();
                                            var le = s.Util.applyTransform([ne.width, 0], Y);
                                            se = le[0] * H + he, k.translate(se, 0), R.x += se * K
                                        }
                                        k.restore(), this.processingType3 = null
                                    }
                                },
                                setCharWidth: function(y, k) {},
                                setCharWidthAndBounds: function(y, k, R, D, H, q) {
                                    this.ctx.rect(R, D, H - R, q - D), this.clip(), this.endPath()
                                },
                                getColorN_Pattern: function(y) {
                                    var k;
                                    if (y[0] === "TilingPattern") {
                                        var R = y[1],
                                            D = this.baseTransform || this.ctx.mozCurrentTransform.slice(),
                                            H = {
                                                createCanvasGraphics: q => new B(q, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext)
                                            };
                                        k = new a.TilingPattern(y, R, this.ctx, H, D)
                                    } else k = (0, a.getShadingPatternFromIR)(y);
                                    return k
                                },
                                setStrokeColorN: function() {
                                    this.current.strokeColor = this.getColorN_Pattern(arguments)
                                },
                                setFillColorN: function() {
                                    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0
                                },
                                setStrokeRGBColor: function(y, k, R) {
                                    var D = s.Util.makeCssRgb(y, k, R);
                                    this.ctx.strokeStyle = D, this.current.strokeColor = D
                                },
                                setFillRGBColor: function(y, k, R) {
                                    var D = s.Util.makeCssRgb(y, k, R);
                                    this.ctx.fillStyle = D, this.current.fillColor = D, this.current.patternFill = !1
                                },
                                shadingFill: function(y) {
                                    var k = this.ctx;
                                    this.save();
                                    var R = (0, a.getShadingPatternFromIR)(y);
                                    k.fillStyle = R.getPattern(k, this, !0);
                                    var D = k.mozCurrentTransformInverse;
                                    if (D) {
                                        var H = k.canvas,
                                            q = H.width,
                                            z = H.height,
                                            j = s.Util.applyTransform([0, 0], D),
                                            V = s.Util.applyTransform([0, z], D),
                                            K = s.Util.applyTransform([q, 0], D),
                                            Y = s.Util.applyTransform([q, z], D),
                                            Q = Math.min(j[0], V[0], K[0], Y[0]),
                                            ee = Math.min(j[1], V[1], K[1], Y[1]),
                                            J = Math.max(j[0], V[0], K[0], Y[0]),
                                            ne = Math.max(j[1], V[1], K[1], Y[1]);
                                        this.ctx.fillRect(Q, ee, J - Q, ne - ee)
                                    } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                                    this.restore()
                                },
                                beginInlineImage: function() {
                                    (0, s.unreachable)("Should not call beginInlineImage")
                                },
                                beginImageData: function() {
                                    (0, s.unreachable)("Should not call beginImageData")
                                },
                                paintFormXObjectBegin: function(y, k) {
                                    if (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(y) && y.length === 6 && this.transform.apply(this, y), this.baseTransform = this.ctx.mozCurrentTransform, k) {
                                        var R = k[2] - k[0],
                                            D = k[3] - k[1];
                                        this.ctx.rect(k[0], k[1], R, D), this.clip(), this.endPath()
                                    }
                                },
                                paintFormXObjectEnd: function() {
                                    this.restore(), this.baseTransform = this.baseTransformStack.pop()
                                },
                                beginGroup: function(y) {
                                    this.save();
                                    var k = this.ctx;
                                    y.isolated || (0, s.info)("TODO: Support non-isolated groups."), y.knockout && (0, s.warn)("Knockout groups not supported.");
                                    var R = k.mozCurrentTransform;
                                    if (y.matrix && k.transform.apply(k, y.matrix), !y.bbox) throw new Error("Bounding box is required.");
                                    var D = s.Util.getAxialAlignedBoundingBox(y.bbox, k.mozCurrentTransform),
                                        H = [0, 0, k.canvas.width, k.canvas.height];
                                    D = s.Util.intersect(D, H) || [0, 0, 0, 0];
                                    var q = Math.floor(D[0]),
                                        z = Math.floor(D[1]),
                                        j = Math.max(Math.ceil(D[2]) - q, 1),
                                        V = Math.max(Math.ceil(D[3]) - z, 1),
                                        K = 1,
                                        Y = 1;
                                    j > p && (K = j / p, j = p), V > p && (Y = V / p, V = p);
                                    var Q = "groupAt" + this.groupLevel;
                                    y.smask && (Q += "_smask_" + this.smaskCounter++ % 2);
                                    var ee = this.cachedCanvases.getCanvas(Q, j, V, !0),
                                        J = ee.context;
                                    J.scale(1 / K, 1 / Y), J.translate(-q, -z), J.transform.apply(J, R), y.smask ? this.smaskStack.push({
                                        canvas: ee.canvas,
                                        context: J,
                                        offsetX: q,
                                        offsetY: z,
                                        scaleX: K,
                                        scaleY: Y,
                                        subtype: y.smask.subtype,
                                        backdrop: y.smask.backdrop,
                                        transferMap: y.smask.transferMap || null,
                                        startTransformInverse: null
                                    }) : (k.setTransform(1, 0, 0, 1, 0, 0), k.translate(q, z), k.scale(K, Y)), d(k, J), this.ctx = J, this.setGState([
                                        ["BM", "source-over"],
                                        ["ca", 1],
                                        ["CA", 1]
                                    ]), this.groupStack.push(k), this.groupLevel++, this.current.activeSMask = null
                                },
                                endGroup: function(y) {
                                    this.groupLevel--;
                                    var k = this.ctx;
                                    this.ctx = this.groupStack.pop(), this.ctx.imageSmoothingEnabled !== void 0 ? this.ctx.imageSmoothingEnabled = !1 : this.ctx.mozImageSmoothingEnabled = !1, y.smask ? this.tempSMask = this.smaskStack.pop() : this.ctx.drawImage(k.canvas, 0, 0), this.restore()
                                },
                                beginAnnotations: function() {
                                    this.save(), this.baseTransform && this.ctx.setTransform.apply(this.ctx, this.baseTransform)
                                },
                                endAnnotations: function() {
                                    this.restore()
                                },
                                beginAnnotation: function(y, k, R) {
                                    if (this.save(), g(this.ctx), this.current = new S, Array.isArray(y) && y.length === 4) {
                                        var D = y[2] - y[0],
                                            H = y[3] - y[1];
                                        this.ctx.rect(y[0], y[1], D, H), this.clip(), this.endPath()
                                    }
                                    this.transform.apply(this, k), this.transform.apply(this, R)
                                },
                                endAnnotation: function() {
                                    this.restore()
                                },
                                paintImageMaskXObject: function(y) {
                                    var k = this.ctx,
                                        R = y.width,
                                        D = y.height,
                                        H = this.current.fillColor,
                                        q = this.current.patternFill,
                                        z = this.processingType3;
                                    if (z && z.compiled === void 0 && (R <= u && D <= u ? z.compiled = m({
                                            data: y.data,
                                            width: R,
                                            height: D
                                        }) : z.compiled = null), z && z.compiled) {
                                        z.compiled(k);
                                        return
                                    }
                                    var j = this.cachedCanvases.getCanvas("maskCanvas", R, D),
                                        V = j.context;
                                    V.save(), f(V, y), V.globalCompositeOperation = "source-in", V.fillStyle = q ? H.getPattern(V, this) : H, V.fillRect(0, 0, R, D), V.restore(), this.paintInlineImageXObject(j.canvas)
                                },
                                paintImageMaskXObjectRepeat: function(y, k, R, D) {
                                    var H = y.width,
                                        q = y.height,
                                        z = this.current.fillColor,
                                        j = this.current.patternFill,
                                        V = this.cachedCanvases.getCanvas("maskCanvas", H, q),
                                        K = V.context;
                                    K.save(), f(K, y), K.globalCompositeOperation = "source-in", K.fillStyle = j ? z.getPattern(K, this) : z, K.fillRect(0, 0, H, q), K.restore();
                                    for (var Y = this.ctx, Q = 0, ee = D.length; Q < ee; Q += 2) Y.save(), Y.transform(k, 0, 0, R, D[Q], D[Q + 1]), Y.scale(1, -1), Y.drawImage(V.canvas, 0, 0, H, q, 0, -1, 1, 1), Y.restore()
                                },
                                paintImageMaskXObjectGroup: function(y) {
                                    for (var k = this.ctx, R = this.current.fillColor, D = this.current.patternFill, H = 0, q = y.length; H < q; H++) {
                                        var z = y[H],
                                            j = z.width,
                                            V = z.height,
                                            K = this.cachedCanvases.getCanvas("maskCanvas", j, V),
                                            Y = K.context;
                                        Y.save(), f(Y, z), Y.globalCompositeOperation = "source-in", Y.fillStyle = D ? R.getPattern(Y, this) : R, Y.fillRect(0, 0, j, V), Y.restore(), k.save(), k.transform.apply(k, z.transform), k.scale(1, -1), k.drawImage(K.canvas, 0, 0, j, V, 0, -1, 1, 1), k.restore()
                                    }
                                },
                                paintImageXObject: function(y) {
                                    const k = y.startsWith("g_") ? this.commonObjs.get(y) : this.objs.get(y);
                                    if (!k) {
                                        (0, s.warn)("Dependent image isn't ready yet");
                                        return
                                    }
                                    this.paintInlineImageXObject(k)
                                },
                                paintImageXObjectRepeat: function(y, k, R, D) {
                                    const H = y.startsWith("g_") ? this.commonObjs.get(y) : this.objs.get(y);
                                    if (!H) {
                                        (0, s.warn)("Dependent image isn't ready yet");
                                        return
                                    }
                                    for (var q = H.width, z = H.height, j = [], V = 0, K = D.length; V < K; V += 2) j.push({
                                        transform: [k, 0, 0, R, D[V], D[V + 1]],
                                        x: 0,
                                        y: 0,
                                        w: q,
                                        h: z
                                    });
                                    this.paintInlineImageXObjectGroup(H, j)
                                },
                                paintInlineImageXObject: function(y) {
                                    var k = y.width,
                                        R = y.height,
                                        D = this.ctx;
                                    this.save(), D.scale(1 / k, -1 / R);
                                    var H = D.mozCurrentTransformInverse,
                                        q = H[0],
                                        z = H[1],
                                        j = Math.max(Math.sqrt(q * q + z * z), 1),
                                        V = H[2],
                                        K = H[3],
                                        Y = Math.max(Math.sqrt(V * V + K * K), 1),
                                        Q, ee;
                                    if (typeof HTMLElement == "function" && y instanceof HTMLElement || !y.data) Q = y;
                                    else {
                                        ee = this.cachedCanvases.getCanvas("inlineImage", k, R);
                                        var J = ee.context;
                                        b(J, y), Q = ee.canvas
                                    }
                                    for (var ne = k, se = R, ie = "prescale1"; j > 2 && ne > 1 || Y > 2 && se > 1;) {
                                        var he = ne,
                                            fe = se;
                                        j > 2 && ne > 1 && (he = Math.ceil(ne / 2), j /= ne / he), Y > 2 && se > 1 && (fe = Math.ceil(se / 2), Y /= se / fe), ee = this.cachedCanvases.getCanvas(ie, he, fe), J = ee.context, J.clearRect(0, 0, he, fe), J.drawImage(Q, 0, 0, ne, se, 0, 0, he, fe), Q = ee.canvas, ne = he, se = fe, ie = ie === "prescale1" ? "prescale2" : "prescale1"
                                    }
                                    if (D.drawImage(Q, 0, 0, ne, se, 0, -R, k, R), this.imageLayer) {
                                        var le = this.getCanvasPosition(0, -R);
                                        this.imageLayer.appendImage({
                                            imgData: y,
                                            left: le[0],
                                            top: le[1],
                                            width: k / H[0],
                                            height: R / H[3]
                                        })
                                    }
                                    this.restore()
                                },
                                paintInlineImageXObjectGroup: function(y, k) {
                                    var R = this.ctx,
                                        D = y.width,
                                        H = y.height,
                                        q = this.cachedCanvases.getCanvas("inlineImage", D, H),
                                        z = q.context;
                                    b(z, y);
                                    for (var j = 0, V = k.length; j < V; j++) {
                                        var K = k[j];
                                        if (R.save(), R.transform.apply(R, K.transform), R.scale(1, -1), R.drawImage(q.canvas, K.x, K.y, K.w, K.h, 0, -1, 1, 1), this.imageLayer) {
                                            var Y = this.getCanvasPosition(K.x, K.y);
                                            this.imageLayer.appendImage({
                                                imgData: y,
                                                left: Y[0],
                                                top: Y[1],
                                                width: D,
                                                height: H
                                            })
                                        }
                                        R.restore()
                                    }
                                },
                                paintSolidColorImageMask: function() {
                                    this.ctx.fillRect(0, 0, 1, 1)
                                },
                                paintXObject: function() {
                                    (0, s.warn)("Unsupported 'paintXObject' command.")
                                },
                                markPoint: function(y) {},
                                markPointProps: function(y, k) {},
                                beginMarkedContent: function(y) {},
                                beginMarkedContentProps: function(y, k) {},
                                endMarkedContent: function() {},
                                beginCompat: function() {},
                                endCompat: function() {},
                                consumePath: function() {
                                    var y = this.ctx;
                                    this.pendingClip && (this.pendingClip === M ? y.clip("evenodd") : y.clip(), this.pendingClip = null), y.beginPath()
                                },
                                getSinglePixelWidth(A) {
                                    if (this._cachedGetSinglePixelWidth === null) {
                                        const y = this.ctx.mozCurrentTransformInverse;
                                        this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(y[0] * y[0] + y[1] * y[1], y[2] * y[2] + y[3] * y[3]))
                                    }
                                    return this._cachedGetSinglePixelWidth
                                },
                                getCanvasPosition: function(y, k) {
                                    var R = this.ctx.mozCurrentTransform;
                                    return [R[0] * y + R[2] * k + R[4], R[1] * y + R[3] * k + R[5]]
                                }
                            };
                            for (var _ in s.OPS) B.prototype[s.OPS[_]] = B.prototype[_];
                            return B
                        }();
                    r.CanvasGraphics = C
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.getShadingPatternFromIR = p, r.TilingPattern = void 0;
                    var s = n(2),
                        a = {};

                    function o(u, l) {
                        if (!l || typeof Path2D > "u") return;
                        const v = l[2] - l[0],
                            w = l[3] - l[1],
                            m = new Path2D;
                        m.rect(l[0], l[1], v, w), u.clip(m)
                    }
                    a.RadialAxial = {
                        fromIR: function(l) {
                            var v = l[1],
                                w = l[2],
                                m = l[3],
                                S = l[4],
                                C = l[5],
                                O = l[6],
                                x = l[7];
                            return {
                                type: "Pattern",
                                getPattern: function(B) {
                                    o(B, w);
                                    var b;
                                    v === "axial" ? b = B.createLinearGradient(S[0], S[1], C[0], C[1]) : v === "radial" && (b = B.createRadialGradient(S[0], S[1], O, C[0], C[1], x));
                                    for (var f = 0, d = m.length; f < d; ++f) {
                                        var g = m[f];
                                        b.addColorStop(g[0], g[1])
                                    }
                                    return b
                                }
                            }
                        }
                    };
                    var c = function() {
                        function l(m, S, C, O, x, I, B, b) {
                            var f = S.coords,
                                d = S.colors,
                                g = m.data,
                                E = m.width * 4,
                                T;
                            f[C + 1] > f[O + 1] && (T = C, C = O, O = T, T = I, I = B, B = T), f[O + 1] > f[x + 1] && (T = O, O = x, x = T, T = B, B = b, b = T), f[C + 1] > f[O + 1] && (T = C, C = O, O = T, T = I, I = B, B = T);
                            var N = (f[C] + S.offsetX) * S.scaleX,
                                P = (f[C + 1] + S.offsetY) * S.scaleY,
                                U = (f[O] + S.offsetX) * S.scaleX,
                                F = (f[O + 1] + S.offsetY) * S.scaleY,
                                L = (f[x] + S.offsetX) * S.scaleX,
                                G = (f[x + 1] + S.offsetY) * S.scaleY;
                            if (!(P >= G))
                                for (var M = d[I], _ = d[I + 1], A = d[I + 2], y = d[B], k = d[B + 1], R = d[B + 2], D = d[b], H = d[b + 1], q = d[b + 2], z = Math.round(P), j = Math.round(G), V, K, Y, Q, ee, J, ne, se, ie = z; ie <= j; ie++) {
                                    if (ie < F) {
                                        let oe;
                                        ie < P ? oe = 0 : P === F ? oe = 1 : oe = (P - ie) / (P - F), V = N - (N - U) * oe, K = M - (M - y) * oe, Y = _ - (_ - k) * oe, Q = A - (A - R) * oe
                                    } else {
                                        let oe;
                                        ie > G ? oe = 1 : F === G ? oe = 0 : oe = (F - ie) / (F - G), V = U - (U - L) * oe, K = y - (y - D) * oe, Y = k - (k - H) * oe, Q = R - (R - q) * oe
                                    }
                                    let de;
                                    ie < P ? de = 0 : ie > G ? de = 1 : de = (P - ie) / (P - G), ee = N - (N - L) * de, J = M - (M - D) * de, ne = _ - (_ - H) * de, se = A - (A - q) * de;
                                    for (var he = Math.round(Math.min(V, ee)), fe = Math.round(Math.max(V, ee)), le = E * ie + he * 4, pe = he; pe <= fe; pe++) de = (V - pe) / (V - ee), de < 0 ? de = 0 : de > 1 && (de = 1), g[le++] = K - (K - J) * de | 0, g[le++] = Y - (Y - ne) * de | 0, g[le++] = Q - (Q - se) * de | 0, g[le++] = 255
                                }
                        }

                        function v(m, S, C) {
                            var O = S.coords,
                                x = S.colors,
                                I, B;
                            switch (S.type) {
                                case "lattice":
                                    var b = S.verticesPerRow,
                                        f = Math.floor(O.length / b) - 1,
                                        d = b - 1;
                                    for (I = 0; I < f; I++)
                                        for (var g = I * b, E = 0; E < d; E++, g++) l(m, C, O[g], O[g + 1], O[g + b], x[g], x[g + 1], x[g + b]), l(m, C, O[g + b + 1], O[g + 1], O[g + b], x[g + b + 1], x[g + 1], x[g + b]);
                                    break;
                                case "triangles":
                                    for (I = 0, B = O.length; I < B; I += 3) l(m, C, O[I], O[I + 1], O[I + 2], x[I], x[I + 1], x[I + 2]);
                                    break;
                                default:
                                    throw new Error("illegal figure")
                            }
                        }

                        function w(m, S, C, O, x, I, B, b) {
                            var f = 1.1,
                                d = 3e3,
                                g = 2,
                                E = Math.floor(m[0]),
                                T = Math.floor(m[1]),
                                N = Math.ceil(m[2]) - E,
                                P = Math.ceil(m[3]) - T,
                                U = Math.min(Math.ceil(Math.abs(N * S[0] * f)), d),
                                F = Math.min(Math.ceil(Math.abs(P * S[1] * f)), d),
                                L = N / U,
                                G = P / F,
                                M = {
                                    coords: C,
                                    colors: O,
                                    offsetX: -E,
                                    offsetY: -T,
                                    scaleX: 1 / L,
                                    scaleY: 1 / G
                                },
                                _ = U + g * 2,
                                A = F + g * 2,
                                y, k, R, D;
                            if (b.isEnabled) y = b.drawFigures({
                                width: U,
                                height: F,
                                backgroundColor: I,
                                figures: x,
                                context: M
                            }), k = B.getCanvas("mesh", _, A, !1), k.context.drawImage(y, g, g), y = k.canvas;
                            else {
                                k = B.getCanvas("mesh", _, A, !1);
                                var H = k.context,
                                    q = H.createImageData(U, F);
                                if (I) {
                                    var z = q.data;
                                    for (R = 0, D = z.length; R < D; R += 4) z[R] = I[0], z[R + 1] = I[1], z[R + 2] = I[2], z[R + 3] = 255
                                }
                                for (R = 0; R < x.length; R++) v(q, x[R], M);
                                H.putImageData(q, g, g), y = k.canvas
                            }
                            return {
                                canvas: y,
                                offsetX: E - g * L,
                                offsetY: T - g * G,
                                scaleX: L,
                                scaleY: G
                            }
                        }
                        return w
                    }();
                    a.Mesh = {
                        fromIR: function(l) {
                            var v = l[2],
                                w = l[3],
                                m = l[4],
                                S = l[5],
                                C = l[6],
                                O = l[7],
                                x = l[8];
                            return {
                                type: "Pattern",
                                getPattern: function(B, b, f) {
                                    o(B, O);
                                    var d;
                                    if (f) d = s.Util.singularValueDecompose2dScale(B.mozCurrentTransform);
                                    else if (d = s.Util.singularValueDecompose2dScale(b.baseTransform), C) {
                                        var g = s.Util.singularValueDecompose2dScale(C);
                                        d = [d[0] * g[0], d[1] * g[1]]
                                    }
                                    var E = c(S, d, v, w, m, f ? null : x, b.cachedCanvases, b.webGLContext);
                                    return f || (B.setTransform.apply(B, b.baseTransform), C && B.transform.apply(B, C)), B.translate(E.offsetX, E.offsetY), B.scale(E.scaleX, E.scaleY), B.createPattern(E.canvas, "no-repeat")
                                }
                            }
                        }
                    }, a.Dummy = {
                        fromIR: function() {
                            return {
                                type: "Pattern",
                                getPattern: function() {
                                    return "hotpink"
                                }
                            }
                        }
                    };

                    function p(u) {
                        var l = a[u[0]];
                        if (!l) throw new Error(`Unknown IR type: ${u[0]}`);
                        return l.fromIR(u)
                    }
                    var h = function() {
                        var l = {
                                COLORED: 1,
                                UNCOLORED: 2
                            },
                            v = 3e3;

                        function w(m, S, C, O, x) {
                            this.operatorList = m[2], this.matrix = m[3] || [1, 0, 0, 1, 0, 0], this.bbox = m[4], this.xstep = m[5], this.ystep = m[6], this.paintType = m[7], this.tilingType = m[8], this.color = S, this.canvasGraphicsFactory = O, this.baseTransform = x, this.type = "Pattern", this.ctx = C
                        }
                        return w.prototype = {
                            createPatternCanvas: function(S) {
                                var C = this.operatorList,
                                    O = this.bbox,
                                    x = this.xstep,
                                    I = this.ystep,
                                    B = this.paintType,
                                    b = this.tilingType,
                                    f = this.color,
                                    d = this.canvasGraphicsFactory;
                                (0, s.info)("TilingType: " + b);
                                var g = O[0],
                                    E = O[1],
                                    T = O[2],
                                    N = O[3],
                                    P = s.Util.singularValueDecompose2dScale(this.matrix),
                                    U = s.Util.singularValueDecompose2dScale(this.baseTransform),
                                    F = [P[0] * U[0], P[1] * U[1]],
                                    L = this.getSizeAndScale(x, this.ctx.canvas.width, F[0]),
                                    G = this.getSizeAndScale(I, this.ctx.canvas.height, F[1]),
                                    M = S.cachedCanvases.getCanvas("pattern", L.size, G.size, !0),
                                    _ = M.context,
                                    A = d.createCanvasGraphics(_);
                                return A.groupLevel = S.groupLevel, this.setFillAndStrokeStyleToContext(A, B, f), A.transform(L.scale, 0, 0, G.scale, 0, 0), A.transform(1, 0, 0, 1, -g, -E), this.clipBbox(A, O, g, E, T, N), A.executeOperatorList(C), this.ctx.transform(1, 0, 0, 1, g, E), this.ctx.scale(1 / L.scale, 1 / G.scale), M.canvas
                            },
                            getSizeAndScale: function(S, C, O) {
                                S = Math.abs(S);
                                var x = Math.max(v, C),
                                    I = Math.ceil(S * O);
                                return I >= x ? I = x : O = I / S, {
                                    scale: O,
                                    size: I
                                }
                            },
                            clipBbox: function(S, C, O, x, I, B) {
                                if (Array.isArray(C) && C.length === 4) {
                                    var b = I - O,
                                        f = B - x;
                                    S.ctx.rect(O, x, b, f), S.clip(), S.endPath()
                                }
                            },
                            setFillAndStrokeStyleToContext: function(S, C, O) {
                                const x = S.ctx,
                                    I = S.current;
                                switch (C) {
                                    case l.COLORED:
                                        var B = this.ctx;
                                        x.fillStyle = B.fillStyle, x.strokeStyle = B.strokeStyle, I.fillColor = B.fillStyle, I.strokeColor = B.strokeStyle;
                                        break;
                                    case l.UNCOLORED:
                                        var b = s.Util.makeCssRgb(O[0], O[1], O[2]);
                                        x.fillStyle = b, x.strokeStyle = b, I.fillColor = b, I.strokeColor = b;
                                        break;
                                    default:
                                        throw new s.FormatError(`Unsupported paint type: ${C}`)
                                }
                            },
                            getPattern: function(S, C) {
                                S = this.ctx, S.setTransform.apply(S, this.baseTransform), S.transform.apply(S, this.matrix);
                                var O = this.createPatternCanvas(C);
                                return S.createPattern(O, "repeat")
                            }
                        }, w
                    }();
                    r.TilingPattern = h
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.GlobalWorkerOptions = void 0;
                    const s = Object.create(null);
                    r.GlobalWorkerOptions = s, s.workerPort = s.workerPort === void 0 ? null : s.workerPort, s.workerSrc = s.workerSrc === void 0 ? "" : s.workerSrc
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.MessageHandler = void 0;
                    var s = n(2);
                    const a = {
                            UNKNOWN: 0,
                            DATA: 1,
                            ERROR: 2
                        },
                        o = {
                            UNKNOWN: 0,
                            CANCEL: 1,
                            CANCEL_COMPLETE: 2,
                            CLOSE: 3,
                            ENQUEUE: 4,
                            ERROR: 5,
                            PULL: 6,
                            PULL_COMPLETE: 7,
                            START_COMPLETE: 8
                        };

                    function c(h) {
                        if (typeof h != "object" || h === null) return h;
                        switch (h.name) {
                            case "AbortException":
                                return new s.AbortException(h.message);
                            case "MissingPDFException":
                                return new s.MissingPDFException(h.message);
                            case "UnexpectedResponseException":
                                return new s.UnexpectedResponseException(h.message, h.status);
                            case "UnknownErrorException":
                                return new s.UnknownErrorException(h.message, h.details);
                            default:
                                return new s.UnknownErrorException(h.message, h.toString())
                        }
                    }
                    class p {
                        constructor(u, l, v) {
                            this.sourceName = u, this.targetName = l, this.comObj = v, this.callbackId = 1, this.streamId = 1, this.postMessageTransfers = !0, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), this._onComObjOnMessage = w => {
                                const m = w.data;
                                if (m.targetName !== this.sourceName) return;
                                if (m.stream) {
                                    this._processStreamMessage(m);
                                    return
                                }
                                if (m.callback) {
                                    const C = m.callbackId,
                                        O = this.callbackCapabilities[C];
                                    if (!O) throw new Error(`Cannot resolve callback ${C}`);
                                    if (delete this.callbackCapabilities[C], m.callback === a.DATA) O.resolve(m.data);
                                    else if (m.callback === a.ERROR) O.reject(c(m.reason));
                                    else throw new Error("Unexpected callback case");
                                    return
                                }
                                const S = this.actionHandler[m.action];
                                if (!S) throw new Error(`Unknown action from worker: ${m.action}`);
                                if (m.callbackId) {
                                    const C = this.sourceName,
                                        O = m.sourceName;
                                    new Promise(function(x) {
                                        x(S(m.data))
                                    }).then(function(x) {
                                        v.postMessage({
                                            sourceName: C,
                                            targetName: O,
                                            callback: a.DATA,
                                            callbackId: m.callbackId,
                                            data: x
                                        })
                                    }, function(x) {
                                        v.postMessage({
                                            sourceName: C,
                                            targetName: O,
                                            callback: a.ERROR,
                                            callbackId: m.callbackId,
                                            reason: c(x)
                                        })
                                    });
                                    return
                                }
                                if (m.streamId) {
                                    this._createStreamSink(m);
                                    return
                                }
                                S(m.data)
                            }, v.addEventListener("message", this._onComObjOnMessage)
                        }
                        on(u, l) {
                            const v = this.actionHandler;
                            if (v[u]) throw new Error(`There is already an actionName called "${u}"`);
                            v[u] = l
                        }
                        send(u, l, v) {
                            this._postMessage({
                                sourceName: this.sourceName,
                                targetName: this.targetName,
                                action: u,
                                data: l
                            }, v)
                        }
                        sendWithPromise(u, l, v) {
                            const w = this.callbackId++,
                                m = (0, s.createPromiseCapability)();
                            this.callbackCapabilities[w] = m;
                            try {
                                this._postMessage({
                                    sourceName: this.sourceName,
                                    targetName: this.targetName,
                                    action: u,
                                    callbackId: w,
                                    data: l
                                }, v)
                            } catch (S) {
                                m.reject(S)
                            }
                            return m.promise
                        }
                        sendWithStream(u, l, v, w) {
                            const m = this.streamId++,
                                S = this.sourceName,
                                C = this.targetName,
                                O = this.comObj;
                            return new ReadableStream({
                                start: x => {
                                    const I = (0, s.createPromiseCapability)();
                                    return this.streamControllers[m] = {
                                        controller: x,
                                        startCall: I,
                                        pullCall: null,
                                        cancelCall: null,
                                        isClosed: !1
                                    }, this._postMessage({
                                        sourceName: S,
                                        targetName: C,
                                        action: u,
                                        streamId: m,
                                        data: l,
                                        desiredSize: x.desiredSize
                                    }, w), I.promise
                                },
                                pull: x => {
                                    const I = (0, s.createPromiseCapability)();
                                    return this.streamControllers[m].pullCall = I, O.postMessage({
                                        sourceName: S,
                                        targetName: C,
                                        stream: o.PULL,
                                        streamId: m,
                                        desiredSize: x.desiredSize
                                    }), I.promise
                                },
                                cancel: x => {
                                    (0, s.assert)(x instanceof Error, "cancel must have a valid reason");
                                    const I = (0, s.createPromiseCapability)();
                                    return this.streamControllers[m].cancelCall = I, this.streamControllers[m].isClosed = !0, O.postMessage({
                                        sourceName: S,
                                        targetName: C,
                                        stream: o.CANCEL,
                                        streamId: m,
                                        reason: c(x)
                                    }), I.promise
                                }
                            }, v)
                        }
                        _createStreamSink(u) {
                            const l = this,
                                v = this.actionHandler[u.action],
                                w = u.streamId,
                                m = this.sourceName,
                                S = u.sourceName,
                                C = this.comObj,
                                O = {
                                    enqueue(x, I = 1, B) {
                                        if (this.isCancelled) return;
                                        const b = this.desiredSize;
                                        this.desiredSize -= I, b > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, s.createPromiseCapability)(), this.ready = this.sinkCapability.promise), l._postMessage({
                                            sourceName: m,
                                            targetName: S,
                                            stream: o.ENQUEUE,
                                            streamId: w,
                                            chunk: x
                                        }, B)
                                    },
                                    close() {
                                        this.isCancelled || (this.isCancelled = !0, C.postMessage({
                                            sourceName: m,
                                            targetName: S,
                                            stream: o.CLOSE,
                                            streamId: w
                                        }), delete l.streamSinks[w])
                                    },
                                    error(x) {
                                        (0, s.assert)(x instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, C.postMessage({
                                            sourceName: m,
                                            targetName: S,
                                            stream: o.ERROR,
                                            streamId: w,
                                            reason: c(x)
                                        }))
                                    },
                                    sinkCapability: (0, s.createPromiseCapability)(),
                                    onPull: null,
                                    onCancel: null,
                                    isCancelled: !1,
                                    desiredSize: u.desiredSize,
                                    ready: null
                                };
                            O.sinkCapability.resolve(), O.ready = O.sinkCapability.promise, this.streamSinks[w] = O, new Promise(function(x) {
                                x(v(u.data, O))
                            }).then(function() {
                                C.postMessage({
                                    sourceName: m,
                                    targetName: S,
                                    stream: o.START_COMPLETE,
                                    streamId: w,
                                    success: !0
                                })
                            }, function(x) {
                                C.postMessage({
                                    sourceName: m,
                                    targetName: S,
                                    stream: o.START_COMPLETE,
                                    streamId: w,
                                    reason: c(x)
                                })
                            })
                        }
                        _processStreamMessage(u) {
                            const l = u.streamId,
                                v = this.sourceName,
                                w = u.sourceName,
                                m = this.comObj;
                            switch (u.stream) {
                                case o.START_COMPLETE:
                                    u.success ? this.streamControllers[l].startCall.resolve() : this.streamControllers[l].startCall.reject(c(u.reason));
                                    break;
                                case o.PULL_COMPLETE:
                                    u.success ? this.streamControllers[l].pullCall.resolve() : this.streamControllers[l].pullCall.reject(c(u.reason));
                                    break;
                                case o.PULL:
                                    if (!this.streamSinks[l]) {
                                        m.postMessage({
                                            sourceName: v,
                                            targetName: w,
                                            stream: o.PULL_COMPLETE,
                                            streamId: l,
                                            success: !0
                                        });
                                        break
                                    }
                                    this.streamSinks[l].desiredSize <= 0 && u.desiredSize > 0 && this.streamSinks[l].sinkCapability.resolve(), this.streamSinks[l].desiredSize = u.desiredSize;
                                    const {
                                        onPull: S
                                    } = this.streamSinks[u.streamId];
                                    new Promise(function(O) {
                                        O(S && S())
                                    }).then(function() {
                                        m.postMessage({
                                            sourceName: v,
                                            targetName: w,
                                            stream: o.PULL_COMPLETE,
                                            streamId: l,
                                            success: !0
                                        })
                                    }, function(O) {
                                        m.postMessage({
                                            sourceName: v,
                                            targetName: w,
                                            stream: o.PULL_COMPLETE,
                                            streamId: l,
                                            reason: c(O)
                                        })
                                    });
                                    break;
                                case o.ENQUEUE:
                                    if ((0, s.assert)(this.streamControllers[l], "enqueue should have stream controller"), this.streamControllers[l].isClosed) break;
                                    this.streamControllers[l].controller.enqueue(u.chunk);
                                    break;
                                case o.CLOSE:
                                    if ((0, s.assert)(this.streamControllers[l], "close should have stream controller"), this.streamControllers[l].isClosed) break;
                                    this.streamControllers[l].isClosed = !0, this.streamControllers[l].controller.close(), this._deleteStreamController(l);
                                    break;
                                case o.ERROR:
                                    (0, s.assert)(this.streamControllers[l], "error should have stream controller"), this.streamControllers[l].controller.error(c(u.reason)), this._deleteStreamController(l);
                                    break;
                                case o.CANCEL_COMPLETE:
                                    u.success ? this.streamControllers[l].cancelCall.resolve() : this.streamControllers[l].cancelCall.reject(c(u.reason)), this._deleteStreamController(l);
                                    break;
                                case o.CANCEL:
                                    if (!this.streamSinks[l]) break;
                                    const {
                                        onCancel: C
                                    } = this.streamSinks[u.streamId];
                                    new Promise(function(O) {
                                        O(C && C(c(u.reason)))
                                    }).then(function() {
                                        m.postMessage({
                                            sourceName: v,
                                            targetName: w,
                                            stream: o.CANCEL_COMPLETE,
                                            streamId: l,
                                            success: !0
                                        })
                                    }, function(O) {
                                        m.postMessage({
                                            sourceName: v,
                                            targetName: w,
                                            stream: o.CANCEL_COMPLETE,
                                            streamId: l,
                                            reason: c(O)
                                        })
                                    }), this.streamSinks[l].sinkCapability.reject(c(u.reason)), this.streamSinks[l].isCancelled = !0, delete this.streamSinks[l];
                                    break;
                                default:
                                    throw new Error("Unexpected stream case")
                            }
                        }
                        async _deleteStreamController(u) {
                            await Promise.allSettled([this.streamControllers[u].startCall, this.streamControllers[u].pullCall, this.streamControllers[u].cancelCall].map(function(l) {
                                return l && l.promise
                            })), delete this.streamControllers[u]
                        }
                        _postMessage(u, l) {
                            l && this.postMessageTransfers ? this.comObj.postMessage(u, l) : this.comObj.postMessage(u)
                        }
                        destroy() {
                            this.comObj.removeEventListener("message", this._onComObjOnMessage)
                        }
                    }
                    r.MessageHandler = p
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.Metadata = void 0;
                    var s = n(2),
                        a = n(13);
                    class o {
                        constructor(p) {
                            (0, s.assert)(typeof p == "string", "Metadata: input is not a string"), p = this._repair(p);
                            const u = new a.SimpleXMLParser().parseFromString(p);
                            this._metadataMap = new Map, u && this._parse(u)
                        }
                        _repair(p) {
                            return p.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(h, u) {
                                const l = u.replace(/\\([0-3])([0-7])([0-7])/g, function(w, m, S, C) {
                                    return String.fromCharCode(m * 64 + S * 8 + C * 1)
                                }).replace(/&(amp|apos|gt|lt|quot);/g, function(w, m) {
                                    switch (m) {
                                        case "amp":
                                            return "&";
                                        case "apos":
                                            return "'";
                                        case "gt":
                                            return ">";
                                        case "lt":
                                            return "<";
                                        case "quot":
                                            return '"'
                                    }
                                    throw new Error(`_repair: ${m} isn't defined.`)
                                });
                                let v = "";
                                for (let w = 0, m = l.length; w < m; w += 2) {
                                    const S = l.charCodeAt(w) * 256 + l.charCodeAt(w + 1);
                                    S >= 32 && S < 127 && S !== 60 && S !== 62 && S !== 38 ? v += String.fromCharCode(S) : v += "&#x" + (65536 + S).toString(16).substring(1) + ";"
                                }
                                return ">" + v
                            })
                        }
                        _parse(p) {
                            let h = p.documentElement;
                            if (h.nodeName.toLowerCase() !== "rdf:rdf")
                                for (h = h.firstChild; h && h.nodeName.toLowerCase() !== "rdf:rdf";) h = h.nextSibling;
                            const u = h ? h.nodeName.toLowerCase() : null;
                            if (!h || u !== "rdf:rdf" || !h.hasChildNodes()) return;
                            const l = h.childNodes;
                            for (let v = 0, w = l.length; v < w; v++) {
                                const m = l[v];
                                if (m.nodeName.toLowerCase() === "rdf:description") {
                                    for (let S = 0, C = m.childNodes.length; S < C; S++)
                                        if (m.childNodes[S].nodeName.toLowerCase() !== "#text") {
                                            const O = m.childNodes[S],
                                                x = O.nodeName.toLowerCase();
                                            this._metadataMap.set(x, O.textContent.trim())
                                        }
                                }
                            }
                        }
                        get(p) {
                            return this._metadataMap.has(p) ? this._metadataMap.get(p) : null
                        }
                        getAll() {
                            const p = Object.create(null);
                            for (const [h, u] of this._metadataMap) p[h] = u;
                            return p
                        }
                        has(p) {
                            return this._metadataMap.has(p)
                        }
                    }
                    r.Metadata = o
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.SimpleXMLParser = void 0;
                    const s = {
                        NoError: 0,
                        EndOfDocument: -1,
                        UnterminatedCdat: -2,
                        UnterminatedXmlDeclaration: -3,
                        UnterminatedDoctypeDeclaration: -4,
                        UnterminatedComment: -5,
                        MalformedElement: -6,
                        OutOfMemory: -7,
                        UnterminatedAttributeValue: -8,
                        UnterminatedElement: -9,
                        ElementNeverBegun: -10
                    };

                    function a(u, l) {
                        const v = u[l];
                        return v === " " || v === `
` || v === "\r" || v === "	"
                    }

                    function o(u) {
                        for (let l = 0, v = u.length; l < v; l++)
                            if (!a(u, l)) return !1;
                        return !0
                    }
                    class c {
                        _resolveEntities(l) {
                            return l.replace(/&([^;]+);/g, (v, w) => {
                                if (w.substring(0, 2) === "#x") return String.fromCharCode(parseInt(w.substring(2), 16));
                                if (w.substring(0, 1) === "#") return String.fromCharCode(parseInt(w.substring(1), 10));
                                switch (w) {
                                    case "lt":
                                        return "<";
                                    case "gt":
                                        return ">";
                                    case "amp":
                                        return "&";
                                    case "quot":
                                        return '"'
                                }
                                return this.onResolveEntity(w)
                            })
                        }
                        _parseContent(l, v) {
                            const w = [];
                            let m = v;

                            function S() {
                                for (; m < l.length && a(l, m);) ++m
                            }
                            for (; m < l.length && !a(l, m) && l[m] !== ">" && l[m] !== "/";) ++m;
                            const C = l.substring(v, m);
                            for (S(); m < l.length && l[m] !== ">" && l[m] !== "/" && l[m] !== "?";) {
                                S();
                                let O = "",
                                    x = "";
                                for (; m < l.length && !a(l, m) && l[m] !== "=";) O += l[m], ++m;
                                if (S(), l[m] !== "=") return null;
                                ++m, S();
                                const I = l[m];
                                if (I !== '"' && I !== "'") return null;
                                const B = l.indexOf(I, ++m);
                                if (B < 0) return null;
                                x = l.substring(m, B), w.push({
                                    name: O,
                                    value: this._resolveEntities(x)
                                }), m = B + 1, S()
                            }
                            return {
                                name: C,
                                attributes: w,
                                parsed: m - v
                            }
                        }
                        _parseProcessingInstruction(l, v) {
                            let w = v;

                            function m() {
                                for (; w < l.length && a(l, w);) ++w
                            }
                            for (; w < l.length && !a(l, w) && l[w] !== ">" && l[w] !== "/";) ++w;
                            const S = l.substring(v, w);
                            m();
                            const C = w;
                            for (; w < l.length && (l[w] !== "?" || l[w + 1] !== ">");) ++w;
                            const O = l.substring(C, w);
                            return {
                                name: S,
                                value: O,
                                parsed: w - v
                            }
                        }
                        parseXml(l) {
                            let v = 0;
                            for (; v < l.length;) {
                                const w = l[v];
                                let m = v;
                                if (w === "<") {
                                    ++m;
                                    const S = l[m];
                                    let C;
                                    switch (S) {
                                        case "/":
                                            if (++m, C = l.indexOf(">", m), C < 0) {
                                                this.onError(s.UnterminatedElement);
                                                return
                                            }
                                            this.onEndElement(l.substring(m, C)), m = C + 1;
                                            break;
                                        case "?":
                                            ++m;
                                            const O = this._parseProcessingInstruction(l, m);
                                            if (l.substring(m + O.parsed, m + O.parsed + 2) !== "?>") {
                                                this.onError(s.UnterminatedXmlDeclaration);
                                                return
                                            }
                                            this.onPi(O.name, O.value), m += O.parsed + 2;
                                            break;
                                        case "!":
                                            if (l.substring(m + 1, m + 3) === "--") {
                                                if (C = l.indexOf("-->", m + 3), C < 0) {
                                                    this.onError(s.UnterminatedComment);
                                                    return
                                                }
                                                this.onComment(l.substring(m + 3, C)), m = C + 3
                                            } else if (l.substring(m + 1, m + 8) === "[CDATA[") {
                                                if (C = l.indexOf("]]>", m + 8), C < 0) {
                                                    this.onError(s.UnterminatedCdat);
                                                    return
                                                }
                                                this.onCdata(l.substring(m + 8, C)), m = C + 3
                                            } else if (l.substring(m + 1, m + 8) === "DOCTYPE") {
                                                const B = l.indexOf("[", m + 8);
                                                let b = !1;
                                                if (C = l.indexOf(">", m + 8), C < 0) {
                                                    this.onError(s.UnterminatedDoctypeDeclaration);
                                                    return
                                                }
                                                if (B > 0 && C > B) {
                                                    if (C = l.indexOf("]>", m + 8), C < 0) {
                                                        this.onError(s.UnterminatedDoctypeDeclaration);
                                                        return
                                                    }
                                                    b = !0
                                                }
                                                const f = l.substring(m + 8, C + (b ? 1 : 0));
                                                this.onDoctype(f), m = C + (b ? 2 : 1)
                                            } else {
                                                this.onError(s.MalformedElement);
                                                return
                                            }
                                            break;
                                        default:
                                            const x = this._parseContent(l, m);
                                            if (x === null) {
                                                this.onError(s.MalformedElement);
                                                return
                                            }
                                            let I = !1;
                                            if (l.substring(m + x.parsed, m + x.parsed + 2) === "/>") I = !0;
                                            else if (l.substring(m + x.parsed, m + x.parsed + 1) !== ">") {
                                                this.onError(s.UnterminatedElement);
                                                return
                                            }
                                            this.onBeginElement(x.name, x.attributes, I), m += x.parsed + (I ? 2 : 1);
                                            break
                                    }
                                } else {
                                    for (; m < l.length && l[m] !== "<";) m++;
                                    const S = l.substring(v, m);
                                    this.onText(this._resolveEntities(S))
                                }
                                v = m
                            }
                        }
                        onResolveEntity(l) {
                            return `&${l};`
                        }
                        onPi(l, v) {}
                        onComment(l) {}
                        onCdata(l) {}
                        onDoctype(l) {}
                        onText(l) {}
                        onBeginElement(l, v, w) {}
                        onEndElement(l) {}
                        onError(l) {}
                    }
                    class p {
                        constructor(l, v) {
                            this.nodeName = l, this.nodeValue = v, Object.defineProperty(this, "parentNode", {
                                value: null,
                                writable: !0
                            })
                        }
                        get firstChild() {
                            return this.childNodes && this.childNodes[0]
                        }
                        get nextSibling() {
                            const l = this.parentNode.childNodes;
                            if (!l) return;
                            const v = l.indexOf(this);
                            if (v !== -1) return l[v + 1]
                        }
                        get textContent() {
                            return this.childNodes ? this.childNodes.map(function(l) {
                                return l.textContent
                            }).join("") : this.nodeValue || ""
                        }
                        hasChildNodes() {
                            return this.childNodes && this.childNodes.length > 0
                        }
                    }
                    class h extends c {
                        constructor() {
                            super(), this._currentFragment = null, this._stack = null, this._errorCode = s.NoError
                        }
                        parseFromString(l) {
                            if (this._currentFragment = [], this._stack = [], this._errorCode = s.NoError, this.parseXml(l), this._errorCode !== s.NoError) return;
                            const [v] = this._currentFragment;
                            if (!!v) return {
                                documentElement: v
                            }
                        }
                        onResolveEntity(l) {
                            switch (l) {
                                case "apos":
                                    return "'"
                            }
                            return super.onResolveEntity(l)
                        }
                        onText(l) {
                            if (o(l)) return;
                            const v = new p("#text", l);
                            this._currentFragment.push(v)
                        }
                        onCdata(l) {
                            const v = new p("#text", l);
                            this._currentFragment.push(v)
                        }
                        onBeginElement(l, v, w) {
                            const m = new p(l);
                            m.childNodes = [], this._currentFragment.push(m), !w && (this._stack.push(this._currentFragment), this._currentFragment = m.childNodes)
                        }
                        onEndElement(l) {
                            this._currentFragment = this._stack.pop() || [];
                            const v = this._currentFragment[this._currentFragment.length - 1];
                            if (!!v)
                                for (let w = 0, m = v.childNodes.length; w < m; w++) v.childNodes[w].parentNode = v
                        }
                        onError(l) {
                            this._errorCode = l
                        }
                    }
                    r.SimpleXMLParser = h
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.PDFDataTransportStream = void 0;
                    var s = n(2);
                    class a {
                        constructor(h, u) {
                            (0, s.assert)(u, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = h.progressiveDone || !1;
                            const l = h.initialData;
                            if (l && l.length > 0) {
                                const v = new Uint8Array(l).buffer;
                                this._queuedChunks.push(v)
                            }
                            this._pdfDataRangeTransport = u, this._isStreamingSupported = !h.disableStream, this._isRangeSupported = !h.disableRange, this._contentLength = h.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((v, w) => {
                                this._onReceiveData({
                                    begin: v,
                                    chunk: w
                                })
                            }), this._pdfDataRangeTransport.addProgressListener((v, w) => {
                                this._onProgress({
                                    loaded: v,
                                    total: w
                                })
                            }), this._pdfDataRangeTransport.addProgressiveReadListener(v => {
                                this._onReceiveData({
                                    chunk: v
                                })
                            }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                                this._onProgressiveDone()
                            }), this._pdfDataRangeTransport.transportReady()
                        }
                        _onReceiveData(h) {
                            const u = new Uint8Array(h.chunk).buffer;
                            if (h.begin === void 0) this._fullRequestReader ? this._fullRequestReader._enqueue(u) : this._queuedChunks.push(u);
                            else {
                                const l = this._rangeReaders.some(function(v) {
                                    return v._begin !== h.begin ? !1 : (v._enqueue(u), !0)
                                });
                                (0, s.assert)(l, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.")
                            }
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        _onProgress(h) {
                            if (h.total === void 0) {
                                const u = this._rangeReaders[0];
                                u && u.onProgress && u.onProgress({
                                    loaded: h.loaded
                                })
                            } else {
                                const u = this._fullRequestReader;
                                u && u.onProgress && u.onProgress({
                                    loaded: h.loaded,
                                    total: h.total
                                })
                            }
                        }
                        _onProgressiveDone() {
                            this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0
                        }
                        _removeRangeReader(h) {
                            const u = this._rangeReaders.indexOf(h);
                            u >= 0 && this._rangeReaders.splice(u, 1)
                        }
                        getFullReader() {
                            (0, s.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                            const h = this._queuedChunks;
                            return this._queuedChunks = null, new o(this, h, this._progressiveDone)
                        }
                        getRangeReader(h, u) {
                            if (u <= this._progressiveDataLength) return null;
                            const l = new c(this, h, u);
                            return this._pdfDataRangeTransport.requestDataRange(h, u), this._rangeReaders.push(l), l
                        }
                        cancelAllRequests(h) {
                            this._fullRequestReader && this._fullRequestReader.cancel(h), this._rangeReaders.slice(0).forEach(function(l) {
                                l.cancel(h)
                            }), this._pdfDataRangeTransport.abort()
                        }
                    }
                    r.PDFDataTransportStream = a;
                    class o {
                        constructor(h, u, l = !1) {
                            this._stream = h, this._done = l || !1, this._filename = null, this._queuedChunks = u || [], this._loaded = 0;
                            for (const v of this._queuedChunks) this._loaded += v.byteLength;
                            this._requests = [], this._headersReady = Promise.resolve(), h._fullRequestReader = this, this.onProgress = null
                        }
                        _enqueue(h) {
                            this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                                value: h,
                                done: !1
                            }) : this._queuedChunks.push(h), this._loaded += h.byteLength)
                        }
                        get headersReady() {
                            return this._headersReady
                        }
                        get filename() {
                            return this._filename
                        }
                        get isRangeSupported() {
                            return this._stream._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._stream._isStreamingSupported
                        }
                        get contentLength() {
                            return this._stream._contentLength
                        }
                        async read() {
                            if (this._queuedChunks.length > 0) return {
                                value: this._queuedChunks.shift(),
                                done: !1
                            };
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const h = (0, s.createPromiseCapability)();
                            return this._requests.push(h), h.promise
                        }
                        cancel(h) {
                            this._done = !0, this._requests.forEach(function(u) {
                                u.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = []
                        }
                        progressiveDone() {
                            this._done || (this._done = !0)
                        }
                    }
                    class c {
                        constructor(h, u, l) {
                            this._stream = h, this._begin = u, this._end = l, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null
                        }
                        _enqueue(h) {
                            this._done || (this._requests.length === 0 ? this._queuedChunk = h : (this._requests.shift().resolve({
                                value: h,
                                done: !1
                            }), this._requests.forEach(function(l) {
                                l.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = []), this._done = !0, this._stream._removeRangeReader(this))
                        }
                        get isStreamingSupported() {
                            return !1
                        }
                        async read() {
                            if (this._queuedChunk) {
                                const u = this._queuedChunk;
                                return this._queuedChunk = null, {
                                    value: u,
                                    done: !1
                                }
                            }
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const h = (0, s.createPromiseCapability)();
                            return this._requests.push(h), h.promise
                        }
                        cancel(h) {
                            this._done = !0, this._requests.forEach(function(u) {
                                u.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = [], this._stream._removeRangeReader(this)
                        }
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.WebGLContext = void 0;
                    var s = n(2);
                    class a {
                        constructor({
                            enable: p = !1
                        }) {
                            this._enabled = p === !0
                        }
                        get isEnabled() {
                            let p = this._enabled;
                            return p && (p = o.tryInitGL()), (0, s.shadow)(this, "isEnabled", p)
                        }
                        composeSMask({
                            layer: p,
                            mask: h,
                            properties: u
                        }) {
                            return o.composeSMask(p, h, u)
                        }
                        drawFigures({
                            width: p,
                            height: h,
                            backgroundColor: u,
                            figures: l,
                            context: v
                        }) {
                            return o.drawFigures(p, h, u, l, v)
                        }
                        clear() {
                            o.cleanup()
                        }
                    }
                    r.WebGLContext = a;
                    var o = function() {
                        function p(T, N, P) {
                            var U = T.createShader(P);
                            T.shaderSource(U, N), T.compileShader(U);
                            var F = T.getShaderParameter(U, T.COMPILE_STATUS);
                            if (!F) {
                                var L = T.getShaderInfoLog(U);
                                throw new Error("Error during shader compilation: " + L)
                            }
                            return U
                        }

                        function h(T, N) {
                            return p(T, N, T.VERTEX_SHADER)
                        }

                        function u(T, N) {
                            return p(T, N, T.FRAGMENT_SHADER)
                        }

                        function l(T, N) {
                            for (var P = T.createProgram(), U = 0, F = N.length; U < F; ++U) T.attachShader(P, N[U]);
                            T.linkProgram(P);
                            var L = T.getProgramParameter(P, T.LINK_STATUS);
                            if (!L) {
                                var G = T.getProgramInfoLog(P);
                                throw new Error("Error during program linking: " + G)
                            }
                            return P
                        }

                        function v(T, N, P) {
                            T.activeTexture(P);
                            var U = T.createTexture();
                            return T.bindTexture(T.TEXTURE_2D, U), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_WRAP_S, T.CLAMP_TO_EDGE), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_WRAP_T, T.CLAMP_TO_EDGE), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MIN_FILTER, T.NEAREST), T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MAG_FILTER, T.NEAREST), T.texImage2D(T.TEXTURE_2D, 0, T.RGBA, T.RGBA, T.UNSIGNED_BYTE, N), U
                        }
                        var w, m;

                        function S() {
                            w || (m = document.createElement("canvas"), w = m.getContext("webgl", {
                                premultipliedalpha: !1
                            }))
                        }
                        var C = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ",
                            O = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ",
                            x = null;

                        function I() {
                            var T, N;
                            S(), T = m, m = null, N = w, w = null;
                            var P = h(N, C),
                                U = u(N, O),
                                F = l(N, [P, U]);
                            N.useProgram(F);
                            var L = {};
                            L.gl = N, L.canvas = T, L.resolutionLocation = N.getUniformLocation(F, "u_resolution"), L.positionLocation = N.getAttribLocation(F, "a_position"), L.backdropLocation = N.getUniformLocation(F, "u_backdrop"), L.subtypeLocation = N.getUniformLocation(F, "u_subtype");
                            var G = N.getAttribLocation(F, "a_texCoord"),
                                M = N.getUniformLocation(F, "u_image"),
                                _ = N.getUniformLocation(F, "u_mask"),
                                A = N.createBuffer();
                            N.bindBuffer(N.ARRAY_BUFFER, A), N.bufferData(N.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), N.STATIC_DRAW), N.enableVertexAttribArray(G), N.vertexAttribPointer(G, 2, N.FLOAT, !1, 0, 0), N.uniform1i(M, 0), N.uniform1i(_, 1), x = L
                        }

                        function B(T, N, P) {
                            var U = T.width,
                                F = T.height;
                            x || I();
                            var L = x,
                                G = L.canvas,
                                M = L.gl;
                            G.width = U, G.height = F, M.viewport(0, 0, M.drawingBufferWidth, M.drawingBufferHeight), M.uniform2f(L.resolutionLocation, U, F), P.backdrop ? M.uniform4f(L.resolutionLocation, P.backdrop[0], P.backdrop[1], P.backdrop[2], 1) : M.uniform4f(L.resolutionLocation, 0, 0, 0, 0), M.uniform1i(L.subtypeLocation, P.subtype === "Luminosity" ? 1 : 0);
                            var _ = v(M, T, M.TEXTURE0),
                                A = v(M, N, M.TEXTURE1),
                                y = M.createBuffer();
                            return M.bindBuffer(M.ARRAY_BUFFER, y), M.bufferData(M.ARRAY_BUFFER, new Float32Array([0, 0, U, 0, 0, F, 0, F, U, 0, U, F]), M.STATIC_DRAW), M.enableVertexAttribArray(L.positionLocation), M.vertexAttribPointer(L.positionLocation, 2, M.FLOAT, !1, 0, 0), M.clearColor(0, 0, 0, 0), M.enable(M.BLEND), M.blendFunc(M.ONE, M.ONE_MINUS_SRC_ALPHA), M.clear(M.COLOR_BUFFER_BIT), M.drawArrays(M.TRIANGLES, 0, 6), M.flush(), M.deleteTexture(_), M.deleteTexture(A), M.deleteBuffer(y), G
                        }
                        var b = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ",
                            f = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ",
                            d = null;

                        function g() {
                            var T, N;
                            S(), T = m, m = null, N = w, w = null;
                            var P = h(N, b),
                                U = u(N, f),
                                F = l(N, [P, U]);
                            N.useProgram(F);
                            var L = {};
                            L.gl = N, L.canvas = T, L.resolutionLocation = N.getUniformLocation(F, "u_resolution"), L.scaleLocation = N.getUniformLocation(F, "u_scale"), L.offsetLocation = N.getUniformLocation(F, "u_offset"), L.positionLocation = N.getAttribLocation(F, "a_position"), L.colorLocation = N.getAttribLocation(F, "a_color"), d = L
                        }

                        function E(T, N, P, U, F) {
                            d || g();
                            var L = d,
                                G = L.canvas,
                                M = L.gl;
                            G.width = T, G.height = N, M.viewport(0, 0, M.drawingBufferWidth, M.drawingBufferHeight), M.uniform2f(L.resolutionLocation, T, N);
                            var _ = 0,
                                A, y, k;
                            for (A = 0, y = U.length; A < y; A++) switch (U[A].type) {
                                case "lattice":
                                    k = U[A].coords.length / U[A].verticesPerRow | 0, _ += (k - 1) * (U[A].verticesPerRow - 1) * 6;
                                    break;
                                case "triangles":
                                    _ += U[A].coords.length;
                                    break
                            }
                            var R = new Float32Array(_ * 2),
                                D = new Uint8Array(_ * 3),
                                H = F.coords,
                                q = F.colors,
                                z = 0,
                                j = 0;
                            for (A = 0, y = U.length; A < y; A++) {
                                var V = U[A],
                                    K = V.coords,
                                    Y = V.colors;
                                switch (V.type) {
                                    case "lattice":
                                        var Q = V.verticesPerRow;
                                        k = K.length / Q | 0;
                                        for (var ee = 1; ee < k; ee++)
                                            for (var J = ee * Q + 1, ne = 1; ne < Q; ne++, J++) R[z] = H[K[J - Q - 1]], R[z + 1] = H[K[J - Q - 1] + 1], R[z + 2] = H[K[J - Q]], R[z + 3] = H[K[J - Q] + 1], R[z + 4] = H[K[J - 1]], R[z + 5] = H[K[J - 1] + 1], D[j] = q[Y[J - Q - 1]], D[j + 1] = q[Y[J - Q - 1] + 1], D[j + 2] = q[Y[J - Q - 1] + 2], D[j + 3] = q[Y[J - Q]], D[j + 4] = q[Y[J - Q] + 1], D[j + 5] = q[Y[J - Q] + 2], D[j + 6] = q[Y[J - 1]], D[j + 7] = q[Y[J - 1] + 1], D[j + 8] = q[Y[J - 1] + 2], R[z + 6] = R[z + 2], R[z + 7] = R[z + 3], R[z + 8] = R[z + 4], R[z + 9] = R[z + 5], R[z + 10] = H[K[J]], R[z + 11] = H[K[J] + 1], D[j + 9] = D[j + 3], D[j + 10] = D[j + 4], D[j + 11] = D[j + 5], D[j + 12] = D[j + 6], D[j + 13] = D[j + 7], D[j + 14] = D[j + 8], D[j + 15] = q[Y[J]], D[j + 16] = q[Y[J] + 1], D[j + 17] = q[Y[J] + 2], z += 12, j += 18;
                                        break;
                                    case "triangles":
                                        for (var se = 0, ie = K.length; se < ie; se++) R[z] = H[K[se]], R[z + 1] = H[K[se] + 1], D[j] = q[Y[se]], D[j + 1] = q[Y[se] + 1], D[j + 2] = q[Y[se] + 2], z += 2, j += 3;
                                        break
                                }
                            }
                            P ? M.clearColor(P[0] / 255, P[1] / 255, P[2] / 255, 1) : M.clearColor(0, 0, 0, 0), M.clear(M.COLOR_BUFFER_BIT);
                            var he = M.createBuffer();
                            M.bindBuffer(M.ARRAY_BUFFER, he), M.bufferData(M.ARRAY_BUFFER, R, M.STATIC_DRAW), M.enableVertexAttribArray(L.positionLocation), M.vertexAttribPointer(L.positionLocation, 2, M.FLOAT, !1, 0, 0);
                            var fe = M.createBuffer();
                            return M.bindBuffer(M.ARRAY_BUFFER, fe), M.bufferData(M.ARRAY_BUFFER, D, M.STATIC_DRAW), M.enableVertexAttribArray(L.colorLocation), M.vertexAttribPointer(L.colorLocation, 3, M.UNSIGNED_BYTE, !1, 0, 0), M.uniform2f(L.scaleLocation, F.scaleX, F.scaleY), M.uniform2f(L.offsetLocation, F.offsetX, F.offsetY), M.drawArrays(M.TRIANGLES, 0, _), M.flush(), M.deleteBuffer(he), M.deleteBuffer(fe), G
                        }
                        return {
                            tryInitGL() {
                                try {
                                    return S(), !!w
                                } catch {}
                                return !1
                            },
                            composeSMask: B,
                            drawFigures: E,
                            cleanup() {
                                x && x.canvas && (x.canvas.width = 0, x.canvas.height = 0), d && d.canvas && (d.canvas.width = 0, d.canvas.height = 0), x = null, d = null
                            }
                        }
                    }()
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.AnnotationLayer = void 0;
                    var s = n(1),
                        a = n(2);
                    class o {
                        static create(_) {
                            switch (_.data.annotationType) {
                                case a.AnnotationType.LINK:
                                    return new p(_);
                                case a.AnnotationType.TEXT:
                                    return new h(_);
                                case a.AnnotationType.WIDGET:
                                    switch (_.data.fieldType) {
                                        case "Tx":
                                            return new l(_);
                                        case "Btn":
                                            return _.data.radioButton ? new w(_) : _.data.checkBox ? new v(_) : new m(_);
                                        case "Ch":
                                            return new S(_)
                                    }
                                    return new u(_);
                                case a.AnnotationType.POPUP:
                                    return new C(_);
                                case a.AnnotationType.FREETEXT:
                                    return new x(_);
                                case a.AnnotationType.LINE:
                                    return new I(_);
                                case a.AnnotationType.SQUARE:
                                    return new B(_);
                                case a.AnnotationType.CIRCLE:
                                    return new b(_);
                                case a.AnnotationType.POLYLINE:
                                    return new f(_);
                                case a.AnnotationType.CARET:
                                    return new g(_);
                                case a.AnnotationType.INK:
                                    return new E(_);
                                case a.AnnotationType.POLYGON:
                                    return new d(_);
                                case a.AnnotationType.HIGHLIGHT:
                                    return new T(_);
                                case a.AnnotationType.UNDERLINE:
                                    return new N(_);
                                case a.AnnotationType.SQUIGGLY:
                                    return new P(_);
                                case a.AnnotationType.STRIKEOUT:
                                    return new U(_);
                                case a.AnnotationType.STAMP:
                                    return new F(_);
                                case a.AnnotationType.FILEATTACHMENT:
                                    return new L(_);
                                default:
                                    return new c(_)
                            }
                        }
                    }
                    class c {
                        constructor(_, A = !1, y = !1) {
                            this.isRenderable = A, this.data = _.data, this.layer = _.layer, this.page = _.page, this.viewport = _.viewport, this.linkService = _.linkService, this.downloadManager = _.downloadManager, this.imageResourcesPath = _.imageResourcesPath, this.renderInteractiveForms = _.renderInteractiveForms, this.svgFactory = _.svgFactory, A && (this.container = this._createContainer(y))
                        }
                        _createContainer(_ = !1) {
                            const A = this.data,
                                y = this.page,
                                k = this.viewport,
                                R = document.createElement("section");
                            let D = A.rect[2] - A.rect[0],
                                H = A.rect[3] - A.rect[1];
                            R.setAttribute("data-annotation-id", A.id);
                            const q = a.Util.normalizeRect([A.rect[0], y.view[3] - A.rect[1] + y.view[1], A.rect[2], y.view[3] - A.rect[3] + y.view[1]]);
                            if (R.style.transform = `matrix(${k.transform.join(",")})`, R.style.transformOrigin = `-${q[0]}px -${q[1]}px`, !_ && A.borderStyle.width > 0) {
                                R.style.borderWidth = `${A.borderStyle.width}px`, A.borderStyle.style !== a.AnnotationBorderStyleType.UNDERLINE && (D = D - 2 * A.borderStyle.width, H = H - 2 * A.borderStyle.width);
                                const z = A.borderStyle.horizontalCornerRadius,
                                    j = A.borderStyle.verticalCornerRadius;
                                if (z > 0 || j > 0) {
                                    const V = `${z}px / ${j}px`;
                                    R.style.borderRadius = V
                                }
                                switch (A.borderStyle.style) {
                                    case a.AnnotationBorderStyleType.SOLID:
                                        R.style.borderStyle = "solid";
                                        break;
                                    case a.AnnotationBorderStyleType.DASHED:
                                        R.style.borderStyle = "dashed";
                                        break;
                                    case a.AnnotationBorderStyleType.BEVELED:
                                        (0, a.warn)("Unimplemented border style: beveled");
                                        break;
                                    case a.AnnotationBorderStyleType.INSET:
                                        (0, a.warn)("Unimplemented border style: inset");
                                        break;
                                    case a.AnnotationBorderStyleType.UNDERLINE:
                                        R.style.borderBottomStyle = "solid";
                                        break
                                }
                                A.color ? R.style.borderColor = a.Util.makeCssRgb(A.color[0] | 0, A.color[1] | 0, A.color[2] | 0) : R.style.borderWidth = 0
                            }
                            return R.style.left = `${q[0]}px`, R.style.top = `${q[1]}px`, R.style.width = `${D}px`, R.style.height = `${H}px`, R
                        }
                        _createPopup(_, A, y) {
                            A || (A = document.createElement("div"), A.style.height = _.style.height, A.style.width = _.style.width, _.appendChild(A));
                            const R = new O({
                                container: _,
                                trigger: A,
                                color: y.color,
                                title: y.title,
                                modificationDate: y.modificationDate,
                                contents: y.contents,
                                hideWrapper: !0
                            }).render();
                            R.style.left = _.style.width, _.appendChild(R)
                        }
                        render() {
                            (0, a.unreachable)("Abstract method `AnnotationElement.render` called")
                        }
                    }
                    class p extends c {
                        constructor(_) {
                            const A = !!(_.data.url || _.data.dest || _.data.action);
                            super(_, A)
                        }
                        render() {
                            this.container.className = "linkAnnotation";
                            const {
                                data: _,
                                linkService: A
                            } = this, y = document.createElement("a");
                            return _.url ? (0, s.addLinkAttributes)(y, {
                                url: _.url,
                                target: _.newWindow ? s.LinkTarget.BLANK : A.externalLinkTarget,
                                rel: A.externalLinkRel,
                                enabled: A.externalLinkEnabled
                            }) : _.action ? this._bindNamedAction(y, _.action) : this._bindLink(y, _.dest), this.container.appendChild(y), this.container
                        }
                        _bindLink(_, A) {
                            _.href = this.linkService.getDestinationHash(A), _.onclick = () => (A && this.linkService.navigateTo(A), !1), A && (_.className = "internalLink")
                        }
                        _bindNamedAction(_, A) {
                            _.href = this.linkService.getAnchorUrl(""), _.onclick = () => (this.linkService.executeNamedAction(A), !1), _.className = "internalLink"
                        }
                    }
                    class h extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A)
                        }
                        render() {
                            this.container.className = "textAnnotation";
                            const _ = document.createElement("img");
                            return _.style.height = this.container.style.height, _.style.width = this.container.style.width, _.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", _.alt = "[{{type}} Annotation]", _.dataset.l10nId = "text_annotation_type", _.dataset.l10nArgs = JSON.stringify({
                                type: this.data.name
                            }), this.data.hasPopup || this._createPopup(this.container, _, this.data), this.container.appendChild(_), this.container
                        }
                    }
                    class u extends c {
                        render() {
                            return this.container
                        }
                    }
                    class l extends u {
                        constructor(_) {
                            const A = _.renderInteractiveForms || !_.data.hasAppearance && !!_.data.fieldValue;
                            super(_, A)
                        }
                        render() {
                            const _ = ["left", "center", "right"];
                            this.container.className = "textWidgetAnnotation";
                            let A = null;
                            if (this.renderInteractiveForms) {
                                if (this.data.multiLine ? (A = document.createElement("textarea"), A.textContent = this.data.fieldValue) : (A = document.createElement("input"), A.type = "text", A.setAttribute("value", this.data.fieldValue)), A.disabled = this.data.readOnly, A.name = this.data.fieldName, this.data.maxLen !== null && (A.maxLength = this.data.maxLen), this.data.comb) {
                                    const k = (this.data.rect[2] - this.data.rect[0]) / this.data.maxLen;
                                    A.classList.add("comb"), A.style.letterSpacing = `calc(${k}px - 1ch)`
                                }
                            } else {
                                A = document.createElement("div"), A.textContent = this.data.fieldValue, A.style.verticalAlign = "middle", A.style.display = "table-cell";
                                let y = null;
                                this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName) && (y = this.page.commonObjs.get(this.data.fontRefName)), this._setTextStyle(A, y)
                            }
                            return this.data.textAlignment !== null && (A.style.textAlign = _[this.data.textAlignment]), this.container.appendChild(A), this.container
                        }
                        _setTextStyle(_, A) {
                            const y = _.style;
                            if (y.fontSize = `${this.data.fontSize}px`, y.direction = this.data.fontDirection < 0 ? "rtl" : "ltr", !A) return;
                            let k = "normal";
                            A.black ? k = "900" : A.bold && (k = "bold"), y.fontWeight = k, y.fontStyle = A.italic ? "italic" : "normal";
                            const R = A.loadedName ? `"${A.loadedName}", ` : "",
                                D = A.fallbackName || "Helvetica, sans-serif";
                            y.fontFamily = R + D
                        }
                    }
                    class v extends u {
                        constructor(_) {
                            super(_, _.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "buttonWidgetAnnotation checkBox";
                            const _ = document.createElement("input");
                            return _.disabled = this.data.readOnly, _.type = "checkbox", _.name = this.data.fieldName, this.data.fieldValue && this.data.fieldValue !== "Off" && _.setAttribute("checked", !0), this.container.appendChild(_), this.container
                        }
                    }
                    class w extends u {
                        constructor(_) {
                            super(_, _.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "buttonWidgetAnnotation radioButton";
                            const _ = document.createElement("input");
                            return _.disabled = this.data.readOnly, _.type = "radio", _.name = this.data.fieldName, this.data.fieldValue === this.data.buttonValue && _.setAttribute("checked", !0), this.container.appendChild(_), this.container
                        }
                    }
                    class m extends p {
                        render() {
                            const _ = super.render();
                            return _.className = "buttonWidgetAnnotation pushButton", _
                        }
                    }
                    class S extends u {
                        constructor(_) {
                            super(_, _.renderInteractiveForms)
                        }
                        render() {
                            this.container.className = "choiceWidgetAnnotation";
                            const _ = document.createElement("select");
                            _.disabled = this.data.readOnly, _.name = this.data.fieldName, this.data.combo || (_.size = this.data.options.length, this.data.multiSelect && (_.multiple = !0));
                            for (const A of this.data.options) {
                                const y = document.createElement("option");
                                y.textContent = A.displayValue, y.value = A.exportValue, this.data.fieldValue.includes(A.displayValue) && y.setAttribute("selected", !0), _.appendChild(y)
                            }
                            return this.container.appendChild(_), this.container
                        }
                    }
                    class C extends c {
                        constructor(_) {
                            const A = !!(_.data.title || _.data.contents);
                            super(_, A)
                        }
                        render() {
                            const _ = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                            if (this.container.className = "popupAnnotation", _.includes(this.data.parentType)) return this.container;
                            const A = `[data-annotation-id="${this.data.parentId}"]`,
                                y = this.layer.querySelector(A);
                            if (!y) return this.container;
                            const k = new O({
                                    container: this.container,
                                    trigger: y,
                                    color: this.data.color,
                                    title: this.data.title,
                                    modificationDate: this.data.modificationDate,
                                    contents: this.data.contents
                                }),
                                R = parseFloat(y.style.left),
                                D = parseFloat(y.style.width);
                            return this.container.style.transformOrigin = `-${R+D}px -${y.style.top}`, this.container.style.left = `${R+D}px`, this.container.appendChild(k.render()), this.container
                        }
                    }
                    class O {
                        constructor(_) {
                            this.container = _.container, this.trigger = _.trigger, this.color = _.color, this.title = _.title, this.modificationDate = _.modificationDate, this.contents = _.contents, this.hideWrapper = _.hideWrapper || !1, this.pinned = !1
                        }
                        render() {
                            const A = document.createElement("div");
                            A.className = "popupWrapper", this.hideElement = this.hideWrapper ? A : this.container, this.hideElement.setAttribute("hidden", !0);
                            const y = document.createElement("div");
                            y.className = "popup";
                            const k = this.color;
                            if (k) {
                                const q = .7 * (255 - k[0]) + k[0],
                                    z = .7 * (255 - k[1]) + k[1],
                                    j = .7 * (255 - k[2]) + k[2];
                                y.style.backgroundColor = a.Util.makeCssRgb(q | 0, z | 0, j | 0)
                            }
                            const R = document.createElement("h1");
                            R.textContent = this.title, y.appendChild(R);
                            const D = s.PDFDateString.toDateObject(this.modificationDate);
                            if (D) {
                                const q = document.createElement("span");
                                q.textContent = "{{date}}, {{time}}", q.dataset.l10nId = "annotation_date_string", q.dataset.l10nArgs = JSON.stringify({
                                    date: D.toLocaleDateString(),
                                    time: D.toLocaleTimeString()
                                }), y.appendChild(q)
                            }
                            const H = this._formatContents(this.contents);
                            return y.appendChild(H), this.trigger.addEventListener("click", this._toggle.bind(this)), this.trigger.addEventListener("mouseover", this._show.bind(this, !1)), this.trigger.addEventListener("mouseout", this._hide.bind(this, !1)), y.addEventListener("click", this._hide.bind(this, !0)), A.appendChild(y), A
                        }
                        _formatContents(_) {
                            const A = document.createElement("p"),
                                y = _.split(/(?:\r\n?|\n)/);
                            for (let k = 0, R = y.length; k < R; ++k) {
                                const D = y[k];
                                A.appendChild(document.createTextNode(D)), k < R - 1 && A.appendChild(document.createElement("br"))
                            }
                            return A
                        }
                        _toggle() {
                            this.pinned ? this._hide(!0) : this._show(!0)
                        }
                        _show(_ = !1) {
                            _ && (this.pinned = !0), this.hideElement.hasAttribute("hidden") && (this.hideElement.removeAttribute("hidden"), this.container.style.zIndex += 1)
                        }
                        _hide(_ = !0) {
                            _ && (this.pinned = !1), !this.hideElement.hasAttribute("hidden") && !this.pinned && (this.hideElement.setAttribute("hidden", !0), this.container.style.zIndex -= 1)
                        }
                    }
                    class x extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "freeTextAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class I extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            this.container.className = "lineAnnotation";
                            const _ = this.data,
                                A = _.rect[2] - _.rect[0],
                                y = _.rect[3] - _.rect[1],
                                k = this.svgFactory.create(A, y),
                                R = this.svgFactory.createElement("svg:line");
                            return R.setAttribute("x1", _.rect[2] - _.lineCoordinates[0]), R.setAttribute("y1", _.rect[3] - _.lineCoordinates[1]), R.setAttribute("x2", _.rect[2] - _.lineCoordinates[2]), R.setAttribute("y2", _.rect[3] - _.lineCoordinates[3]), R.setAttribute("stroke-width", _.borderStyle.width || 1), R.setAttribute("stroke", "transparent"), k.appendChild(R), this.container.append(k), this._createPopup(this.container, R, _), this.container
                        }
                    }
                    class B extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            this.container.className = "squareAnnotation";
                            const _ = this.data,
                                A = _.rect[2] - _.rect[0],
                                y = _.rect[3] - _.rect[1],
                                k = this.svgFactory.create(A, y),
                                R = _.borderStyle.width,
                                D = this.svgFactory.createElement("svg:rect");
                            return D.setAttribute("x", R / 2), D.setAttribute("y", R / 2), D.setAttribute("width", A - R), D.setAttribute("height", y - R), D.setAttribute("stroke-width", R || 1), D.setAttribute("stroke", "transparent"), D.setAttribute("fill", "none"), k.appendChild(D), this.container.append(k), this._createPopup(this.container, D, _), this.container
                        }
                    }
                    class b extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            this.container.className = "circleAnnotation";
                            const _ = this.data,
                                A = _.rect[2] - _.rect[0],
                                y = _.rect[3] - _.rect[1],
                                k = this.svgFactory.create(A, y),
                                R = _.borderStyle.width,
                                D = this.svgFactory.createElement("svg:ellipse");
                            return D.setAttribute("cx", A / 2), D.setAttribute("cy", y / 2), D.setAttribute("rx", A / 2 - R / 2), D.setAttribute("ry", y / 2 - R / 2), D.setAttribute("stroke-width", R || 1), D.setAttribute("stroke", "transparent"), D.setAttribute("fill", "none"), k.appendChild(D), this.container.append(k), this._createPopup(this.container, D, _), this.container
                        }
                    }
                    class f extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline"
                        }
                        render() {
                            this.container.className = this.containerClassName;
                            const _ = this.data,
                                A = _.rect[2] - _.rect[0],
                                y = _.rect[3] - _.rect[1],
                                k = this.svgFactory.create(A, y);
                            let R = [];
                            for (const H of _.vertices) {
                                const q = H.x - _.rect[0],
                                    z = _.rect[3] - H.y;
                                R.push(q + "," + z)
                            }
                            R = R.join(" ");
                            const D = this.svgFactory.createElement(this.svgElementName);
                            return D.setAttribute("points", R), D.setAttribute("stroke-width", _.borderStyle.width || 1), D.setAttribute("stroke", "transparent"), D.setAttribute("fill", "none"), k.appendChild(D), this.container.append(k), this._createPopup(this.container, D, _), this.container
                        }
                    }
                    class d extends f {
                        constructor(_) {
                            super(_), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon"
                        }
                    }
                    class g extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class E extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline"
                        }
                        render() {
                            this.container.className = this.containerClassName;
                            const _ = this.data,
                                A = _.rect[2] - _.rect[0],
                                y = _.rect[3] - _.rect[1],
                                k = this.svgFactory.create(A, y);
                            for (const R of _.inkLists) {
                                let D = [];
                                for (const q of R) {
                                    const z = q.x - _.rect[0],
                                        j = _.rect[3] - q.y;
                                    D.push(`${z},${j}`)
                                }
                                D = D.join(" ");
                                const H = this.svgFactory.createElement(this.svgElementName);
                                H.setAttribute("points", D), H.setAttribute("stroke-width", _.borderStyle.width || 1), H.setAttribute("stroke", "transparent"), H.setAttribute("fill", "none"), this._createPopup(this.container, H, _), k.appendChild(H)
                            }
                            return this.container.append(k), this.container
                        }
                    }
                    class T extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "highlightAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class N extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "underlineAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class P extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "squigglyAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class U extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "strikeoutAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class F extends c {
                        constructor(_) {
                            const A = !!(_.data.hasPopup || _.data.title || _.data.contents);
                            super(_, A, !0)
                        }
                        render() {
                            return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(this.container, null, this.data), this.container
                        }
                    }
                    class L extends c {
                        constructor(_) {
                            super(_, !0);
                            const {
                                filename: A,
                                content: y
                            } = this.data.file;
                            this.filename = (0, s.getFilenameFromUrl)(A), this.content = y, this.linkService.eventBus && this.linkService.eventBus.dispatch("fileattachmentannotation", {
                                source: this,
                                id: (0, a.stringToPDFString)(A),
                                filename: A,
                                content: y
                            })
                        }
                        render() {
                            this.container.className = "fileAttachmentAnnotation";
                            const _ = document.createElement("div");
                            return _.style.height = this.container.style.height, _.style.width = this.container.style.width, _.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && (this.data.title || this.data.contents) && this._createPopup(this.container, _, this.data), this.container.appendChild(_), this.container
                        }
                        _download() {
                            if (!this.downloadManager) {
                                (0, a.warn)("Download cannot be started due to unavailable download manager");
                                return
                            }
                            this.downloadManager.downloadData(this.content, this.filename, "")
                        }
                    }
                    class G {
                        static render(_) {
                            const A = [],
                                y = [];
                            for (const k of _.annotations)
                                if (!!k) {
                                    if (k.annotationType === a.AnnotationType.POPUP) {
                                        y.push(k);
                                        continue
                                    }
                                    A.push(k)
                                } y.length && A.push(...y);
                            for (const k of A) {
                                const R = o.create({
                                    data: k,
                                    layer: _.div,
                                    page: _.page,
                                    viewport: _.viewport,
                                    linkService: _.linkService,
                                    downloadManager: _.downloadManager,
                                    imageResourcesPath: _.imageResourcesPath || "",
                                    renderInteractiveForms: _.renderInteractiveForms || !1,
                                    svgFactory: new s.DOMSVGFactory
                                });
                                R.isRenderable && _.div.appendChild(R.render())
                            }
                        }
                        static update(_) {
                            for (const A of _.annotations) {
                                const y = _.div.querySelector(`[data-annotation-id="${A.id}"]`);
                                y && (y.style.transform = `matrix(${_.viewport.transform.join(",")})`)
                            }
                            _.div.removeAttribute("hidden")
                        }
                    }
                    r.AnnotationLayer = G
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.renderTextLayer = void 0;
                    var s = n(2),
                        a = function() {
                            var c = 1e5,
                                p = /\S/;

                            function h(x) {
                                return !p.test(x)
                            }

                            function u(x, I, B) {
                                var b = document.createElement("span"),
                                    f = {
                                        angle: 0,
                                        canvasWidth: 0,
                                        isWhitespace: !1,
                                        originalTransform: null,
                                        paddingBottom: 0,
                                        paddingLeft: 0,
                                        paddingRight: 0,
                                        paddingTop: 0,
                                        scale: 1
                                    };
                                if (x._textDivs.push(b), h(I.str)) {
                                    f.isWhitespace = !0, x._textDivProperties.set(b, f);
                                    return
                                }
                                var d = s.Util.transform(x._viewport.transform, I.transform),
                                    g = Math.atan2(d[1], d[0]),
                                    E = B[I.fontName];
                                E.vertical && (g += Math.PI / 2);
                                var T = Math.sqrt(d[2] * d[2] + d[3] * d[3]),
                                    N = T;
                                E.ascent ? N = E.ascent * N : E.descent && (N = (1 + E.descent) * N);
                                let P, U;
                                g === 0 ? (P = d[4], U = d[5] - N) : (P = d[4] + N * Math.sin(g), U = d[5] - N * Math.cos(g)), b.style.left = `${P}px`, b.style.top = `${U}px`, b.style.fontSize = `${T}px`, b.style.fontFamily = E.fontFamily, b.textContent = I.str, x._fontInspectorEnabled && (b.dataset.fontName = I.fontName), g !== 0 && (f.angle = g * (180 / Math.PI));
                                let F = !1;
                                if (I.str.length > 1) F = !0;
                                else if (I.transform[0] !== I.transform[3]) {
                                    const k = Math.abs(I.transform[0]),
                                        R = Math.abs(I.transform[3]);
                                    k !== R && Math.max(k, R) / Math.min(k, R) > 1.5 && (F = !0)
                                }
                                if (F && (E.vertical ? f.canvasWidth = I.height * x._viewport.scale : f.canvasWidth = I.width * x._viewport.scale), x._textDivProperties.set(b, f), x._textContentStream && x._layoutText(b), x._enhanceTextSelection) {
                                    var L = 1,
                                        G = 0;
                                    g !== 0 && (L = Math.cos(g), G = Math.sin(g));
                                    var M = (E.vertical ? I.height : I.width) * x._viewport.scale,
                                        _ = T,
                                        A, y;
                                    g !== 0 ? (A = [L, G, -G, L, P, U], y = s.Util.getAxialAlignedBoundingBox([0, 0, M, _], A)) : y = [P, U, P + M, U + _], x._bounds.push({
                                        left: y[0],
                                        top: y[1],
                                        right: y[2],
                                        bottom: y[3],
                                        div: b,
                                        size: [M, _],
                                        m: A
                                    })
                                }
                            }

                            function l(x) {
                                if (!x._canceled) {
                                    var I = x._textDivs,
                                        B = x._capability,
                                        b = I.length;
                                    if (b > c) {
                                        x._renderingDone = !0, B.resolve();
                                        return
                                    }
                                    if (!x._textContentStream)
                                        for (var f = 0; f < b; f++) x._layoutText(I[f]);
                                    x._renderingDone = !0, B.resolve()
                                }
                            }

                            function v(x, I, B) {
                                let b = 0;
                                for (let f = 0; f < B; f++) {
                                    const d = x[I++];
                                    d > 0 && (b = b ? Math.min(d, b) : d)
                                }
                                return b
                            }

                            function w(x) {
                                for (var I = x._bounds, B = x._viewport, b = m(B.width, B.height, I), f = 0; f < b.length; f++) {
                                    var d = I[f].div,
                                        g = x._textDivProperties.get(d);
                                    if (g.angle === 0) {
                                        g.paddingLeft = I[f].left - b[f].left, g.paddingTop = I[f].top - b[f].top, g.paddingRight = b[f].right - I[f].right, g.paddingBottom = b[f].bottom - I[f].bottom, x._textDivProperties.set(d, g);
                                        continue
                                    }
                                    var E = b[f],
                                        T = I[f],
                                        N = T.m,
                                        P = N[0],
                                        U = N[1],
                                        F = [
                                            [0, 0],
                                            [0, T.size[1]],
                                            [T.size[0], 0], T.size
                                        ],
                                        L = new Float64Array(64);
                                    F.forEach(function(M, _) {
                                        var A = s.Util.applyTransform(M, N);
                                        L[_ + 0] = P && (E.left - A[0]) / P, L[_ + 4] = U && (E.top - A[1]) / U, L[_ + 8] = P && (E.right - A[0]) / P, L[_ + 12] = U && (E.bottom - A[1]) / U, L[_ + 16] = U && (E.left - A[0]) / -U, L[_ + 20] = P && (E.top - A[1]) / P, L[_ + 24] = U && (E.right - A[0]) / -U, L[_ + 28] = P && (E.bottom - A[1]) / P, L[_ + 32] = P && (E.left - A[0]) / -P, L[_ + 36] = U && (E.top - A[1]) / -U, L[_ + 40] = P && (E.right - A[0]) / -P, L[_ + 44] = U && (E.bottom - A[1]) / -U, L[_ + 48] = U && (E.left - A[0]) / U, L[_ + 52] = P && (E.top - A[1]) / -P, L[_ + 56] = U && (E.right - A[0]) / U, L[_ + 60] = P && (E.bottom - A[1]) / -P
                                    });
                                    var G = 1 + Math.min(Math.abs(P), Math.abs(U));
                                    g.paddingLeft = v(L, 32, 16) / G, g.paddingTop = v(L, 48, 16) / G, g.paddingRight = v(L, 0, 16) / G, g.paddingBottom = v(L, 16, 16) / G, x._textDivProperties.set(d, g)
                                }
                            }

                            function m(x, I, B) {
                                var b = B.map(function(d, g) {
                                    return {
                                        x1: d.left,
                                        y1: d.top,
                                        x2: d.right,
                                        y2: d.bottom,
                                        index: g,
                                        x1New: void 0,
                                        x2New: void 0
                                    }
                                });
                                S(x, b);
                                var f = new Array(B.length);
                                return b.forEach(function(d) {
                                    var g = d.index;
                                    f[g] = {
                                        left: d.x1New,
                                        top: 0,
                                        right: d.x2New,
                                        bottom: 0
                                    }
                                }), B.map(function(d, g) {
                                    var E = f[g],
                                        T = b[g];
                                    T.x1 = d.top, T.y1 = x - E.right, T.x2 = d.bottom, T.y2 = x - E.left, T.index = g, T.x1New = void 0, T.x2New = void 0
                                }), S(I, b), b.forEach(function(d) {
                                    var g = d.index;
                                    f[g].top = d.x1New, f[g].bottom = d.x2New
                                }), f
                            }

                            function S(x, I) {
                                I.sort(function(f, d) {
                                    return f.x1 - d.x1 || f.index - d.index
                                });
                                var B = {
                                        x1: -1 / 0,
                                        y1: -1 / 0,
                                        x2: 0,
                                        y2: 1 / 0,
                                        index: -1,
                                        x1New: 0,
                                        x2New: 0
                                    },
                                    b = [{
                                        start: -1 / 0,
                                        end: 1 / 0,
                                        boundary: B
                                    }];
                                I.forEach(function(f) {
                                    for (var d = 0; d < b.length && b[d].end <= f.y1;) d++;
                                    for (var g = b.length - 1; g >= 0 && b[g].start >= f.y2;) g--;
                                    var E, T, N, P, U = -1 / 0;
                                    for (N = d; N <= g; N++) {
                                        E = b[N], T = E.boundary;
                                        var F;
                                        T.x2 > f.x1 ? F = T.index > f.index ? T.x1New : f.x1 : T.x2New === void 0 ? F = (T.x2 + f.x1) / 2 : F = T.x2New, F > U && (U = F)
                                    }
                                    for (f.x1New = U, N = d; N <= g; N++) E = b[N], T = E.boundary, T.x2New === void 0 ? T.x2 > f.x1 ? T.index > f.index && (T.x2New = T.x2) : T.x2New = U : T.x2New > U && (T.x2New = Math.max(U, T.x2));
                                    var L = [],
                                        G = null;
                                    for (N = d; N <= g; N++) {
                                        E = b[N], T = E.boundary;
                                        var M = T.x2 > f.x2 ? T : f;
                                        G === M ? L[L.length - 1].end = E.end : (L.push({
                                            start: E.start,
                                            end: E.end,
                                            boundary: M
                                        }), G = M)
                                    }
                                    for (b[d].start < f.y1 && (L[0].start = f.y1, L.unshift({
                                            start: b[d].start,
                                            end: f.y1,
                                            boundary: b[d].boundary
                                        })), f.y2 < b[g].end && (L[L.length - 1].end = f.y2, L.push({
                                            start: f.y2,
                                            end: b[g].end,
                                            boundary: b[g].boundary
                                        })), N = d; N <= g; N++)
                                        if (E = b[N], T = E.boundary, T.x2New === void 0) {
                                            var _ = !1;
                                            for (P = d - 1; !_ && P >= 0 && b[P].start >= T.y1; P--) _ = b[P].boundary === T;
                                            for (P = g + 1; !_ && P < b.length && b[P].end <= T.y2; P++) _ = b[P].boundary === T;
                                            for (P = 0; !_ && P < L.length; P++) _ = L[P].boundary === T;
                                            _ || (T.x2New = U)
                                        } Array.prototype.splice.apply(b, [d, g - d + 1].concat(L))
                                }), b.forEach(function(f) {
                                    var d = f.boundary;
                                    d.x2New === void 0 && (d.x2New = Math.max(x, d.x2))
                                })
                            }

                            function C({
                                textContent: x,
                                textContentStream: I,
                                container: B,
                                viewport: b,
                                textDivs: f,
                                textContentItemsStr: d,
                                enhanceTextSelection: g
                            }) {
                                this._textContent = x, this._textContentStream = I, this._container = B, this._viewport = b, this._textDivs = f || [], this._textContentItemsStr = d || [], this._enhanceTextSelection = !!g, this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = new WeakMap, this._renderingDone = !1, this._canceled = !1, this._capability = (0, s.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._capability.promise.finally(() => {
                                    this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null)
                                }).catch(() => {})
                            }
                            C.prototype = {
                                get promise() {
                                    return this._capability.promise
                                },
                                cancel: function() {
                                    this._canceled = !0, this._reader && (this._reader.cancel(new s.AbortException("TextLayer task cancelled.")), this._reader = null), this._renderTimer !== null && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."))
                                },
                                _processItems(x, I) {
                                    for (let B = 0, b = x.length; B < b; B++) this._textContentItemsStr.push(x[B].str), u(this, x[B], I)
                                },
                                _layoutText(x) {
                                    const I = this._textDivProperties.get(x);
                                    if (I.isWhitespace) return;
                                    let B = "";
                                    if (I.canvasWidth !== 0) {
                                        const {
                                            fontSize: b,
                                            fontFamily: f
                                        } = x.style;
                                        (b !== this._layoutTextLastFontSize || f !== this._layoutTextLastFontFamily) && (this._layoutTextCtx.font = `${b} ${f}`, this._layoutTextLastFontSize = b, this._layoutTextLastFontFamily = f);
                                        const {
                                            width: d
                                        } = this._layoutTextCtx.measureText(x.textContent);
                                        d > 0 && (I.scale = I.canvasWidth / d, B = `scaleX(${I.scale})`)
                                    }
                                    I.angle !== 0 && (B = `rotate(${I.angle}deg) ${B}`), B.length > 0 && (this._enhanceTextSelection && (I.originalTransform = B), x.style.transform = B), this._textDivProperties.set(x, I), this._container.appendChild(x)
                                },
                                _render: function(I) {
                                    const B = (0, s.createPromiseCapability)();
                                    let b = Object.create(null);
                                    const f = document.createElement("canvas");
                                    if (f.mozOpaque = !0, this._layoutTextCtx = f.getContext("2d", {
                                            alpha: !1
                                        }), this._textContent) {
                                        const d = this._textContent.items,
                                            g = this._textContent.styles;
                                        this._processItems(d, g), B.resolve()
                                    } else if (this._textContentStream) {
                                        const d = () => {
                                            this._reader.read().then(({
                                                value: g,
                                                done: E
                                            }) => {
                                                if (E) {
                                                    B.resolve();
                                                    return
                                                }
                                                Object.assign(b, g.styles), this._processItems(g.items, b), d()
                                            }, B.reject)
                                        };
                                        this._reader = this._textContentStream.getReader(), d()
                                    } else throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                                    B.promise.then(() => {
                                        b = null, I ? this._renderTimer = setTimeout(() => {
                                            l(this), this._renderTimer = null
                                        }, I) : l(this)
                                    }, this._capability.reject)
                                },
                                expandTextDivs: function(I) {
                                    if (!this._enhanceTextSelection || !this._renderingDone) return;
                                    this._bounds !== null && (w(this), this._bounds = null);
                                    const B = [],
                                        b = [];
                                    for (var f = 0, d = this._textDivs.length; f < d; f++) {
                                        const g = this._textDivs[f],
                                            E = this._textDivProperties.get(g);
                                        E.isWhitespace || (I ? (B.length = 0, b.length = 0, E.originalTransform && B.push(E.originalTransform), E.paddingTop > 0 ? (b.push(`${E.paddingTop}px`), B.push(`translateY(${-E.paddingTop}px)`)) : b.push(0), E.paddingRight > 0 ? b.push(`${E.paddingRight/E.scale}px`) : b.push(0), E.paddingBottom > 0 ? b.push(`${E.paddingBottom}px`) : b.push(0), E.paddingLeft > 0 ? (b.push(`${E.paddingLeft/E.scale}px`), B.push(`translateX(${-E.paddingLeft/E.scale}px)`)) : b.push(0), g.style.padding = b.join(" "), B.length && (g.style.transform = B.join(" "))) : (g.style.padding = null, g.style.transform = E.originalTransform))
                                    }
                                }
                            };

                            function O(x) {
                                var I = new C({
                                    textContent: x.textContent,
                                    textContentStream: x.textContentStream,
                                    container: x.container,
                                    viewport: x.viewport,
                                    textDivs: x.textDivs,
                                    textContentItemsStr: x.textContentItemsStr,
                                    enhanceTextSelection: x.enhanceTextSelection
                                });
                                return I._render(x.timeout), I
                            }
                            return O
                        }();
                    r.renderTextLayer = a
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.SVGGraphics = void 0;
                    var s = n(2),
                        a = n(1),
                        o = n(4);
                    let c = function() {
                        throw new Error("Not implemented: SVGGraphics")
                    };
                    r.SVGGraphics = c; {
                        let S = function(b) {
                                let f = [];
                                const d = [];
                                for (const g of b) {
                                    if (g.fn === "save") {
                                        f.push({
                                            fnId: 92,
                                            fn: "group",
                                            items: []
                                        }), d.push(f), f = f[f.length - 1].items;
                                        continue
                                    }
                                    g.fn === "restore" ? f = d.pop() : f.push(g)
                                }
                                return f
                            },
                            C = function(b) {
                                if (Number.isInteger(b)) return b.toString();
                                const f = b.toFixed(10);
                                let d = f.length - 1;
                                if (f[d] !== "0") return f;
                                do d--; while (f[d] === "0");
                                return f.substring(0, f[d] === "." ? d : d + 1)
                            },
                            O = function(b) {
                                if (b[4] === 0 && b[5] === 0) {
                                    if (b[1] === 0 && b[2] === 0) return b[0] === 1 && b[3] === 1 ? "" : `scale(${C(b[0])} ${C(b[3])})`;
                                    if (b[0] === b[3] && b[1] === -b[2]) {
                                        const f = Math.acos(b[0]) * 180 / Math.PI;
                                        return `rotate(${C(f)})`
                                    }
                                } else if (b[0] === 1 && b[1] === 0 && b[2] === 0 && b[3] === 1) return `translate(${C(b[4])} ${C(b[5])})`;
                                return `matrix(${C(b[0])} ${C(b[1])} ${C(b[2])} ${C(b[3])} ${C(b[4])} ${C(b[5])})`
                            };
                        const p = {
                                fontStyle: "normal",
                                fontWeight: "normal",
                                fillColor: "#000000"
                            },
                            h = "http://www.w3.org/XML/1998/namespace",
                            u = "http://www.w3.org/1999/xlink",
                            l = ["butt", "round", "square"],
                            v = ["miter", "round", "bevel"],
                            w = function() {
                                const b = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
                                    f = 12,
                                    d = new Int32Array(256);
                                for (let F = 0; F < 256; F++) {
                                    let L = F;
                                    for (let G = 0; G < 8; G++) L & 1 ? L = 3988292384 ^ L >> 1 & 2147483647 : L = L >> 1 & 2147483647;
                                    d[F] = L
                                }

                                function g(F, L, G) {
                                    let M = -1;
                                    for (let _ = L; _ < G; _++) {
                                        const A = (M ^ F[_]) & 255,
                                            y = d[A];
                                        M = M >>> 8 ^ y
                                    }
                                    return M ^ -1
                                }

                                function E(F, L, G, M) {
                                    let _ = M;
                                    const A = L.length;
                                    G[_] = A >> 24 & 255, G[_ + 1] = A >> 16 & 255, G[_ + 2] = A >> 8 & 255, G[_ + 3] = A & 255, _ += 4, G[_] = F.charCodeAt(0) & 255, G[_ + 1] = F.charCodeAt(1) & 255, G[_ + 2] = F.charCodeAt(2) & 255, G[_ + 3] = F.charCodeAt(3) & 255, _ += 4, G.set(L, _), _ += L.length;
                                    const y = g(G, M + 4, _);
                                    G[_] = y >> 24 & 255, G[_ + 1] = y >> 16 & 255, G[_ + 2] = y >> 8 & 255, G[_ + 3] = y & 255
                                }

                                function T(F, L, G) {
                                    let M = 1,
                                        _ = 0;
                                    for (let A = L; A < G; ++A) M = (M + (F[A] & 255)) % 65521, _ = (_ + M) % 65521;
                                    return _ << 16 | M
                                }

                                function N(F) {
                                    if (!o.isNodeJS) return P(F);
                                    try {
                                        let L;
                                        parseInt(process$1.versions.node) >= 8 ? L = F : L = Buffer.from(F);
                                        const G = require$$4.deflateSync(L, {
                                            level: 9
                                        });
                                        return G instanceof Uint8Array ? G : new Uint8Array(G)
                                    } catch (L) {
                                        (0, s.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + L)
                                    }
                                    return P(F)
                                }

                                function P(F) {
                                    let L = F.length;
                                    const G = 65535,
                                        M = Math.ceil(L / G),
                                        _ = new Uint8Array(2 + L + M * 5 + 4);
                                    let A = 0;
                                    _[A++] = 120, _[A++] = 156;
                                    let y = 0;
                                    for (; L > G;) _[A++] = 0, _[A++] = 255, _[A++] = 255, _[A++] = 0, _[A++] = 0, _.set(F.subarray(y, y + G), A), A += G, y += G, L -= G;
                                    _[A++] = 1, _[A++] = L & 255, _[A++] = L >> 8 & 255, _[A++] = ~L & 65535 & 255, _[A++] = (~L & 65535) >> 8 & 255, _.set(F.subarray(y), A), A += F.length - y;
                                    const k = T(F, 0, F.length);
                                    return _[A++] = k >> 24 & 255, _[A++] = k >> 16 & 255, _[A++] = k >> 8 & 255, _[A++] = k & 255, _
                                }

                                function U(F, L, G, M) {
                                    const _ = F.width,
                                        A = F.height;
                                    let y, k, R;
                                    const D = F.data;
                                    switch (L) {
                                        case s.ImageKind.GRAYSCALE_1BPP:
                                            k = 0, y = 1, R = _ + 7 >> 3;
                                            break;
                                        case s.ImageKind.RGB_24BPP:
                                            k = 2, y = 8, R = _ * 3;
                                            break;
                                        case s.ImageKind.RGBA_32BPP:
                                            k = 6, y = 8, R = _ * 4;
                                            break;
                                        default:
                                            throw new Error("invalid format")
                                    }
                                    const H = new Uint8Array((1 + R) * A);
                                    let q = 0,
                                        z = 0;
                                    for (let ee = 0; ee < A; ++ee) H[q++] = 0, H.set(D.subarray(z, z + R), q), z += R, q += R;
                                    if (L === s.ImageKind.GRAYSCALE_1BPP && M) {
                                        q = 0;
                                        for (let ee = 0; ee < A; ee++) {
                                            q++;
                                            for (let J = 0; J < R; J++) H[q++] ^= 255
                                        }
                                    }
                                    const j = new Uint8Array([_ >> 24 & 255, _ >> 16 & 255, _ >> 8 & 255, _ & 255, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, A & 255, y, k, 0, 0, 0]),
                                        V = N(H),
                                        K = b.length + f * 3 + j.length + V.length,
                                        Y = new Uint8Array(K);
                                    let Q = 0;
                                    return Y.set(b, Q), Q += b.length, E("IHDR", j, Y, Q), Q += f + j.length, E("IDATA", V, Y, Q), Q += f + V.length, E("IEND", new Uint8Array(0), Y, Q), (0, s.createObjectURL)(Y, "image/png", G)
                                }
                                return function(L, G, M) {
                                    const _ = L.kind === void 0 ? s.ImageKind.GRAYSCALE_1BPP : L.kind;
                                    return U(L, _, G, M)
                                }
                            }();
                        class m {
                            constructor() {
                                this.fontSizeScale = 1, this.fontWeight = p.fontWeight, this.fontSize = 0, this.textMatrix = s.IDENTITY_MATRIX, this.fontMatrix = s.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = s.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = p.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = ""
                            }
                            clone() {
                                return Object.create(this)
                            }
                            setCurrentPoint(f, d) {
                                this.x = f, this.y = d
                            }
                        }
                        let x = 0,
                            I = 0,
                            B = 0;
                        r.SVGGraphics = c = class {
                            constructor(f, d, g = !1) {
                                this.svgFactory = new a.DOMSVGFactory, this.current = new m, this.transformMatrix = s.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = f, this.objs = d, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = Object.create(null), this.cssStyle = null, this.forceDataSchema = !!g, this._operatorIdMapping = [];
                                for (const E in s.OPS) this._operatorIdMapping[s.OPS[E]] = E
                            }
                            save() {
                                this.transformStack.push(this.transformMatrix);
                                const f = this.current;
                                this.extraStack.push(f), this.current = f.clone()
                            }
                            restore() {
                                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null
                            }
                            group(f) {
                                this.save(), this.executeOpTree(f), this.restore()
                            }
                            loadDependencies(f) {
                                const d = f.fnArray,
                                    g = f.argsArray;
                                for (let E = 0, T = d.length; E < T; E++)
                                    if (d[E] === s.OPS.dependency)
                                        for (const N of g[E]) {
                                            const P = N.startsWith("g_") ? this.commonObjs : this.objs,
                                                U = new Promise(F => {
                                                    P.get(N, F)
                                                });
                                            this.current.dependencies.push(U)
                                        }
                                return Promise.all(this.current.dependencies)
                            }
                            transform(f, d, g, E, T, N) {
                                const P = [f, d, g, E, T, N];
                                this.transformMatrix = s.Util.transform(this.transformMatrix, P), this.tgrp = null
                            }
                            getSVG(f, d) {
                                this.viewport = d;
                                const g = this._initialize(d);
                                return this.loadDependencies(f).then(() => (this.transformMatrix = s.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(f)), g))
                            }
                            convertOpList(f) {
                                const d = this._operatorIdMapping,
                                    g = f.argsArray,
                                    E = f.fnArray,
                                    T = [];
                                for (let N = 0, P = E.length; N < P; N++) {
                                    const U = E[N];
                                    T.push({
                                        fnId: U,
                                        fn: d[U],
                                        args: g[N]
                                    })
                                }
                                return S(T)
                            }
                            executeOpTree(f) {
                                for (const d of f) {
                                    const g = d.fn,
                                        E = d.fnId,
                                        T = d.args;
                                    switch (E | 0) {
                                        case s.OPS.beginText:
                                            this.beginText();
                                            break;
                                        case s.OPS.dependency:
                                            break;
                                        case s.OPS.setLeading:
                                            this.setLeading(T);
                                            break;
                                        case s.OPS.setLeadingMoveText:
                                            this.setLeadingMoveText(T[0], T[1]);
                                            break;
                                        case s.OPS.setFont:
                                            this.setFont(T);
                                            break;
                                        case s.OPS.showText:
                                            this.showText(T[0]);
                                            break;
                                        case s.OPS.showSpacedText:
                                            this.showText(T[0]);
                                            break;
                                        case s.OPS.endText:
                                            this.endText();
                                            break;
                                        case s.OPS.moveText:
                                            this.moveText(T[0], T[1]);
                                            break;
                                        case s.OPS.setCharSpacing:
                                            this.setCharSpacing(T[0]);
                                            break;
                                        case s.OPS.setWordSpacing:
                                            this.setWordSpacing(T[0]);
                                            break;
                                        case s.OPS.setHScale:
                                            this.setHScale(T[0]);
                                            break;
                                        case s.OPS.setTextMatrix:
                                            this.setTextMatrix(T[0], T[1], T[2], T[3], T[4], T[5]);
                                            break;
                                        case s.OPS.setTextRise:
                                            this.setTextRise(T[0]);
                                            break;
                                        case s.OPS.setTextRenderingMode:
                                            this.setTextRenderingMode(T[0]);
                                            break;
                                        case s.OPS.setLineWidth:
                                            this.setLineWidth(T[0]);
                                            break;
                                        case s.OPS.setLineJoin:
                                            this.setLineJoin(T[0]);
                                            break;
                                        case s.OPS.setLineCap:
                                            this.setLineCap(T[0]);
                                            break;
                                        case s.OPS.setMiterLimit:
                                            this.setMiterLimit(T[0]);
                                            break;
                                        case s.OPS.setFillRGBColor:
                                            this.setFillRGBColor(T[0], T[1], T[2]);
                                            break;
                                        case s.OPS.setStrokeRGBColor:
                                            this.setStrokeRGBColor(T[0], T[1], T[2]);
                                            break;
                                        case s.OPS.setStrokeColorN:
                                            this.setStrokeColorN(T);
                                            break;
                                        case s.OPS.setFillColorN:
                                            this.setFillColorN(T);
                                            break;
                                        case s.OPS.shadingFill:
                                            this.shadingFill(T[0]);
                                            break;
                                        case s.OPS.setDash:
                                            this.setDash(T[0], T[1]);
                                            break;
                                        case s.OPS.setRenderingIntent:
                                            this.setRenderingIntent(T[0]);
                                            break;
                                        case s.OPS.setFlatness:
                                            this.setFlatness(T[0]);
                                            break;
                                        case s.OPS.setGState:
                                            this.setGState(T[0]);
                                            break;
                                        case s.OPS.fill:
                                            this.fill();
                                            break;
                                        case s.OPS.eoFill:
                                            this.eoFill();
                                            break;
                                        case s.OPS.stroke:
                                            this.stroke();
                                            break;
                                        case s.OPS.fillStroke:
                                            this.fillStroke();
                                            break;
                                        case s.OPS.eoFillStroke:
                                            this.eoFillStroke();
                                            break;
                                        case s.OPS.clip:
                                            this.clip("nonzero");
                                            break;
                                        case s.OPS.eoClip:
                                            this.clip("evenodd");
                                            break;
                                        case s.OPS.paintSolidColorImageMask:
                                            this.paintSolidColorImageMask();
                                            break;
                                        case s.OPS.paintImageXObject:
                                            this.paintImageXObject(T[0]);
                                            break;
                                        case s.OPS.paintInlineImageXObject:
                                            this.paintInlineImageXObject(T[0]);
                                            break;
                                        case s.OPS.paintImageMaskXObject:
                                            this.paintImageMaskXObject(T[0]);
                                            break;
                                        case s.OPS.paintFormXObjectBegin:
                                            this.paintFormXObjectBegin(T[0], T[1]);
                                            break;
                                        case s.OPS.paintFormXObjectEnd:
                                            this.paintFormXObjectEnd();
                                            break;
                                        case s.OPS.closePath:
                                            this.closePath();
                                            break;
                                        case s.OPS.closeStroke:
                                            this.closeStroke();
                                            break;
                                        case s.OPS.closeFillStroke:
                                            this.closeFillStroke();
                                            break;
                                        case s.OPS.closeEOFillStroke:
                                            this.closeEOFillStroke();
                                            break;
                                        case s.OPS.nextLine:
                                            this.nextLine();
                                            break;
                                        case s.OPS.transform:
                                            this.transform(T[0], T[1], T[2], T[3], T[4], T[5]);
                                            break;
                                        case s.OPS.constructPath:
                                            this.constructPath(T[0], T[1]);
                                            break;
                                        case s.OPS.endPath:
                                            this.endPath();
                                            break;
                                        case 92:
                                            this.group(d.items);
                                            break;
                                        default:
                                            (0, s.warn)(`Unimplemented operator ${g}`);
                                            break
                                    }
                                }
                            }
                            setWordSpacing(f) {
                                this.current.wordSpacing = f
                            }
                            setCharSpacing(f) {
                                this.current.charSpacing = f
                            }
                            nextLine() {
                                this.moveText(0, this.current.leading)
                            }
                            setTextMatrix(f, d, g, E, T, N) {
                                const P = this.current;
                                P.textMatrix = P.lineMatrix = [f, d, g, E, T, N], P.textMatrixScale = Math.sqrt(f * f + d * d), P.x = P.lineX = 0, P.y = P.lineY = 0, P.xcoords = [], P.ycoords = [], P.tspan = this.svgFactory.createElement("svg:tspan"), P.tspan.setAttributeNS(null, "font-family", P.fontFamily), P.tspan.setAttributeNS(null, "font-size", `${C(P.fontSize)}px`), P.tspan.setAttributeNS(null, "y", C(-P.y)), P.txtElement = this.svgFactory.createElement("svg:text"), P.txtElement.appendChild(P.tspan)
                            }
                            beginText() {
                                const f = this.current;
                                f.x = f.lineX = 0, f.y = f.lineY = 0, f.textMatrix = s.IDENTITY_MATRIX, f.lineMatrix = s.IDENTITY_MATRIX, f.textMatrixScale = 1, f.tspan = this.svgFactory.createElement("svg:tspan"), f.txtElement = this.svgFactory.createElement("svg:text"), f.txtgrp = this.svgFactory.createElement("svg:g"), f.xcoords = [], f.ycoords = []
                            }
                            moveText(f, d) {
                                const g = this.current;
                                g.x = g.lineX += f, g.y = g.lineY += d, g.xcoords = [], g.ycoords = [], g.tspan = this.svgFactory.createElement("svg:tspan"), g.tspan.setAttributeNS(null, "font-family", g.fontFamily), g.tspan.setAttributeNS(null, "font-size", `${C(g.fontSize)}px`), g.tspan.setAttributeNS(null, "y", C(-g.y))
                            }
                            showText(f) {
                                const d = this.current,
                                    g = d.font,
                                    E = d.fontSize;
                                if (E === 0) return;
                                const T = d.fontSizeScale,
                                    N = d.charSpacing,
                                    P = d.wordSpacing,
                                    U = d.fontDirection,
                                    F = d.textHScale * U,
                                    L = g.vertical,
                                    G = L ? 1 : -1,
                                    M = g.defaultVMetrics,
                                    _ = E * d.fontMatrix[0];
                                let A = 0;
                                for (const R of f) {
                                    if (R === null) {
                                        A += U * P;
                                        continue
                                    } else if ((0, s.isNum)(R)) {
                                        A += G * R * E / 1e3;
                                        continue
                                    }
                                    const D = (R.isSpace ? P : 0) + N,
                                        H = R.fontChar;
                                    let q, z, j = R.width;
                                    if (L) {
                                        let K;
                                        const Y = R.vmetric || M;
                                        K = R.vmetric ? Y[1] : j * .5, K = -K * _;
                                        const Q = Y[2] * _;
                                        j = Y ? -Y[0] : j, q = K / T, z = (A + Q) / T
                                    } else q = A / T, z = 0;
                                    (R.isInFont || g.missingFile) && (d.xcoords.push(d.x + q), L && d.ycoords.push(-d.y + z), d.tspan.textContent += H);
                                    let V;
                                    L ? V = j * _ - D * U : V = j * _ + D * U, A += V
                                }
                                d.tspan.setAttributeNS(null, "x", d.xcoords.map(C).join(" ")), L ? d.tspan.setAttributeNS(null, "y", d.ycoords.map(C).join(" ")) : d.tspan.setAttributeNS(null, "y", C(-d.y)), L ? d.y -= A : d.x += A * F, d.tspan.setAttributeNS(null, "font-family", d.fontFamily), d.tspan.setAttributeNS(null, "font-size", `${C(d.fontSize)}px`), d.fontStyle !== p.fontStyle && d.tspan.setAttributeNS(null, "font-style", d.fontStyle), d.fontWeight !== p.fontWeight && d.tspan.setAttributeNS(null, "font-weight", d.fontWeight);
                                const y = d.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK;
                                if (y === s.TextRenderingMode.FILL || y === s.TextRenderingMode.FILL_STROKE ? (d.fillColor !== p.fillColor && d.tspan.setAttributeNS(null, "fill", d.fillColor), d.fillAlpha < 1 && d.tspan.setAttributeNS(null, "fill-opacity", d.fillAlpha)) : d.textRenderingMode === s.TextRenderingMode.ADD_TO_PATH ? d.tspan.setAttributeNS(null, "fill", "transparent") : d.tspan.setAttributeNS(null, "fill", "none"), y === s.TextRenderingMode.STROKE || y === s.TextRenderingMode.FILL_STROKE) {
                                    const R = 1 / (d.textMatrixScale || 1);
                                    this._setStrokeAttributes(d.tspan, R)
                                }
                                let k = d.textMatrix;
                                d.textRise !== 0 && (k = k.slice(), k[5] += d.textRise), d.txtElement.setAttributeNS(null, "transform", `${O(k)} scale(${C(F)}, -1)`), d.txtElement.setAttributeNS(h, "xml:space", "preserve"), d.txtElement.appendChild(d.tspan), d.txtgrp.appendChild(d.txtElement), this._ensureTransformGroup().appendChild(d.txtElement)
                            }
                            setLeadingMoveText(f, d) {
                                this.setLeading(-d), this.moveText(f, d)
                            }
                            addFontStyle(f) {
                                if (!f.data) throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.appendChild(this.cssStyle));
                                const d = (0, s.createObjectURL)(f.data, f.mimetype, this.forceDataSchema);
                                this.cssStyle.textContent += `@font-face { font-family: "${f.loadedName}"; src: url(${d}); }
`
                            }
                            setFont(f) {
                                const d = this.current,
                                    g = this.commonObjs.get(f[0]);
                                let E = f[1];
                                d.font = g, this.embedFonts && !g.missingFile && !this.embeddedFonts[g.loadedName] && (this.addFontStyle(g), this.embeddedFonts[g.loadedName] = g), d.fontMatrix = g.fontMatrix ? g.fontMatrix : s.FONT_IDENTITY_MATRIX;
                                let T = "normal";
                                g.black ? T = "900" : g.bold && (T = "bold");
                                const N = g.italic ? "italic" : "normal";
                                E < 0 ? (E = -E, d.fontDirection = -1) : d.fontDirection = 1, d.fontSize = E, d.fontFamily = g.loadedName, d.fontWeight = T, d.fontStyle = N, d.tspan = this.svgFactory.createElement("svg:tspan"), d.tspan.setAttributeNS(null, "y", C(-d.y)), d.xcoords = [], d.ycoords = []
                            }
                            endText() {
                                const f = this.current;
                                f.textRenderingMode & s.TextRenderingMode.ADD_TO_PATH_FLAG && f.txtElement && f.txtElement.hasChildNodes() && (f.element = f.txtElement, this.clip("nonzero"), this.endPath())
                            }
                            setLineWidth(f) {
                                f > 0 && (this.current.lineWidth = f)
                            }
                            setLineCap(f) {
                                this.current.lineCap = l[f]
                            }
                            setLineJoin(f) {
                                this.current.lineJoin = v[f]
                            }
                            setMiterLimit(f) {
                                this.current.miterLimit = f
                            }
                            setStrokeAlpha(f) {
                                this.current.strokeAlpha = f
                            }
                            setStrokeRGBColor(f, d, g) {
                                this.current.strokeColor = s.Util.makeCssRgb(f, d, g)
                            }
                            setFillAlpha(f) {
                                this.current.fillAlpha = f
                            }
                            setFillRGBColor(f, d, g) {
                                this.current.fillColor = s.Util.makeCssRgb(f, d, g), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = []
                            }
                            setStrokeColorN(f) {
                                this.current.strokeColor = this._makeColorN_Pattern(f)
                            }
                            setFillColorN(f) {
                                this.current.fillColor = this._makeColorN_Pattern(f)
                            }
                            shadingFill(f) {
                                const d = this.viewport.width,
                                    g = this.viewport.height,
                                    E = s.Util.inverseTransform(this.transformMatrix),
                                    T = s.Util.applyTransform([0, 0], E),
                                    N = s.Util.applyTransform([0, g], E),
                                    P = s.Util.applyTransform([d, 0], E),
                                    U = s.Util.applyTransform([d, g], E),
                                    F = Math.min(T[0], N[0], P[0], U[0]),
                                    L = Math.min(T[1], N[1], P[1], U[1]),
                                    G = Math.max(T[0], N[0], P[0], U[0]),
                                    M = Math.max(T[1], N[1], P[1], U[1]),
                                    _ = this.svgFactory.createElement("svg:rect");
                                _.setAttributeNS(null, "x", F), _.setAttributeNS(null, "y", L), _.setAttributeNS(null, "width", G - F), _.setAttributeNS(null, "height", M - L), _.setAttributeNS(null, "fill", this._makeShadingPattern(f)), this.current.fillAlpha < 1 && _.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().appendChild(_)
                            }
                            _makeColorN_Pattern(f) {
                                return f[0] === "TilingPattern" ? this._makeTilingPattern(f) : this._makeShadingPattern(f)
                            }
                            _makeTilingPattern(f) {
                                const d = f[1],
                                    g = f[2],
                                    E = f[3] || s.IDENTITY_MATRIX,
                                    [T, N, P, U] = f[4],
                                    F = f[5],
                                    L = f[6],
                                    G = f[7],
                                    M = `shading${B++}`,
                                    [_, A] = s.Util.applyTransform([T, N], E),
                                    [y, k] = s.Util.applyTransform([P, U], E),
                                    [R, D] = s.Util.singularValueDecompose2dScale(E),
                                    H = F * R,
                                    q = L * D,
                                    z = this.svgFactory.createElement("svg:pattern");
                                z.setAttributeNS(null, "id", M), z.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), z.setAttributeNS(null, "width", H), z.setAttributeNS(null, "height", q), z.setAttributeNS(null, "x", `${_}`), z.setAttributeNS(null, "y", `${A}`);
                                const j = this.svg,
                                    V = this.transformMatrix,
                                    K = this.current.fillColor,
                                    Y = this.current.strokeColor,
                                    Q = this.svgFactory.create(y - _, k - A);
                                if (this.svg = Q, this.transformMatrix = E, G === 2) {
                                    const ee = s.Util.makeCssRgb(...d);
                                    this.current.fillColor = ee, this.current.strokeColor = ee
                                }
                                return this.executeOpTree(this.convertOpList(g)), this.svg = j, this.transformMatrix = V, this.current.fillColor = K, this.current.strokeColor = Y, z.appendChild(Q.childNodes[0]), this.defs.appendChild(z), `url(#${M})`
                            }
                            _makeShadingPattern(f) {
                                switch (f[0]) {
                                    case "RadialAxial":
                                        const d = `shading${B++}`,
                                            g = f[3];
                                        let E;
                                        switch (f[1]) {
                                            case "axial":
                                                const T = f[4],
                                                    N = f[5];
                                                E = this.svgFactory.createElement("svg:linearGradient"), E.setAttributeNS(null, "id", d), E.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), E.setAttributeNS(null, "x1", T[0]), E.setAttributeNS(null, "y1", T[1]), E.setAttributeNS(null, "x2", N[0]), E.setAttributeNS(null, "y2", N[1]);
                                                break;
                                            case "radial":
                                                const P = f[4],
                                                    U = f[5],
                                                    F = f[6],
                                                    L = f[7];
                                                E = this.svgFactory.createElement("svg:radialGradient"), E.setAttributeNS(null, "id", d), E.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), E.setAttributeNS(null, "cx", U[0]), E.setAttributeNS(null, "cy", U[1]), E.setAttributeNS(null, "r", L), E.setAttributeNS(null, "fx", P[0]), E.setAttributeNS(null, "fy", P[1]), E.setAttributeNS(null, "fr", F);
                                                break;
                                            default:
                                                throw new Error(`Unknown RadialAxial type: ${f[1]}`)
                                        }
                                        for (const T of g) {
                                            const N = this.svgFactory.createElement("svg:stop");
                                            N.setAttributeNS(null, "offset", T[0]), N.setAttributeNS(null, "stop-color", T[1]), E.appendChild(N)
                                        }
                                        return this.defs.appendChild(E), `url(#${d})`;
                                    case "Mesh":
                                        return (0, s.warn)("Unimplemented pattern Mesh"), null;
                                    case "Dummy":
                                        return "hotpink";
                                    default:
                                        throw new Error(`Unknown IR type: ${f[0]}`)
                                }
                            }
                            setDash(f, d) {
                                this.current.dashArray = f, this.current.dashPhase = d
                            }
                            constructPath(f, d) {
                                const g = this.current;
                                let E = g.x,
                                    T = g.y,
                                    N = [],
                                    P = 0;
                                for (const U of f) switch (U | 0) {
                                    case s.OPS.rectangle:
                                        E = d[P++], T = d[P++];
                                        const F = d[P++],
                                            L = d[P++],
                                            G = E + F,
                                            M = T + L;
                                        N.push("M", C(E), C(T), "L", C(G), C(T), "L", C(G), C(M), "L", C(E), C(M), "Z");
                                        break;
                                    case s.OPS.moveTo:
                                        E = d[P++], T = d[P++], N.push("M", C(E), C(T));
                                        break;
                                    case s.OPS.lineTo:
                                        E = d[P++], T = d[P++], N.push("L", C(E), C(T));
                                        break;
                                    case s.OPS.curveTo:
                                        E = d[P + 4], T = d[P + 5], N.push("C", C(d[P]), C(d[P + 1]), C(d[P + 2]), C(d[P + 3]), C(E), C(T)), P += 6;
                                        break;
                                    case s.OPS.curveTo2:
                                        N.push("C", C(E), C(T), C(d[P]), C(d[P + 1]), C(d[P + 2]), C(d[P + 3])), E = d[P + 2], T = d[P + 3], P += 4;
                                        break;
                                    case s.OPS.curveTo3:
                                        E = d[P + 2], T = d[P + 3], N.push("C", C(d[P]), C(d[P + 1]), C(E), C(T), C(E), C(T)), P += 4;
                                        break;
                                    case s.OPS.closePath:
                                        N.push("Z");
                                        break
                                }
                                N = N.join(" "), g.path && f.length > 0 && f[0] !== s.OPS.rectangle && f[0] !== s.OPS.moveTo ? N = g.path.getAttributeNS(null, "d") + N : (g.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().appendChild(g.path)), g.path.setAttributeNS(null, "d", N), g.path.setAttributeNS(null, "fill", "none"), g.element = g.path, g.setCurrentPoint(E, T)
                            }
                            endPath() {
                                const f = this.current;
                                if (f.path = null, !this.pendingClip) return;
                                if (!f.element) {
                                    this.pendingClip = null;
                                    return
                                }
                                const d = `clippath${x++}`,
                                    g = this.svgFactory.createElement("svg:clipPath");
                                g.setAttributeNS(null, "id", d), g.setAttributeNS(null, "transform", O(this.transformMatrix));
                                const E = f.element.cloneNode(!0);
                                this.pendingClip === "evenodd" ? E.setAttributeNS(null, "clip-rule", "evenodd") : E.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, g.appendChild(E), this.defs.appendChild(g), f.activeClipUrl && (f.clipGroup = null, this.extraStack.forEach(function(T) {
                                    T.clipGroup = null
                                }), g.setAttributeNS(null, "clip-path", f.activeClipUrl)), f.activeClipUrl = `url(#${d})`, this.tgrp = null
                            }
                            clip(f) {
                                this.pendingClip = f
                            }
                            closePath() {
                                const f = this.current;
                                if (f.path) {
                                    const d = `${f.path.getAttributeNS(null,"d")}Z`;
                                    f.path.setAttributeNS(null, "d", d)
                                }
                            }
                            setLeading(f) {
                                this.current.leading = -f
                            }
                            setTextRise(f) {
                                this.current.textRise = f
                            }
                            setTextRenderingMode(f) {
                                this.current.textRenderingMode = f
                            }
                            setHScale(f) {
                                this.current.textHScale = f / 100
                            }
                            setRenderingIntent(f) {}
                            setFlatness(f) {}
                            setGState(f) {
                                for (const [d, g] of f) switch (d) {
                                    case "LW":
                                        this.setLineWidth(g);
                                        break;
                                    case "LC":
                                        this.setLineCap(g);
                                        break;
                                    case "LJ":
                                        this.setLineJoin(g);
                                        break;
                                    case "ML":
                                        this.setMiterLimit(g);
                                        break;
                                    case "D":
                                        this.setDash(g[0], g[1]);
                                        break;
                                    case "RI":
                                        this.setRenderingIntent(g);
                                        break;
                                    case "FL":
                                        this.setFlatness(g);
                                        break;
                                    case "Font":
                                        this.setFont(g);
                                        break;
                                    case "CA":
                                        this.setStrokeAlpha(g);
                                        break;
                                    case "ca":
                                        this.setFillAlpha(g);
                                        break;
                                    default:
                                        (0, s.warn)(`Unimplemented graphic state operator ${d}`);
                                        break
                                }
                            }
                            fill() {
                                const f = this.current;
                                f.element && (f.element.setAttributeNS(null, "fill", f.fillColor), f.element.setAttributeNS(null, "fill-opacity", f.fillAlpha), this.endPath())
                            }
                            stroke() {
                                const f = this.current;
                                f.element && (this._setStrokeAttributes(f.element), f.element.setAttributeNS(null, "fill", "none"), this.endPath())
                            }
                            _setStrokeAttributes(f, d = 1) {
                                const g = this.current;
                                let E = g.dashArray;
                                d !== 1 && E.length > 0 && (E = E.map(function(T) {
                                    return d * T
                                })), f.setAttributeNS(null, "stroke", g.strokeColor), f.setAttributeNS(null, "stroke-opacity", g.strokeAlpha), f.setAttributeNS(null, "stroke-miterlimit", C(g.miterLimit)), f.setAttributeNS(null, "stroke-linecap", g.lineCap), f.setAttributeNS(null, "stroke-linejoin", g.lineJoin), f.setAttributeNS(null, "stroke-width", C(d * g.lineWidth) + "px"), f.setAttributeNS(null, "stroke-dasharray", E.map(C).join(" ")), f.setAttributeNS(null, "stroke-dashoffset", C(d * g.dashPhase) + "px")
                            }
                            eoFill() {
                                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill()
                            }
                            fillStroke() {
                                this.stroke(), this.fill()
                            }
                            eoFillStroke() {
                                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke()
                            }
                            closeStroke() {
                                this.closePath(), this.stroke()
                            }
                            closeFillStroke() {
                                this.closePath(), this.fillStroke()
                            }
                            closeEOFillStroke() {
                                this.closePath(), this.eoFillStroke()
                            }
                            paintSolidColorImageMask() {
                                const f = this.svgFactory.createElement("svg:rect");
                                f.setAttributeNS(null, "x", "0"), f.setAttributeNS(null, "y", "0"), f.setAttributeNS(null, "width", "1px"), f.setAttributeNS(null, "height", "1px"), f.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().appendChild(f)
                            }
                            paintImageXObject(f) {
                                const d = this.objs.get(f);
                                if (!d) {
                                    (0, s.warn)(`Dependent image with object ID ${f} is not ready yet`);
                                    return
                                }
                                this.paintInlineImageXObject(d)
                            }
                            paintInlineImageXObject(f, d) {
                                const g = f.width,
                                    E = f.height,
                                    T = w(f, this.forceDataSchema, !!d),
                                    N = this.svgFactory.createElement("svg:rect");
                                N.setAttributeNS(null, "x", "0"), N.setAttributeNS(null, "y", "0"), N.setAttributeNS(null, "width", C(g)), N.setAttributeNS(null, "height", C(E)), this.current.element = N, this.clip("nonzero");
                                const P = this.svgFactory.createElement("svg:image");
                                P.setAttributeNS(u, "xlink:href", T), P.setAttributeNS(null, "x", "0"), P.setAttributeNS(null, "y", C(-E)), P.setAttributeNS(null, "width", C(g) + "px"), P.setAttributeNS(null, "height", C(E) + "px"), P.setAttributeNS(null, "transform", `scale(${C(1/g)} ${C(-1/E)})`), d ? d.appendChild(P) : this._ensureTransformGroup().appendChild(P)
                            }
                            paintImageMaskXObject(f) {
                                const d = this.current,
                                    g = f.width,
                                    E = f.height,
                                    T = d.fillColor;
                                d.maskId = `mask${I++}`;
                                const N = this.svgFactory.createElement("svg:mask");
                                N.setAttributeNS(null, "id", d.maskId);
                                const P = this.svgFactory.createElement("svg:rect");
                                P.setAttributeNS(null, "x", "0"), P.setAttributeNS(null, "y", "0"), P.setAttributeNS(null, "width", C(g)), P.setAttributeNS(null, "height", C(E)), P.setAttributeNS(null, "fill", T), P.setAttributeNS(null, "mask", `url(#${d.maskId})`), this.defs.appendChild(N), this._ensureTransformGroup().appendChild(P), this.paintInlineImageXObject(f, N)
                            }
                            paintFormXObjectBegin(f, d) {
                                if (Array.isArray(f) && f.length === 6 && this.transform(f[0], f[1], f[2], f[3], f[4], f[5]), d) {
                                    const g = d[2] - d[0],
                                        E = d[3] - d[1],
                                        T = this.svgFactory.createElement("svg:rect");
                                    T.setAttributeNS(null, "x", d[0]), T.setAttributeNS(null, "y", d[1]), T.setAttributeNS(null, "width", C(g)), T.setAttributeNS(null, "height", C(E)), this.current.element = T, this.clip("nonzero"), this.endPath()
                                }
                            }
                            paintFormXObjectEnd() {}
                            _initialize(f) {
                                const d = this.svgFactory.create(f.width, f.height),
                                    g = this.svgFactory.createElement("svg:defs");
                                d.appendChild(g), this.defs = g;
                                const E = this.svgFactory.createElement("svg:g");
                                return E.setAttributeNS(null, "transform", O(f.transform)), d.appendChild(E), this.svg = E, d
                            }
                            _ensureClipGroup() {
                                if (!this.current.clipGroup) {
                                    const f = this.svgFactory.createElement("svg:g");
                                    f.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.appendChild(f), this.current.clipGroup = f
                                }
                                return this.current.clipGroup
                            }
                            _ensureTransformGroup() {
                                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", O(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().appendChild(this.tgrp) : this.svg.appendChild(this.tgrp)), this.tgrp
                            }
                        }
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.PDFNodeStream = void 0;
                    var s = n(2),
                        a = n(20);
                    const o = require$$4,
                        c = require$$4,
                        p = require$$4,
                        h = require$$4,
                        u = /^file:\/\/\/[a-zA-Z]:\//;

                    function l(B) {
                        const b = h.parse(B);
                        return b.protocol === "file:" || b.host ? b : /^[a-z]:[/\\]/i.test(B) ? h.parse(`file:///${B}`) : (b.host || (b.protocol = "file:"), b)
                    }
                    class v {
                        constructor(b) {
                            this.source = b, this.url = l(b.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && b.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        getFullReader() {
                            return (0, s.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new x(this) : new C(this), this._fullRequestReader
                        }
                        getRangeReader(b, f) {
                            if (f <= this._progressiveDataLength) return null;
                            const d = this.isFsUrl ? new I(this, b, f) : new O(this, b, f);
                            return this._rangeRequestReaders.push(d), d
                        }
                        cancelAllRequests(b) {
                            this._fullRequestReader && this._fullRequestReader.cancel(b), this._rangeRequestReaders.slice(0).forEach(function(d) {
                                d.cancel(b)
                            })
                        }
                    }
                    r.PDFNodeStream = v;
                    class w {
                        constructor(b) {
                            this._url = b.url, this._done = !1, this._storedError = null, this.onProgress = null;
                            const f = b.source;
                            this._contentLength = f.length, this._loaded = 0, this._filename = null, this._disableRange = f.disableRange || !1, this._rangeChunkSize = f.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !f.disableStream, this._isRangeSupported = !f.disableRange, this._readableStream = null, this._readCapability = (0, s.createPromiseCapability)(), this._headersCapability = (0, s.createPromiseCapability)()
                        }
                        get headersReady() {
                            return this._headersCapability.promise
                        }
                        get filename() {
                            return this._filename
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            if (await this._readCapability.promise, this._done) return {
                                value: void 0,
                                done: !0
                            };
                            if (this._storedError) throw this._storedError;
                            const b = this._readableStream.read();
                            return b === null ? (this._readCapability = (0, s.createPromiseCapability)(), this.read()) : (this._loaded += b.length, this.onProgress && this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                            }), {
                                value: new Uint8Array(b).buffer,
                                done: !1
                            })
                        }
                        cancel(b) {
                            if (!this._readableStream) {
                                this._error(b);
                                return
                            }
                            this._readableStream.destroy(b)
                        }
                        _error(b) {
                            this._storedError = b, this._readCapability.resolve()
                        }
                        _setReadableStream(b) {
                            this._readableStream = b, b.on("readable", () => {
                                this._readCapability.resolve()
                            }), b.on("end", () => {
                                b.destroy(), this._done = !0, this._readCapability.resolve()
                            }), b.on("error", f => {
                                this._error(f)
                            }), !this._isStreamingSupported && this._isRangeSupported && this._error(new s.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError)
                        }
                    }
                    class m {
                        constructor(b) {
                            this._url = b.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, s.createPromiseCapability)();
                            const f = b.source;
                            this._isStreamingSupported = !f.disableStream
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            if (await this._readCapability.promise, this._done) return {
                                value: void 0,
                                done: !0
                            };
                            if (this._storedError) throw this._storedError;
                            const b = this._readableStream.read();
                            return b === null ? (this._readCapability = (0, s.createPromiseCapability)(), this.read()) : (this._loaded += b.length, this.onProgress && this.onProgress({
                                loaded: this._loaded
                            }), {
                                value: new Uint8Array(b).buffer,
                                done: !1
                            })
                        }
                        cancel(b) {
                            if (!this._readableStream) {
                                this._error(b);
                                return
                            }
                            this._readableStream.destroy(b)
                        }
                        _error(b) {
                            this._storedError = b, this._readCapability.resolve()
                        }
                        _setReadableStream(b) {
                            this._readableStream = b, b.on("readable", () => {
                                this._readCapability.resolve()
                            }), b.on("end", () => {
                                b.destroy(), this._done = !0, this._readCapability.resolve()
                            }), b.on("error", f => {
                                this._error(f)
                            }), this._storedError && this._readableStream.destroy(this._storedError)
                        }
                    }

                    function S(B, b) {
                        return {
                            protocol: B.protocol,
                            auth: B.auth,
                            host: B.hostname,
                            port: B.port,
                            path: B.path,
                            method: "GET",
                            headers: b
                        }
                    }
                    class C extends w {
                        constructor(b) {
                            super(b);
                            const f = d => {
                                if (d.statusCode === 404) {
                                    const N = new s.MissingPDFException(`Missing PDF "${this._url}".`);
                                    this._storedError = N, this._headersCapability.reject(N);
                                    return
                                }
                                this._headersCapability.resolve(), this._setReadableStream(d);
                                const g = N => this._readableStream.headers[N.toLowerCase()],
                                    {
                                        allowRangeRequests: E,
                                        suggestedLength: T
                                    } = (0, a.validateRangeRequestCapabilities)({
                                        getResponseHeader: g,
                                        isHttp: b.isHttp,
                                        rangeChunkSize: this._rangeChunkSize,
                                        disableRange: this._disableRange
                                    });
                                this._isRangeSupported = E, this._contentLength = T || this._contentLength, this._filename = (0, a.extractFilenameFromHeader)(g)
                            };
                            this._request = null, this._url.protocol === "http:" ? this._request = c.request(S(this._url, b.httpHeaders), f) : this._request = p.request(S(this._url, b.httpHeaders), f), this._request.on("error", d => {
                                this._storedError = d, this._headersCapability.reject(d)
                            }), this._request.end()
                        }
                    }
                    class O extends m {
                        constructor(b, f, d) {
                            super(b), this._httpHeaders = {};
                            for (const E in b.httpHeaders) {
                                const T = b.httpHeaders[E];
                                typeof T > "u" || (this._httpHeaders[E] = T)
                            }
                            this._httpHeaders.Range = `bytes=${f}-${d-1}`;
                            const g = E => {
                                if (E.statusCode === 404) {
                                    const T = new s.MissingPDFException(`Missing PDF "${this._url}".`);
                                    this._storedError = T;
                                    return
                                }
                                this._setReadableStream(E)
                            };
                            this._request = null, this._url.protocol === "http:" ? this._request = c.request(S(this._url, this._httpHeaders), g) : this._request = p.request(S(this._url, this._httpHeaders), g), this._request.on("error", E => {
                                this._storedError = E
                            }), this._request.end()
                        }
                    }
                    class x extends w {
                        constructor(b) {
                            super(b);
                            let f = decodeURIComponent(this._url.path);
                            u.test(this._url.href) && (f = f.replace(/^\//, "")), o.lstat(f, (d, g) => {
                                if (d) {
                                    d.code === "ENOENT" && (d = new s.MissingPDFException(`Missing PDF "${f}".`)), this._storedError = d, this._headersCapability.reject(d);
                                    return
                                }
                                this._contentLength = g.size, this._setReadableStream(o.createReadStream(f)), this._headersCapability.resolve()
                            })
                        }
                    }
                    class I extends m {
                        constructor(b, f, d) {
                            super(b);
                            let g = decodeURIComponent(this._url.path);
                            u.test(this._url.href) && (g = g.replace(/^\//, "")), this._setReadableStream(o.createReadStream(g, {
                                start: f,
                                end: d - 1
                            }))
                        }
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.createResponseStatusError = p, r.extractFilenameFromHeader = c, r.validateRangeRequestCapabilities = o, r.validateResponseStatus = h;
                    var s = n(2),
                        a = n(21);

                    function o({
                        getResponseHeader: u,
                        isHttp: l,
                        rangeChunkSize: v,
                        disableRange: w
                    }) {
                        (0, s.assert)(v > 0, "Range chunk size must be larger than zero");
                        const m = {
                                allowRangeRequests: !1,
                                suggestedLength: void 0
                            },
                            S = parseInt(u("Content-Length"), 10);
                        return !Number.isInteger(S) || (m.suggestedLength = S, S <= 2 * v) || w || !l || u("Accept-Ranges") !== "bytes" || (u("Content-Encoding") || "identity") !== "identity" || (m.allowRangeRequests = !0), m
                    }

                    function c(u) {
                        const l = u("Content-Disposition");
                        if (l) {
                            let v = (0, a.getFilenameFromContentDispositionHeader)(l);
                            if (v.includes("%")) try {
                                v = decodeURIComponent(v)
                            } catch {}
                            if (/\.pdf$/i.test(v)) return v
                        }
                        return null
                    }

                    function p(u, l) {
                        return u === 404 || u === 0 && l.startsWith("file:") ? new s.MissingPDFException('Missing PDF "' + l + '".') : new s.UnexpectedResponseException("Unexpected server response (" + u + ') while retrieving PDF "' + l + '".', u)
                    }

                    function h(u) {
                        return u === 200 || u === 206
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.getFilenameFromContentDispositionHeader = s;

                    function s(a) {
                        let o = !0,
                            c = p("filename\\*", "i").exec(a);
                        if (c) {
                            c = c[1];
                            let S = v(c);
                            return S = unescape(S), S = w(S), S = m(S), u(S)
                        }
                        if (c = l(a), c) {
                            const S = m(c);
                            return u(S)
                        }
                        if (c = p("filename", "i").exec(a), c) {
                            c = c[1];
                            let S = v(c);
                            return S = m(S), u(S)
                        }

                        function p(S, C) {
                            return new RegExp("(?:^|;)\\s*" + S + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', C)
                        }

                        function h(S, C) {
                            if (S) {
                                if (!/^[\x00-\xFF]+$/.test(C)) return C;
                                try {
                                    const O = new TextDecoder(S, {
                                            fatal: !0
                                        }),
                                        x = Array.from(C, function(I) {
                                            return I.charCodeAt(0) & 255
                                        });
                                    C = O.decode(new Uint8Array(x)), o = !1
                                } catch {
                                    if (/^utf-?8$/i.test(S)) try {
                                        C = decodeURIComponent(escape(C)), o = !1
                                    } catch {}
                                }
                            }
                            return C
                        }

                        function u(S) {
                            return o && /[\x80-\xff]/.test(S) && (S = h("utf-8", S), o && (S = h("iso-8859-1", S))), S
                        }

                        function l(S) {
                            const C = [];
                            let O;
                            const x = p("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                            for (;
                                (O = x.exec(S)) !== null;) {
                                let [, B, b, f] = O;
                                if (B = parseInt(B, 10), B in C) {
                                    if (B === 0) break;
                                    continue
                                }
                                C[B] = [b, f]
                            }
                            const I = [];
                            for (let B = 0; B < C.length && B in C; ++B) {
                                let [b, f] = C[B];
                                f = v(f), b && (f = unescape(f), B === 0 && (f = w(f))), I.push(f)
                            }
                            return I.join("")
                        }

                        function v(S) {
                            if (S.startsWith('"')) {
                                const C = S.slice(1).split('\\"');
                                for (let O = 0; O < C.length; ++O) {
                                    const x = C[O].indexOf('"');
                                    x !== -1 && (C[O] = C[O].slice(0, x), C.length = O + 1), C[O] = C[O].replace(/\\(.)/g, "$1")
                                }
                                S = C.join('"')
                            }
                            return S
                        }

                        function w(S) {
                            const C = S.indexOf("'");
                            if (C === -1) return S;
                            const O = S.slice(0, C),
                                I = S.slice(C + 1).replace(/^[^']*'/, "");
                            return h(O, I)
                        }

                        function m(S) {
                            return !S.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(S) ? S : S.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(C, O, x, I) {
                                if (x === "q" || x === "Q") return I = I.replace(/_/g, " "), I = I.replace(/=([0-9a-fA-F]{2})/g, function(B, b) {
                                    return String.fromCharCode(parseInt(b, 16))
                                }), h(O, I);
                                try {
                                    I = atob(I)
                                } catch {}
                                return h(O, I)
                            })
                        }
                        return ""
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.PDFNetworkStream = void 0;
                    var s = n(2),
                        a = n(20);
                    const o = 200,
                        c = 206;

                    function p(w) {
                        const m = w.response;
                        return typeof m != "string" ? m : (0, s.stringToBytes)(m).buffer
                    }
                    class h {
                        constructor(m, S) {
                            this.url = m, S = S || {}, this.isHttp = /^https?:/i.test(m), this.httpHeaders = this.isHttp && S.httpHeaders || {}, this.withCredentials = S.withCredentials || !1, this.getXhr = S.getXhr || function() {
                                return new XMLHttpRequest
                            }, this.currXhrId = 0, this.pendingRequests = Object.create(null)
                        }
                        requestRange(m, S, C) {
                            const O = {
                                begin: m,
                                end: S
                            };
                            for (const x in C) O[x] = C[x];
                            return this.request(O)
                        }
                        requestFull(m) {
                            return this.request(m)
                        }
                        request(m) {
                            const S = this.getXhr(),
                                C = this.currXhrId++,
                                O = this.pendingRequests[C] = {
                                    xhr: S
                                };
                            S.open("GET", this.url), S.withCredentials = this.withCredentials;
                            for (const x in this.httpHeaders) {
                                const I = this.httpHeaders[x];
                                typeof I > "u" || S.setRequestHeader(x, I)
                            }
                            return this.isHttp && "begin" in m && "end" in m ? (S.setRequestHeader("Range", `bytes=${m.begin}-${m.end-1}`), O.expectedStatus = c) : O.expectedStatus = o, S.responseType = "arraybuffer", m.onError && (S.onerror = function(x) {
                                m.onError(S.status)
                            }), S.onreadystatechange = this.onStateChange.bind(this, C), S.onprogress = this.onProgress.bind(this, C), O.onHeadersReceived = m.onHeadersReceived, O.onDone = m.onDone, O.onError = m.onError, O.onProgress = m.onProgress, S.send(null), C
                        }
                        onProgress(m, S) {
                            const C = this.pendingRequests[m];
                            !C || C.onProgress && C.onProgress(S)
                        }
                        onStateChange(m, S) {
                            const C = this.pendingRequests[m];
                            if (!C) return;
                            const O = C.xhr;
                            if (O.readyState >= 2 && C.onHeadersReceived && (C.onHeadersReceived(), delete C.onHeadersReceived), O.readyState !== 4 || !(m in this.pendingRequests)) return;
                            if (delete this.pendingRequests[m], O.status === 0 && this.isHttp) {
                                C.onError && C.onError(O.status);
                                return
                            }
                            const x = O.status || o;
                            if (!(x === o && C.expectedStatus === c) && x !== C.expectedStatus) {
                                C.onError && C.onError(O.status);
                                return
                            }
                            const B = p(O);
                            if (x === c) {
                                const b = O.getResponseHeader("Content-Range"),
                                    f = /bytes (\d+)-(\d+)\/(\d+)/.exec(b);
                                C.onDone({
                                    begin: parseInt(f[1], 10),
                                    chunk: B
                                })
                            } else B ? C.onDone({
                                begin: 0,
                                chunk: B
                            }) : C.onError && C.onError(O.status)
                        }
                        hasPendingRequests() {
                            for (const m in this.pendingRequests) return !0;
                            return !1
                        }
                        getRequestXhr(m) {
                            return this.pendingRequests[m].xhr
                        }
                        isPendingRequest(m) {
                            return m in this.pendingRequests
                        }
                        abortAllRequests() {
                            for (const m in this.pendingRequests) this.abortRequest(m | 0)
                        }
                        abortRequest(m) {
                            const S = this.pendingRequests[m].xhr;
                            delete this.pendingRequests[m], S.abort()
                        }
                    }
                    class u {
                        constructor(m) {
                            this._source = m, this._manager = new h(m.url, {
                                httpHeaders: m.httpHeaders,
                                withCredentials: m.withCredentials
                            }), this._rangeChunkSize = m.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        _onRangeRequestReaderClosed(m) {
                            const S = this._rangeRequestReaders.indexOf(m);
                            S >= 0 && this._rangeRequestReaders.splice(S, 1)
                        }
                        getFullReader() {
                            return (0, s.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new l(this._manager, this._source), this._fullRequestReader
                        }
                        getRangeReader(m, S) {
                            const C = new v(this._manager, m, S);
                            return C.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(C), C
                        }
                        cancelAllRequests(m) {
                            this._fullRequestReader && this._fullRequestReader.cancel(m), this._rangeRequestReaders.slice(0).forEach(function(C) {
                                C.cancel(m)
                            })
                        }
                    }
                    r.PDFNetworkStream = u;
                    class l {
                        constructor(m, S) {
                            this._manager = m;
                            const C = {
                                onHeadersReceived: this._onHeadersReceived.bind(this),
                                onDone: this._onDone.bind(this),
                                onError: this._onError.bind(this),
                                onProgress: this._onProgress.bind(this)
                            };
                            this._url = S.url, this._fullRequestId = m.requestFull(C), this._headersReceivedCapability = (0, s.createPromiseCapability)(), this._disableRange = S.disableRange || !1, this._contentLength = S.length, this._rangeChunkSize = S.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null
                        }
                        _onHeadersReceived() {
                            const m = this._fullRequestId,
                                S = this._manager.getRequestXhr(m),
                                C = I => S.getResponseHeader(I),
                                {
                                    allowRangeRequests: O,
                                    suggestedLength: x
                                } = (0, a.validateRangeRequestCapabilities)({
                                    getResponseHeader: C,
                                    isHttp: this._manager.isHttp,
                                    rangeChunkSize: this._rangeChunkSize,
                                    disableRange: this._disableRange
                                });
                            O && (this._isRangeSupported = !0), this._contentLength = x || this._contentLength, this._filename = (0, a.extractFilenameFromHeader)(C), this._isRangeSupported && this._manager.abortRequest(m), this._headersReceivedCapability.resolve()
                        }
                        _onDone(m) {
                            m && (this._requests.length > 0 ? this._requests.shift().resolve({
                                value: m.chunk,
                                done: !1
                            }) : this._cachedChunks.push(m.chunk)), this._done = !0, !(this._cachedChunks.length > 0) && (this._requests.forEach(function(S) {
                                S.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = [])
                        }
                        _onError(m) {
                            const S = this._url,
                                C = (0, a.createResponseStatusError)(m, S);
                            this._storedError = C, this._headersReceivedCapability.reject(C), this._requests.forEach(function(O) {
                                O.reject(C)
                            }), this._requests = [], this._cachedChunks = []
                        }
                        _onProgress(m) {
                            this.onProgress && this.onProgress({
                                loaded: m.loaded,
                                total: m.lengthComputable ? m.total : this._contentLength
                            })
                        }
                        get filename() {
                            return this._filename
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get headersReady() {
                            return this._headersReceivedCapability.promise
                        }
                        async read() {
                            if (this._storedError) throw this._storedError;
                            if (this._cachedChunks.length > 0) return {
                                value: this._cachedChunks.shift(),
                                done: !1
                            };
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const m = (0, s.createPromiseCapability)();
                            return this._requests.push(m), m.promise
                        }
                        cancel(m) {
                            this._done = !0, this._headersReceivedCapability.reject(m), this._requests.forEach(function(S) {
                                S.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = [], this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null
                        }
                    }
                    class v {
                        constructor(m, S, C) {
                            this._manager = m;
                            const O = {
                                onDone: this._onDone.bind(this),
                                onProgress: this._onProgress.bind(this)
                            };
                            this._requestId = m.requestRange(S, C, O), this._requests = [], this._queuedChunk = null, this._done = !1, this.onProgress = null, this.onClosed = null
                        }
                        _close() {
                            this.onClosed && this.onClosed(this)
                        }
                        _onDone(m) {
                            const S = m.chunk;
                            this._requests.length > 0 ? this._requests.shift().resolve({
                                value: S,
                                done: !1
                            }) : this._queuedChunk = S, this._done = !0, this._requests.forEach(function(C) {
                                C.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = [], this._close()
                        }
                        _onProgress(m) {
                            !this.isStreamingSupported && this.onProgress && this.onProgress({
                                loaded: m.loaded
                            })
                        }
                        get isStreamingSupported() {
                            return !1
                        }
                        async read() {
                            if (this._queuedChunk !== null) {
                                const S = this._queuedChunk;
                                return this._queuedChunk = null, {
                                    value: S,
                                    done: !1
                                }
                            }
                            if (this._done) return {
                                value: void 0,
                                done: !0
                            };
                            const m = (0, s.createPromiseCapability)();
                            return this._requests.push(m), m.promise
                        }
                        cancel(m) {
                            this._done = !0, this._requests.forEach(function(S) {
                                S.resolve({
                                    value: void 0,
                                    done: !0
                                })
                            }), this._requests = [], this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close()
                        }
                    }
                }, function(i, r, n) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.PDFFetchStream = void 0;
                    var s = n(2),
                        a = n(20);

                    function o(l, v, w) {
                        return {
                            method: "GET",
                            headers: l,
                            signal: w && w.signal,
                            mode: "cors",
                            credentials: v ? "include" : "same-origin",
                            redirect: "follow"
                        }
                    }

                    function c(l) {
                        const v = new Headers;
                        for (const w in l) {
                            const m = l[w];
                            typeof m > "u" || v.append(w, m)
                        }
                        return v
                    }
                    class p {
                        constructor(v) {
                            this.source = v, this.isHttp = /^https?:/i.test(v.url), this.httpHeaders = this.isHttp && v.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = []
                        }
                        get _progressiveDataLength() {
                            return this._fullRequestReader ? this._fullRequestReader._loaded : 0
                        }
                        getFullReader() {
                            return (0, s.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new h(this), this._fullRequestReader
                        }
                        getRangeReader(v, w) {
                            if (w <= this._progressiveDataLength) return null;
                            const m = new u(this, v, w);
                            return this._rangeRequestReaders.push(m), m
                        }
                        cancelAllRequests(v) {
                            this._fullRequestReader && this._fullRequestReader.cancel(v), this._rangeRequestReaders.slice(0).forEach(function(m) {
                                m.cancel(v)
                            })
                        }
                    }
                    r.PDFFetchStream = p;
                    class h {
                        constructor(v) {
                            this._stream = v, this._reader = null, this._loaded = 0, this._filename = null;
                            const w = v.source;
                            this._withCredentials = w.withCredentials || !1, this._contentLength = w.length, this._headersCapability = (0, s.createPromiseCapability)(), this._disableRange = w.disableRange || !1, this._rangeChunkSize = w.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), typeof AbortController < "u" && (this._abortController = new AbortController), this._isStreamingSupported = !w.disableStream, this._isRangeSupported = !w.disableRange, this._headers = c(this._stream.httpHeaders);
                            const m = w.url;
                            fetch(m, o(this._headers, this._withCredentials, this._abortController)).then(S => {
                                if (!(0, a.validateResponseStatus)(S.status)) throw (0, a.createResponseStatusError)(S.status, m);
                                this._reader = S.body.getReader(), this._headersCapability.resolve();
                                const C = I => S.headers.get(I),
                                    {
                                        allowRangeRequests: O,
                                        suggestedLength: x
                                    } = (0, a.validateRangeRequestCapabilities)({
                                        getResponseHeader: C,
                                        isHttp: this._stream.isHttp,
                                        rangeChunkSize: this._rangeChunkSize,
                                        disableRange: this._disableRange
                                    });
                                this._isRangeSupported = O, this._contentLength = x || this._contentLength, this._filename = (0, a.extractFilenameFromHeader)(C), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new s.AbortException("Streaming is disabled."))
                            }).catch(this._headersCapability.reject), this.onProgress = null
                        }
                        get headersReady() {
                            return this._headersCapability.promise
                        }
                        get filename() {
                            return this._filename
                        }
                        get contentLength() {
                            return this._contentLength
                        }
                        get isRangeSupported() {
                            return this._isRangeSupported
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            await this._headersCapability.promise;
                            const {
                                value: v,
                                done: w
                            } = await this._reader.read();
                            return w ? {
                                value: v,
                                done: w
                            } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                            }), {
                                value: new Uint8Array(v).buffer,
                                done: !1
                            })
                        }
                        cancel(v) {
                            this._reader && this._reader.cancel(v), this._abortController && this._abortController.abort()
                        }
                    }
                    class u {
                        constructor(v, w, m) {
                            this._stream = v, this._reader = null, this._loaded = 0;
                            const S = v.source;
                            this._withCredentials = S.withCredentials || !1, this._readCapability = (0, s.createPromiseCapability)(), this._isStreamingSupported = !S.disableStream, typeof AbortController < "u" && (this._abortController = new AbortController), this._headers = c(this._stream.httpHeaders), this._headers.append("Range", `bytes=${w}-${m-1}`);
                            const C = S.url;
                            fetch(C, o(this._headers, this._withCredentials, this._abortController)).then(O => {
                                if (!(0, a.validateResponseStatus)(O.status)) throw (0, a.createResponseStatusError)(O.status, C);
                                this._readCapability.resolve(), this._reader = O.body.getReader()
                            }), this.onProgress = null
                        }
                        get isStreamingSupported() {
                            return this._isStreamingSupported
                        }
                        async read() {
                            await this._readCapability.promise;
                            const {
                                value: v,
                                done: w
                            } = await this._reader.read();
                            return w ? {
                                value: v,
                                done: w
                            } : (this._loaded += v.byteLength, this.onProgress && this.onProgress({
                                loaded: this._loaded
                            }), {
                                value: new Uint8Array(v).buffer,
                                done: !1
                            })
                        }
                        cancel(v) {
                            this._reader && this._reader.cancel(v), this._abortController && this._abortController.abort()
                        }
                    }
                }])
            })
        });
    unwrapExports(pdf);
    var pdf_1 = pdf,
        lzString = {
            exports: {}
        };
    (function(i) {
        var r = function() {
            var n = String.fromCharCode,
                s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
                o = {};

            function c(h, u) {
                if (!o[h]) {
                    o[h] = {};
                    for (var l = 0; l < h.length; l++) o[h][h.charAt(l)] = l
                }
                return o[h][u]
            }
            var p = {
                compressToBase64: function(h) {
                    if (h == null) return "";
                    var u = p._compress(h, 6, function(l) {
                        return s.charAt(l)
                    });
                    switch (u.length % 4) {
                        default:
                        case 0:
                            return u;
                        case 1:
                            return u + "===";
                        case 2:
                            return u + "==";
                        case 3:
                            return u + "="
                    }
                },
                decompressFromBase64: function(h) {
                    return h == null ? "" : h == "" ? null : p._decompress(h.length, 32, function(u) {
                        return c(s, h.charAt(u))
                    })
                },
                compressToUTF16: function(h) {
                    return h == null ? "" : p._compress(h, 15, function(u) {
                        return n(u + 32)
                    }) + " "
                },
                decompressFromUTF16: function(h) {
                    return h == null ? "" : h == "" ? null : p._decompress(h.length, 16384, function(u) {
                        return h.charCodeAt(u) - 32
                    })
                },
                compressToUint8Array: function(h) {
                    for (var u = p.compress(h), l = new Uint8Array(u.length * 2), v = 0, w = u.length; v < w; v++) {
                        var m = u.charCodeAt(v);
                        l[v * 2] = m >>> 8, l[v * 2 + 1] = m % 256
                    }
                    return l
                },
                decompressFromUint8Array: function(h) {
                    if (h == null) return p.decompress(h);
                    for (var u = new Array(h.length / 2), l = 0, v = u.length; l < v; l++) u[l] = h[l * 2] * 256 + h[l * 2 + 1];
                    var w = [];
                    return u.forEach(function(m) {
                        w.push(n(m))
                    }), p.decompress(w.join(""))
                },
                compressToEncodedURIComponent: function(h) {
                    return h == null ? "" : p._compress(h, 6, function(u) {
                        return a.charAt(u)
                    })
                },
                decompressFromEncodedURIComponent: function(h) {
                    return h == null ? "" : h == "" ? null : (h = h.replace(/ /g, "+"), p._decompress(h.length, 32, function(u) {
                        return c(a, h.charAt(u))
                    }))
                },
                compress: function(h) {
                    return p._compress(h, 16, function(u) {
                        return n(u)
                    })
                },
                _compress: function(h, u, l) {
                    if (h == null) return "";
                    var v, w, m = {},
                        S = {},
                        C = "",
                        O = "",
                        x = "",
                        I = 2,
                        B = 3,
                        b = 2,
                        f = [],
                        d = 0,
                        g = 0,
                        E;
                    for (E = 0; E < h.length; E += 1)
                        if (C = h.charAt(E), Object.prototype.hasOwnProperty.call(m, C) || (m[C] = B++, S[C] = !0), O = x + C, Object.prototype.hasOwnProperty.call(m, O)) x = O;
                        else {
                            if (Object.prototype.hasOwnProperty.call(S, x)) {
                                if (x.charCodeAt(0) < 256) {
                                    for (v = 0; v < b; v++) d = d << 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++;
                                    for (w = x.charCodeAt(0), v = 0; v < 8; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1
                                } else {
                                    for (w = 1, v = 0; v < b; v++) d = d << 1 | w, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = 0;
                                    for (w = x.charCodeAt(0), v = 0; v < 16; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1
                                }
                                I--, I == 0 && (I = Math.pow(2, b), b++), delete S[x]
                            } else
                                for (w = m[x], v = 0; v < b; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1;
                            I--, I == 0 && (I = Math.pow(2, b), b++), m[O] = B++, x = String(C)
                        } if (x !== "") {
                        if (Object.prototype.hasOwnProperty.call(S, x)) {
                            if (x.charCodeAt(0) < 256) {
                                for (v = 0; v < b; v++) d = d << 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++;
                                for (w = x.charCodeAt(0), v = 0; v < 8; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1
                            } else {
                                for (w = 1, v = 0; v < b; v++) d = d << 1 | w, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = 0;
                                for (w = x.charCodeAt(0), v = 0; v < 16; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1
                            }
                            I--, I == 0 && (I = Math.pow(2, b), b++), delete S[x]
                        } else
                            for (w = m[x], v = 0; v < b; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1;
                        I--, I == 0 && (I = Math.pow(2, b), b++)
                    }
                    for (w = 2, v = 0; v < b; v++) d = d << 1 | w & 1, g == u - 1 ? (g = 0, f.push(l(d)), d = 0) : g++, w = w >> 1;
                    for (;;)
                        if (d = d << 1, g == u - 1) {
                            f.push(l(d));
                            break
                        } else g++;
                    return f.join("")
                },
                decompress: function(h) {
                    return h == null ? "" : h == "" ? null : p._decompress(h.length, 32768, function(u) {
                        return h.charCodeAt(u)
                    })
                },
                _decompress: function(h, u, l) {
                    var v = [],
                        w = 4,
                        m = 4,
                        S = 3,
                        C = "",
                        O = [],
                        x, I, B, b, f, d, g, E = {
                            val: l(0),
                            position: u,
                            index: 1
                        };
                    for (x = 0; x < 3; x += 1) v[x] = x;
                    for (B = 0, f = Math.pow(2, 2), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                    switch (B) {
                        case 0:
                            for (B = 0, f = Math.pow(2, 8), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                            g = n(B);
                            break;
                        case 1:
                            for (B = 0, f = Math.pow(2, 16), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                            g = n(B);
                            break;
                        case 2:
                            return ""
                    }
                    for (v[3] = g, I = g, O.push(g);;) {
                        if (E.index > h) return "";
                        for (B = 0, f = Math.pow(2, S), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                        switch (g = B) {
                            case 0:
                                for (B = 0, f = Math.pow(2, 8), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                                v[m++] = n(B), g = m - 1, w--;
                                break;
                            case 1:
                                for (B = 0, f = Math.pow(2, 16), d = 1; d != f;) b = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = u, E.val = l(E.index++)), B |= (b > 0 ? 1 : 0) * d, d <<= 1;
                                v[m++] = n(B), g = m - 1, w--;
                                break;
                            case 2:
                                return O.join("")
                        }
                        if (w == 0 && (w = Math.pow(2, S), S++), v[g]) C = v[g];
                        else if (g === m) C = I + I.charAt(0);
                        else return null;
                        O.push(C), v[m++] = I + C.charAt(0), w--, I = C, w == 0 && (w = Math.pow(2, S), S++)
                    }
                }
            };
            return p
        }();
        i != null && (i.exports = r)
    })(lzString);
    var duration$1 = {
        exports: {}
    };
    (function(i, r) {
        (function(n, s) {
            i.exports = s()
        })(commonjsGlobal$1, function() {
            var n, s, a = 1e3,
                o = 6e4,
                c = 36e5,
                p = 864e5,
                h = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                u = 31536e6,
                l = 2592e6,
                v = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,
                w = {
                    years: u,
                    months: l,
                    days: p,
                    hours: c,
                    minutes: o,
                    seconds: a,
                    milliseconds: 1,
                    weeks: 6048e5
                },
                m = function(f) {
                    return f instanceof b
                },
                S = function(f, d, g) {
                    return new b(f, g, d.$l)
                },
                C = function(f) {
                    return s.p(f) + "s"
                },
                O = function(f) {
                    return f < 0
                },
                x = function(f) {
                    return O(f) ? Math.ceil(f) : Math.floor(f)
                },
                I = function(f) {
                    return Math.abs(f)
                },
                B = function(f, d) {
                    return f ? O(f) ? {
                        negative: !0,
                        format: "" + I(f) + d
                    } : {
                        negative: !1,
                        format: "" + f + d
                    } : {
                        negative: !1,
                        format: ""
                    }
                },
                b = function() {
                    function f(g, E, T) {
                        var N = this;
                        if (this.$d = {}, this.$l = T, g === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), E) return S(g * w[C(E)], this);
                        if (typeof g == "number") return this.$ms = g, this.parseFromMilliseconds(), this;
                        if (typeof g == "object") return Object.keys(g).forEach(function(F) {
                            N.$d[C(F)] = g[F]
                        }), this.calMilliseconds(), this;
                        if (typeof g == "string") {
                            var P = g.match(v);
                            if (P) {
                                var U = P.slice(2).map(function(F) {
                                    return F != null ? Number(F) : 0
                                });
                                return this.$d.years = U[0], this.$d.months = U[1], this.$d.weeks = U[2], this.$d.days = U[3], this.$d.hours = U[4], this.$d.minutes = U[5], this.$d.seconds = U[6], this.calMilliseconds(), this
                            }
                        }
                        return this
                    }
                    var d = f.prototype;
                    return d.calMilliseconds = function() {
                        var g = this;
                        this.$ms = Object.keys(this.$d).reduce(function(E, T) {
                            return E + (g.$d[T] || 0) * w[T]
                        }, 0)
                    }, d.parseFromMilliseconds = function() {
                        var g = this.$ms;
                        this.$d.years = x(g / u), g %= u, this.$d.months = x(g / l), g %= l, this.$d.days = x(g / p), g %= p, this.$d.hours = x(g / c), g %= c, this.$d.minutes = x(g / o), g %= o, this.$d.seconds = x(g / a), g %= a, this.$d.milliseconds = g
                    }, d.toISOString = function() {
                        var g = B(this.$d.years, "Y"),
                            E = B(this.$d.months, "M"),
                            T = +this.$d.days || 0;
                        this.$d.weeks && (T += 7 * this.$d.weeks);
                        var N = B(T, "D"),
                            P = B(this.$d.hours, "H"),
                            U = B(this.$d.minutes, "M"),
                            F = this.$d.seconds || 0;
                        this.$d.milliseconds && (F += this.$d.milliseconds / 1e3);
                        var L = B(F, "S"),
                            G = g.negative || E.negative || N.negative || P.negative || U.negative || L.negative,
                            M = P.format || U.format || L.format ? "T" : "",
                            _ = (G ? "-" : "") + "P" + g.format + E.format + N.format + M + P.format + U.format + L.format;
                        return _ === "P" || _ === "-P" ? "P0D" : _
                    }, d.toJSON = function() {
                        return this.toISOString()
                    }, d.format = function(g) {
                        var E = g || "YYYY-MM-DDTHH:mm:ss",
                            T = {
                                Y: this.$d.years,
                                YY: s.s(this.$d.years, 2, "0"),
                                YYYY: s.s(this.$d.years, 4, "0"),
                                M: this.$d.months,
                                MM: s.s(this.$d.months, 2, "0"),
                                D: this.$d.days,
                                DD: s.s(this.$d.days, 2, "0"),
                                H: this.$d.hours,
                                HH: s.s(this.$d.hours, 2, "0"),
                                m: this.$d.minutes,
                                mm: s.s(this.$d.minutes, 2, "0"),
                                s: this.$d.seconds,
                                ss: s.s(this.$d.seconds, 2, "0"),
                                SSS: s.s(this.$d.milliseconds, 3, "0")
                            };
                        return E.replace(h, function(N, P) {
                            return P || String(T[N])
                        })
                    }, d.as = function(g) {
                        return this.$ms / w[C(g)]
                    }, d.get = function(g) {
                        var E = this.$ms,
                            T = C(g);
                        return T === "milliseconds" ? E %= 1e3 : E = T === "weeks" ? x(E / w[T]) : this.$d[T], E === 0 ? 0 : E
                    }, d.add = function(g, E, T) {
                        var N;
                        return N = E ? g * w[C(E)] : m(g) ? g.$ms : S(g, this).$ms, S(this.$ms + N * (T ? -1 : 1), this)
                    }, d.subtract = function(g, E) {
                        return this.add(g, E, !0)
                    }, d.locale = function(g) {
                        var E = this.clone();
                        return E.$l = g, E
                    }, d.clone = function() {
                        return S(this.$ms, this)
                    }, d.humanize = function(g) {
                        return n().add(this.$ms, "ms").locale(this.$l).fromNow(!g)
                    }, d.milliseconds = function() {
                        return this.get("milliseconds")
                    }, d.asMilliseconds = function() {
                        return this.as("milliseconds")
                    }, d.seconds = function() {
                        return this.get("seconds")
                    }, d.asSeconds = function() {
                        return this.as("seconds")
                    }, d.minutes = function() {
                        return this.get("minutes")
                    }, d.asMinutes = function() {
                        return this.as("minutes")
                    }, d.hours = function() {
                        return this.get("hours")
                    }, d.asHours = function() {
                        return this.as("hours")
                    }, d.days = function() {
                        return this.get("days")
                    }, d.asDays = function() {
                        return this.as("days")
                    }, d.weeks = function() {
                        return this.get("weeks")
                    }, d.asWeeks = function() {
                        return this.as("weeks")
                    }, d.months = function() {
                        return this.get("months")
                    }, d.asMonths = function() {
                        return this.as("months")
                    }, d.years = function() {
                        return this.get("years")
                    }, d.asYears = function() {
                        return this.as("years")
                    }, f
                }();
            return function(f, d, g) {
                n = g, s = g().$utils(), g.duration = function(N, P) {
                    var U = g.locale();
                    return S(N, {
                        $l: U
                    }, P)
                }, g.isDuration = m;
                var E = d.prototype.add,
                    T = d.prototype.subtract;
                d.prototype.add = function(N, P) {
                    return m(N) && (N = N.asMilliseconds()), E.bind(this)(N, P)
                }, d.prototype.subtract = function(N, P) {
                    return m(N) && (N = N.asMilliseconds()), T.bind(this)(N, P)
                }
            }
        })
    })(duration$1);
    const duration = duration$1.exports;
    var isSameOrBefore$1 = {
        exports: {}
    };
    (function(i, r) {
        (function(n, s) {
            i.exports = s()
        })(commonjsGlobal$1, function() {
            return function(n, s) {
                s.prototype.isSameOrBefore = function(a, o) {
                    return this.isSame(a, o) || this.isBefore(a, o)
                }
            }
        })
    })(isSameOrBefore$1);
    const isSameOrBefore = isSameOrBefore$1.exports;
    var isSameOrAfter$1 = {
        exports: {}
    };
    (function(i, r) {
        (function(n, s) {
            i.exports = s()
        })(commonjsGlobal$1, function() {
            return function(n, s) {
                s.prototype.isSameOrAfter = function(a, o) {
                    return this.isSame(a, o) || this.isAfter(a, o)
                }
            }
        })
    })(isSameOrAfter$1);
    const isSameOrAfter = isSameOrAfter$1.exports,
        TokenType = Object.freeze({
            EOF: Symbol("TEOF"),
            OP: Symbol("TOP"),
            CONST: Symbol("TCONST"),
            NUMBER: Symbol("TNUMBER"),
            STRING: Symbol("TSTRING"),
            PAREN: Symbol("TPAREN"),
            NAME: Symbol("TNAME")
        });
    class Token {
        constructor(r, n, s) {
            this.type = r, this.value = n, this.index = s
        }
        toString() {
            return `${this.type.toString()}: ${this.value}`
        }
    }
    const codePointPattern = /^[0-9a-f]{4}$/i;
    class TokenStream {
        constructor(r, n) {
            this.pos = 0, this.current = null, this.unaryOps = r.unaryOps, this.binaryOps = r.binaryOps, this.consts = r.consts, this.expression = n, this.savedPosition = 0, this.savedCurrent = null, this.options = r.options, this.parser = r
        }
        newToken(r, n, s) {
            return new Token(r, n, s != null ? s : this.pos)
        }
        save() {
            this.savedPosition = this.pos, this.savedCurrent = this.current
        }
        restore() {
            this.pos = this.savedPosition, this.current = this.savedCurrent
        }
        next() {
            return this.pos >= this.expression.length ? this.newToken(TokenType.EOF, "EOF") : this.isWhitespace() ? this.next() : this.isNumber() || this.isOperator() || this.isString() || this.isParen() || this.isNamedOp() || this.isConst() || this.isName() ? this.current : (this.parseError(`Unknown character "${this.expression.charAt(this.pos)}"`), !1)
        }
        isString() {
            let r = !1;
            const n = this.pos,
                s = this.expression.charAt(n);
            if (s === "'" || s === '"') {
                let a = this.expression.indexOf(s, n + 1);
                for (; a >= 0 && this.pos < this.expression.length;) {
                    if (this.pos = a + 1, this.expression.charAt(a - 1) !== "\\") {
                        const o = this.expression.substring(n + 1, a);
                        this.current = this.newToken(TokenType.STRING, this.unescape(o), n), r = !0;
                        break
                    }
                    a = this.expression.indexOf(s, a + 1)
                }
            }
            return r
        }
        isParen() {
            const r = this.expression.charAt(this.pos);
            return r === "(" || r === ")" ? (this.current = this.newToken(TokenType.PAREN, r), this.pos += 1, !0) : !1
        }
        isConst() {
            const r = this.pos;
            let n = r;
            for (; n < this.expression.length; n += 1) {
                const s = this.expression.charAt(n);
                if (s.toUpperCase() === s.toLowerCase() && (n === this.pos || s !== "_" && s !== "." && (s < "0" || s > "9"))) break
            }
            if (n > r) {
                const s = this.expression.substring(r, n);
                if (s in this.consts) return this.current = this.newToken(TokenType.CONST, this.consts[s]), this.pos += s.length, !0
            }
            return !1
        }
        isNamedOp() {
            const r = this.pos;
            let n = r;
            for (; n < this.expression.length; n += 1) {
                const s = this.expression.charAt(n);
                if (s.toUpperCase() === s.toLowerCase() && (n === this.pos || s !== "_" && (s < "0" || s > "9"))) break
            }
            if (n > r) {
                const s = this.expression.substring(r, n);
                if (s === "and" || s === "or" || s in this.binaryOps || s in this.unaryOps) return this.current = this.newToken(TokenType.OP, s), this.pos += s.length, !0
            }
            return !1
        }
        isName() {
            const r = this.pos;
            let n = r,
                s = !1;
            for (; n < this.expression.length; n += 1) {
                const a = this.expression.charAt(n);
                if (a.toUpperCase() === a.toLowerCase()) {
                    if (n === this.pos && (a === "$" || a === "_")) a === "_" && (s = !0);
                    else if (n === this.pos || !s || a !== "_" && (a < "0" || a > "9")) break
                } else s = !0
            }
            if (s) {
                const a = this.expression.substring(r, n);
                return this.current = this.newToken(TokenType.NAME, a), this.pos += a.length, !0
            }
            return !1
        }
        isWhitespace() {
            let r = !1,
                n = this.expression.charAt(this.pos);
            for (;
                (n === " " || n === "	" || n === `
` || n === "\r") && (r = !0, this.pos += 1, !(this.pos >= this.expression.length));) n = this.expression.charAt(this.pos);
            return r
        }
        unescape(r) {
            let n = r.indexOf("\\");
            if (n < 0) return r;
            let s = r.substring(0, n);
            for (; n >= 0;) {
                const a = r.charAt(n += 1);
                let o;
                switch (a) {
                    case "'":
                        s += "'";
                        break;
                    case '"':
                        s += '"';
                        break;
                    case "\\":
                        s += "\\";
                        break;
                    case "/":
                        s += "/";
                        break;
                    case "b":
                        s += "\b";
                        break;
                    case "f":
                        s += "\f";
                        break;
                    case "n":
                        s += `
`;
                        break;
                    case "r":
                        s += "\r";
                        break;
                    case "t":
                        s += "	";
                        break;
                    case "u":
                        o = r.substring(n + 1, n + 5), codePointPattern.test(o) || this.parseError(`Illegal escape sequence: \\u${o}`), s += String.fromCharCode(parseInt(o, 16)), n += 4;
                        break;
                    default:
                        throw this.parseError(`Illegal escape sequence: "\\${a}"`)
                }
                n += 1;
                const c = r.indexOf("\\", n);
                s += r.substring(n, c < 0 ? r.length : c), n = c
            }
            return s
        }
        isNumber() {
            let r = !1,
                {
                    pos: n
                } = this;
            const s = n;
            let a = n,
                o = !1,
                c = !1,
                p;
            for (; n < this.expression.length && (p = this.expression.charAt(n), p >= "0" && p <= "9" || !o && p === ".");) p === "." ? o = !0 : c = !0, n += 1, r = c;
            if (r && (a = n), p === "e" || p === "E") {
                n += 1;
                let h = !0,
                    u = !1;
                for (; n < this.expression.length;) {
                    if (p = this.expression.charAt(n), h && (p === "+" || p === "-")) h = !1;
                    else if (p >= "0" && p <= "9") u = !0, h = !1;
                    else break;
                    n += 1
                }
                u || (n = a)
            }
            return r ? (this.current = this.newToken(TokenType.NUMBER, parseFloat(this.expression.substring(s, n))), this.pos = n) : this.pos = a, r
        }
        isOperator() {
            const r = this.expression.charAt(this.pos);
            if (r === "+" || r === "-" || r === ".") this.current = this.newToken(TokenType.OP, r);
            else if (r === ">") this.expression.charAt(this.pos + 1) === "=" ? (this.current = this.newToken(TokenType.OP, ">="), this.pos += 1) : this.current = this.newToken(TokenType.OP, ">");
            else if (r === "<") this.expression.charAt(this.pos + 1) === "=" ? (this.current = this.newToken(TokenType.OP, "<="), this.pos += 1) : this.current = this.newToken(TokenType.OP, "<");
            else if (r === "=") this.expression.charAt(this.pos + 1) === "=" ? (this.current = this.newToken(TokenType.OP, "=="), this.pos += 1) : this.current = this.newToken(TokenType.OP, r);
            else if (r === "!") this.expression.charAt(this.pos + 1) === "=" ? (this.current = this.newToken(TokenType.OP, "!="), this.pos += 1) : this.current = this.newToken(TokenType.OP, r);
            else return !1;
            return this.pos += 1, !0
        }
        getCoordinates() {
            let r = 0,
                n, s = -1;
            do r += 1, n = this.pos - s, s = this.expression.indexOf(`
`, s + 1); while (s >= 0 && s < this.pos);
            return {
                line: r,
                column: n
            }
        }
        parseError(r) {
            const n = this.getCoordinates();
            throw new Error(`parse error [${n.line}:${n.column}]: ${r}`)
        }
    }
    const InstructionType = Object.freeze({
        NUMBER: Symbol("INUMBER"),
        NULL: Symbol("INULL"),
        STRING: Symbol("ISTRING"),
        DATE: Symbol("IDATE"),
        DURATION: Symbol("IDURATION"),
        BOOL: Symbol("IBOOL"),
        OP1: Symbol("IOP1"),
        OP2: Symbol("IOP2"),
        VAR: Symbol("IVAR"),
        VARNAME: Symbol("IVARNAME"),
        EXPR: Symbol("IEXPR"),
        EXPREVAL: Symbol("IEXPREVAL"),
        MEMBER: Symbol("IMEMBER"),
        ARRAY: Symbol("IARRAY")
    });
    class Instruction {
        constructor(r, n) {
            this.type = r, this.value = typeof n < "u" ? n : 0
        }
        toString() {
            switch (this.type) {
                case InstructionType.NUMBER:
                case InstructionType.STRING:
                case InstructionType.DATE:
                case InstructionType.DURATION:
                case InstructionType.OP1:
                case InstructionType.OP2:
                case InstructionType.VAR:
                    return this.value;
                case InstructionType.NULL:
                    return "NULL";
                case InstructionType.ARRAY:
                    return `ARRAY ${this.value}`;
                case InstructionType.MEMBER:
                    return `.${this.value}`;
                default:
                    return "Invalid Instruction"
            }
        }
    }

    function unaryInstruction(i) {
        return new Instruction(InstructionType.OP1, i)
    }

    function binaryInstruction(i) {
        return new Instruction(InstructionType.OP2, i)
    }
    const DATE_FORMAT = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,
        DURATION_FORMAT = /^([0-9]+)(s|m|h|d|mo|y)$/;
    dayjs.extend(duration), dayjs.extend(utc);

    function IdentifyValue(i) {
        if (typeof i > "u" || i === null) return new Instruction(InstructionType.NULL, null);
        if (dayjs.isDayjs(i)) return new Instruction(InstructionType.DATE, i);
        if (dayjs.isDuration(i)) return new Instruction(InstructionType.DURATION, i);
        if (typeof i == "object") return new Instruction(InstructionType.VAR, i);
        if (typeof i == "boolean") return new Instruction(InstructionType.BOOL, i);
        if (typeof i == "number") return new Instruction(InstructionType.NUMBER, i);
        const r = String(i);
        if (DATE_FORMAT.test(r)) {
            const n = dayjs.utc(r);
            if (n.isValid()) return new Instruction(InstructionType.DATE, n)
        }
        if (DURATION_FORMAT.test(r)) {
            const n = r.match(DURATION_FORMAT);
            return new Instruction(InstructionType.DURATION, dayjs.duration(parseInt(n[1], 10), n[2] === "mo" ? "M" : n[2]))
        }
        return new Instruction(InstructionType.STRING, r)
    }

    function contains$1(i, r) {
        for (let n = 0; n < i.length; n += 1)
            if (i[n] === r) return !0;
        return !1
    }
    const COMPARISON_OPERATORS = ["==", "!=", "<", "<=", ">=", ">"],
        ADD_SUB_OPERATORS = ["+", "-"];

    function tokenMatches(i, r) {
        return typeof r > "u" ? !0 : Array.isArray(r) ? contains$1(r, i.value) : typeof r == "function" ? r(i) : i.value === r
    }

    function pushExpression(i, r) {
        for (let n = 0, s = r.length; n < s; n += 1) i.push(r[n])
    }
    class ParserState {
        constructor(r, n) {
            this.parser = r, this.tokens = n, this.current = null, this.nextToken = null, this.next(), this.savedCurrent = null, this.savedNextToken = null
        }
        next() {
            return this.current = this.nextToken, this.nextToken = this.tokens.next(), this.nextToken
        }
        save() {
            this.savedCurrent = this.current, this.savedNextToken = this.nextToken, this.tokens.save()
        }
        restore() {
            this.tokens.restore(), this.current = this.savedCurrent, this.nextToken = this.savedNextToken
        }
        accept(r, n) {
            return this.nextToken.type === r && tokenMatches(this.nextToken, n) ? (this.next(), !0) : !1
        }
        expect(r, n) {
            if (!this.accept(r, n)) {
                const s = this.tokens.getCoordinates();
                throw new Error(`parse error [${s.line}:${s.column}]: Expected ${n||r.toString()}`)
            }
        }
        parseExpression(r) {
            const n = [];
            this.parseOrExpression(r), pushExpression(r, n)
        }
        parseOrExpression(r) {
            for (this.parseAndExpression(r); this.accept(TokenType.OP, "or");) {
                const n = [];
                this.parseAndExpression(n), r.push(new Instruction(InstructionType.EXPR, n)), r.push(binaryInstruction("or"))
            }
        }
        parseAndExpression(r) {
            for (this.parseComparison(r); this.accept(TokenType.OP, "and");) {
                const n = [];
                this.parseComparison(n), r.push(new Instruction(InstructionType.EXPR, n)), r.push(binaryInstruction("and"))
            }
        }
        parseComparison(r) {
            for (this.parseAddSub(r); this.accept(TokenType.OP, COMPARISON_OPERATORS);) {
                const n = this.current;
                this.parseAddSub(r), r.push(binaryInstruction(n.value))
            }
        }
        parseAddSub(r) {
            for (this.parseFactor(r); this.accept(TokenType.OP, ADD_SUB_OPERATORS);) {
                const n = this.current;
                this.parseFactor(r), r.push(binaryInstruction(n.value))
            }
        }
        parseFactor(r) {
            const {
                unaryOps: n
            } = this.tokens;

            function s(a) {
                return a.value in n
            }
            if (this.save(), this.accept(TokenType.OP, s)) {
                if (this.current.value !== "-" && this.current.value !== "+" && (this.nextToken.type === TokenType.SEMICOLON || this.nextToken.type === TokenType.EOF || this.nextToken.type === TokenType.PAREN && this.nextToken.value === ")")) {
                    this.restore(), this.parseAtom(r);
                    return
                }
                const a = this.current;
                this.parseFactor(r), r.push(unaryInstruction(a.value))
            } else this.parseMemberExpression(r)
        }
        parseAtom(r) {
            const {
                unaryOps: n
            } = this.tokens;

            function s(a) {
                return a.value in n
            }
            if (this.accept(TokenType.NAME) || this.accept(TokenType.OP, s)) r.push(new Instruction(InstructionType.VAR, this.current.value));
            else if (this.accept(TokenType.NUMBER)) r.push(new Instruction(InstructionType.NUMBER, this.current.value));
            else if (this.accept(TokenType.STRING) || this.accept(TokenType.CONST)) r.push(IdentifyValue(this.current.value));
            else if (this.accept(TokenType.PAREN, "(")) this.parseExpression(r), this.expect(TokenType.PAREN, ")");
            else throw new Error(`unexpected ${this.nextToken}`)
        }
        parseMemberExpression(r) {
            for (this.parseAtom(r); this.accept(TokenType.OP, ".");) {
                const n = this.current;
                if (n.value === ".") this.expect(TokenType.NAME), r.push(new Instruction(InstructionType.MEMBER, this.current.value));
                else throw new Error(`unexpected symbol: ${n.value}`)
            }
        }
    }

    function isExpressionEvaluator(i) {
        return i && i.type === InstructionType.EXPREVAL
    }

    function resolveExpression(i, r) {
        return isExpressionEvaluator(i) ? i.value(r) : i
    }

    function evaluateInternal(i, r, n) {
        const s = [];
        let a, o, c;
        if (isExpressionEvaluator(i)) return resolveExpression(i, n);
        const p = i.length;
        for (let h = 0; h < p; h += 1) {
            const u = i[h],
                {
                    type: l
                } = u;
            if (l === InstructionType.NULL || l === InstructionType.BOOL || l === InstructionType.NUMBER || l === InstructionType.STRING || l === InstructionType.DATE || l === InstructionType.DURATION) s.push(u);
            else if (l === InstructionType.OP2)
                if (o = s.pop(), a = s.pop(), u.value === "and") {
                    if (a.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${a.type.toString()} and`);
                    let v = !1;
                    if (a.value) {
                        const w = evaluateInternal(o, r, n);
                        if (w.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${w.type.toString()} and`);
                        v = w.value
                    }
                    s.push(new Instruction(InstructionType.BOOL, v))
                } else if (u.value === "or") {
                if (a.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${a.type.toString()} or`);
                let v = a.value;
                if (!v) {
                    const w = evaluateInternal(o, r, n);
                    if (w.type !== InstructionType.BOOL) throw new Error(`unsupported operation ${w.type.toString()} or`);
                    v = w.value
                }
                s.push(new Instruction(InstructionType.BOOL, v))
            } else c = r.binaryOps[u.value], s.push(c(resolveExpression(a, n), resolveExpression(o, n)));
            else if (l === InstructionType.VAR)
                if (u.value in r.unaryOps) s.push(r.unaryOps[u.value]);
                else {
                    const v = n[u.value];
                    if (typeof v < "u") v && v instanceof Instruction ? s.push(v) : s.push(IdentifyValue(v));
                    else throw new Error(`undefined variable: ${u.value}`)
                }
            else if (l === InstructionType.OP1) a = s.pop(), c = r.unaryOps[u.value], s.push(c(resolveExpression(a, n)));
            else if (l === InstructionType.EXPR) s.push(createExpressionEvaluator(u, r));
            else if (l === InstructionType.EXPREVAL) s.push(u);
            else if (l === InstructionType.MEMBER) {
                a = s.pop();
                const v = a.value[u.value];
                v && v instanceof Instruction ? s.push(v) : s.push(IdentifyValue(v))
            } else throw new Error("invalid expression")
        }
        if (s.length > 1) throw new Error("invalid expression (parity)");
        return s[0].value === 0 ? new Instruction(InstructionType.NULL, null) : resolveExpression(s[0], n)
    }

    function createExpressionEvaluator(i, r) {
        return isExpressionEvaluator(i) ? i : {
            type: InstructionType.EXPREVAL,
            value(n) {
                return evaluateInternal(i.value, r, n)
            }
        }
    }

    function evaluate(i, r, n) {
        return evaluateInternal(i, r, n).value
    }
    class Expression {
        constructor(r, n) {
            this.tokens = r, this.parser = n, this.unaryOps = n.unaryOps, this.binaryOps = n.binaryOps
        }
        evaluate(r) {
            return evaluate(this.tokens, this, r || {})
        }
    }
    dayjs.extend(isSameOrBefore), dayjs.extend(isSameOrAfter), dayjs.extend(utc), dayjs.extend(duration);

    function add(i, r) {
        if (i.type === InstructionType.DATE) {
            if (r.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${i.type.toString()} + ${r.type.toString()}`);
            return new Instruction(InstructionType.DATE, i.value.clone().add(r.value))
        }
        if (r.type === InstructionType.DATE) {
            if (i.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${i.type.toString()} + ${r.type.toString()}`);
            return new Instruction(InstructionType.DATE, r.value.clone().add(i.value))
        }
        if (i.type !== InstructionType.NUMBER || r.type !== InstructionType.NUMBER) throw new Error(`unsupported operation ${i.type.toString()} + ${r.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, Number(i.value) + Number(r.value))
    }

    function sub(i, r) {
        if (i.type === InstructionType.DATE) {
            if (r.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${i.type.toString()} - ${r.type.toString()}`);
            return new Instruction(InstructionType.DATE, i.value.clone().subtract(r.value))
        }
        if (r.type === InstructionType.DATE) {
            if (i.type !== InstructionType.DURATION) throw new Error(`unsupported operation ${i.type.toString()} - ${r.type.toString()}`);
            return new Instruction(InstructionType.DATE, r.value.clone().subtract(i.value))
        }
        if (i.type !== InstructionType.NUMBER || r.type !== InstructionType.NUMBER) throw new Error(`unsupported operation ${i.type.toString()} - ${r.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, i.value - r.value)
    }

    function equal(i, r) {
        if (i.type !== r.type) {
            if (i.value === null || r.value === null) return new Instruction(InstructionType.BOOL, !1);
            throw new Error(`unsupported operation ${i.type.toString()} == ${r.type.toString()}`)
        }
        let n;
        if (i.type === InstructionType.DATE) {
            let s = i.value.clone(),
                a = r.value.clone();
            (s.clone().startOf("day").isSame(s) || a.clone().startOf("day").isSame(a)) && (s = s.startOf("day").utc(!0), a = a.startOf("day").utc(!0)), n = s.isSame(a)
        } else n = i.value === r.value;
        return new Instruction(InstructionType.BOOL, n)
    }

    function notEqual(i, r) {
        return new Instruction(InstructionType.BOOL, !equal(i, r).value)
    }

    function greaterThan(i, r) {
        if (i.type !== r.type) throw new Error(`unsupported operation ${i.type.toString()} > ${r.type.toString()}`);
        let n;
        if (i.type === InstructionType.DATE) {
            let s = i.value.clone(),
                a = r.value.clone();
            (s.clone().startOf("day").isSame(s) || a.clone().startOf("day").isSame(a)) && (s = s.startOf("day").utc(!0), a = a.startOf("day").utc(!0)), n = s.isAfter(a)
        } else n = i.value > r.value;
        return new Instruction(InstructionType.BOOL, n)
    }

    function lessThan(i, r) {
        if (i.type !== r.type) throw new Error(`unsupported operation ${i.type.toString()} < ${r.type.toString()}`);
        let n;
        if (i.type === InstructionType.DATE) {
            let s = i.value.clone(),
                a = r.value.clone();
            (s.clone().startOf("day").isSame(s) || a.clone().startOf("day").isSame(a)) && (s = s.startOf("day").utc(!0), a = a.startOf("day").utc(!0)), n = s.isBefore(a)
        } else n = i.value < r.value;
        return new Instruction(InstructionType.BOOL, n)
    }

    function greaterThanEqual(i, r) {
        if (i.type !== r.type) throw new Error(`unsupported operation ${i.type.toString()} >= ${r.type.toString()}`);
        let n;
        if (i.type === InstructionType.DATE) {
            let s = i.value.clone(),
                a = r.value.clone();
            (s.clone().startOf("day").isSame(s) || a.clone().startOf("day").isSame(a)) && (s = s.startOf("day").utc(!0), a = a.startOf("day").utc(!0)), n = s.isSameOrAfter(a)
        } else n = i.value >= r.value;
        return new Instruction(InstructionType.BOOL, n)
    }

    function lessThanEqual(i, r) {
        if (i.type !== r.type) throw new Error(`unsupported operation ${i.type.toString()} <= ${r.type.toString()}`);
        let n;
        if (i.type === InstructionType.DATE) {
            let s = i.value.clone(),
                a = r.value.clone();
            (s.clone().startOf("day").isSame(s) || a.clone().startOf("day").isSame(a)) && (s = s.startOf("day").utc(!0), a = a.startOf("day").utc(!0)), n = s.isSameOrBefore(a)
        } else n = i.value <= r.value;
        return new Instruction(InstructionType.BOOL, n)
    }

    function neg(i) {
        if (i.type !== InstructionType.NUMBER) throw new Error(`unsupported operation -${i.type.toString()}`);
        return new Instruction(InstructionType.NUMBER, -i.value)
    }

    function not(i) {
        if (i.type !== InstructionType.BOOL) throw new Error(`unsupported operation not(${i.type.toString()})`);
        return new Instruction(InstructionType.BOOL, !i.value)
    }
    class Parser {
        constructor() {
            this.unaryOps = {
                "-": neg,
                "+": Number,
                not
            }, this.binaryOps = {
                "+": add,
                "-": sub,
                "==": equal,
                "!=": notEqual,
                ">": greaterThan,
                "<": lessThan,
                ">=": greaterThanEqual,
                "<=": lessThanEqual
            }, this.consts = {
                true: !0,
                false: !1,
                null: null
            }
        }
        parse(r) {
            const n = [],
                s = new ParserState(this, new TokenStream(this, r));
            return s.parseExpression(n), s.expect(TokenType.EOF, "EOF"), new Expression(n, this)
        }
    }
    const DEFAULT_LANG = "lv";
    dayjs.extend(utc);

    function getActiveRevisions(i) {
        const r = dayjs.utc().startOf("day"),
            n = [];
        for (let s = 0; s < i.revisions.length; s += 1) {
            const a = i.revisions[s];
            a.validFrom && dayjs.utc(a.validFrom).isAfter(r) || a.validTill && dayjs.utc(a.validTill).isBefore(r) || n.push(a)
        }
        return n
    }

    function getActiveRules(i, r, n) {
        const s = [],
            a = getActiveRevisions(n);
        for (let o = 0; o < a.length; o += 1) {
            const c = a[o];
            for (let p = 0; p < c.roles.length; p += 1) {
                const h = c.roles[p];
                if (!(!(h[i] || {}).rules || !h.common && !contains$1(r, h.code)))
                    for (let u = 0; u < h[i].rules.length; u += 1) s.push(h[i].rules[u])
            }
        }
        return s
    }
    const parser = new Parser;
    class ValidationResult$1 {
        constructor(r, n = null, s = null) {
            this.valid = r, this.reason = n, this.reasonBusinessDescription = s
        }
    }

    function validateByType(i, r, n, s) {
        let a = null;
        for (let c = 0; c < i[r].length; c += 1) {
            let p = !1;
            for (let h = 0; h < n.length; h += 1) {
                const u = n[h];
                p = !1, a = u;
                for (let l = 0; l < (u.conditions || []).length; l += 1) {
                    const v = parser.parse(u.conditions[l]),
                        w = i.dob || "1900-01-01",
                        m = {
                            hcert: {
                                nam: i.nam,
                                dob: w
                            },
                            external: {
                                validationClock: dayjs()
                            }
                        };
                    if (m.hcert[r] = i[r][c], v.evaluate(m)) {
                        p = !0, a = null;
                        break
                    }
                }
                if (!p) break
            }
            if (p) return new ValidationResult$1(!0)
        }
        if (a === null) return new ValidationResult$1(!1, "NO_RULES");
        let {
            businessDescription: o
        } = a;
        return s !== DEFAULT_LANG && `businessDescription:${s}` in a && (o = a[`businessDescription:${s}`]), new ValidationResult$1(!1, a.code, o)
    }

    function validate$2(i, r, n, s) {
        return "t" in (i || {}) && Array.isArray(i.t) && i.t.length > 0 ? validateByType(i, "t", getActiveRules("t", r, n), s) : "r" in (i || {}) && Array.isArray(i.r) && i.r.length > 0 ? validateByType(i, "r", getActiveRules("r", r, n), s) : "v" in (i || {}) && Array.isArray(i.v) && i.v.length > 0 ? validateByType(i, "v", getActiveRules("v", r, n), s) : new ValidationResult$1(!1, "UNKNOWN_CERTIFICATE")
    }
    class Role {
        constructor(r, n) {
            this.code = r, this.businessDescription = n
        }
    }

    function getRoles(i, r = DEFAULT_LANG) {
        const n = getActiveRevisions(i),
            s = [],
            a = {};
        for (let o = 0; o < n.length; o += 1) {
            const c = n[o];
            for (let p = 0; p < c.roles.length; p += 1) {
                const h = c.roles[p];
                if (!h.common && !(h.code in a)) {
                    let {
                        businessDescription: u
                    } = h;
                    r !== DEFAULT_LANG && `businessDescription:${r}` in h && (u = h[`businessDescription:${r}`]), s.push(new Role(h.code, u)), a[h.code] = !0
                }
            }
        }
        return s
    } /*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
    const Z_FIXED$1 = 4,
        Z_BINARY = 0,
        Z_TEXT = 1,
        Z_UNKNOWN$1 = 2;

    function zero$1(i) {
        let r = i.length;
        for (; --r >= 0;) i[r] = 0
    }
    const STORED_BLOCK = 0,
        STATIC_TREES = 1,
        DYN_TREES = 2,
        MIN_MATCH$1 = 3,
        MAX_MATCH$1 = 258,
        LENGTH_CODES$1 = 29,
        LITERALS$1 = 256,
        L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1,
        D_CODES$1 = 30,
        BL_CODES$1 = 19,
        HEAP_SIZE$1 = 2 * L_CODES$1 + 1,
        MAX_BITS$1 = 15,
        Buf_size = 16,
        MAX_BL_BITS = 7,
        END_BLOCK = 256,
        REP_3_6 = 16,
        REPZ_3_10 = 17,
        REPZ_11_138 = 18,
        extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
        extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
        extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
        bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
        DIST_CODE_LEN = 512,
        static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    const static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    const base_dist = new Array(D_CODES$1);
    zero$1(base_dist);

    function StaticTreeDesc(i, r, n, s, a) {
        this.static_tree = i, this.extra_bits = r, this.extra_base = n, this.elems = s, this.max_length = a, this.has_stree = i && i.length
    }
    let static_l_desc, static_d_desc, static_bl_desc;

    function TreeDesc(i, r) {
        this.dyn_tree = i, this.max_code = 0, this.stat_desc = r
    }
    const d_code = i => i < 256 ? _dist_code[i] : _dist_code[256 + (i >>> 7)],
        put_short = (i, r) => {
            i.pending_buf[i.pending++] = r & 255, i.pending_buf[i.pending++] = r >>> 8 & 255
        },
        send_bits = (i, r, n) => {
            i.bi_valid > Buf_size - n ? (i.bi_buf |= r << i.bi_valid & 65535, put_short(i, i.bi_buf), i.bi_buf = r >> Buf_size - i.bi_valid, i.bi_valid += n - Buf_size) : (i.bi_buf |= r << i.bi_valid & 65535, i.bi_valid += n)
        },
        send_code = (i, r, n) => {
            send_bits(i, n[r * 2], n[r * 2 + 1])
        },
        bi_reverse = (i, r) => {
            let n = 0;
            do n |= i & 1, i >>>= 1, n <<= 1; while (--r > 0);
            return n >>> 1
        },
        bi_flush = i => {
            i.bi_valid === 16 ? (put_short(i, i.bi_buf), i.bi_buf = 0, i.bi_valid = 0) : i.bi_valid >= 8 && (i.pending_buf[i.pending++] = i.bi_buf & 255, i.bi_buf >>= 8, i.bi_valid -= 8)
        },
        gen_bitlen = (i, r) => {
            const n = r.dyn_tree,
                s = r.max_code,
                a = r.stat_desc.static_tree,
                o = r.stat_desc.has_stree,
                c = r.stat_desc.extra_bits,
                p = r.stat_desc.extra_base,
                h = r.stat_desc.max_length;
            let u, l, v, w, m, S, C = 0;
            for (w = 0; w <= MAX_BITS$1; w++) i.bl_count[w] = 0;
            for (n[i.heap[i.heap_max] * 2 + 1] = 0, u = i.heap_max + 1; u < HEAP_SIZE$1; u++) l = i.heap[u], w = n[n[l * 2 + 1] * 2 + 1] + 1, w > h && (w = h, C++), n[l * 2 + 1] = w, !(l > s) && (i.bl_count[w]++, m = 0, l >= p && (m = c[l - p]), S = n[l * 2], i.opt_len += S * (w + m), o && (i.static_len += S * (a[l * 2 + 1] + m)));
            if (C !== 0) {
                do {
                    for (w = h - 1; i.bl_count[w] === 0;) w--;
                    i.bl_count[w]--, i.bl_count[w + 1] += 2, i.bl_count[h]--, C -= 2
                } while (C > 0);
                for (w = h; w !== 0; w--)
                    for (l = i.bl_count[w]; l !== 0;) v = i.heap[--u], !(v > s) && (n[v * 2 + 1] !== w && (i.opt_len += (w - n[v * 2 + 1]) * n[v * 2], n[v * 2 + 1] = w), l--)
            }
        },
        gen_codes = (i, r, n) => {
            const s = new Array(MAX_BITS$1 + 1);
            let a = 0,
                o, c;
            for (o = 1; o <= MAX_BITS$1; o++) s[o] = a = a + n[o - 1] << 1;
            for (c = 0; c <= r; c++) {
                let p = i[c * 2 + 1];
                p !== 0 && (i[c * 2] = bi_reverse(s[p]++, p))
            }
        },
        tr_static_init = () => {
            let i, r, n, s, a;
            const o = new Array(MAX_BITS$1 + 1);
            for (n = 0, s = 0; s < LENGTH_CODES$1 - 1; s++)
                for (base_length[s] = n, i = 0; i < 1 << extra_lbits[s]; i++) _length_code[n++] = s;
            for (_length_code[n - 1] = s, a = 0, s = 0; s < 16; s++)
                for (base_dist[s] = a, i = 0; i < 1 << extra_dbits[s]; i++) _dist_code[a++] = s;
            for (a >>= 7; s < D_CODES$1; s++)
                for (base_dist[s] = a << 7, i = 0; i < 1 << extra_dbits[s] - 7; i++) _dist_code[256 + a++] = s;
            for (r = 0; r <= MAX_BITS$1; r++) o[r] = 0;
            for (i = 0; i <= 143;) static_ltree[i * 2 + 1] = 8, i++, o[8]++;
            for (; i <= 255;) static_ltree[i * 2 + 1] = 9, i++, o[9]++;
            for (; i <= 279;) static_ltree[i * 2 + 1] = 7, i++, o[7]++;
            for (; i <= 287;) static_ltree[i * 2 + 1] = 8, i++, o[8]++;
            for (gen_codes(static_ltree, L_CODES$1 + 1, o), i = 0; i < D_CODES$1; i++) static_dtree[i * 2 + 1] = 5, static_dtree[i * 2] = bi_reverse(i, 5);
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS)
        },
        init_block = i => {
            let r;
            for (r = 0; r < L_CODES$1; r++) i.dyn_ltree[r * 2] = 0;
            for (r = 0; r < D_CODES$1; r++) i.dyn_dtree[r * 2] = 0;
            for (r = 0; r < BL_CODES$1; r++) i.bl_tree[r * 2] = 0;
            i.dyn_ltree[END_BLOCK * 2] = 1, i.opt_len = i.static_len = 0, i.last_lit = i.matches = 0
        },
        bi_windup = i => {
            i.bi_valid > 8 ? put_short(i, i.bi_buf) : i.bi_valid > 0 && (i.pending_buf[i.pending++] = i.bi_buf), i.bi_buf = 0, i.bi_valid = 0
        },
        copy_block = (i, r, n, s) => {
            bi_windup(i), s && (put_short(i, n), put_short(i, ~n)), i.pending_buf.set(i.window.subarray(r, r + n), i.pending), i.pending += n
        },
        smaller = (i, r, n, s) => {
            const a = r * 2,
                o = n * 2;
            return i[a] < i[o] || i[a] === i[o] && s[r] <= s[n]
        },
        pqdownheap = (i, r, n) => {
            const s = i.heap[n];
            let a = n << 1;
            for (; a <= i.heap_len && (a < i.heap_len && smaller(r, i.heap[a + 1], i.heap[a], i.depth) && a++, !smaller(r, s, i.heap[a], i.depth));) i.heap[n] = i.heap[a], n = a, a <<= 1;
            i.heap[n] = s
        },
        compress_block = (i, r, n) => {
            let s, a, o = 0,
                c, p;
            if (i.last_lit !== 0)
                do s = i.pending_buf[i.d_buf + o * 2] << 8 | i.pending_buf[i.d_buf + o * 2 + 1], a = i.pending_buf[i.l_buf + o], o++, s === 0 ? send_code(i, a, r) : (c = _length_code[a], send_code(i, c + LITERALS$1 + 1, r), p = extra_lbits[c], p !== 0 && (a -= base_length[c], send_bits(i, a, p)), s--, c = d_code(s), send_code(i, c, n), p = extra_dbits[c], p !== 0 && (s -= base_dist[c], send_bits(i, s, p))); while (o < i.last_lit);
            send_code(i, END_BLOCK, r)
        },
        build_tree = (i, r) => {
            const n = r.dyn_tree,
                s = r.stat_desc.static_tree,
                a = r.stat_desc.has_stree,
                o = r.stat_desc.elems;
            let c, p, h = -1,
                u;
            for (i.heap_len = 0, i.heap_max = HEAP_SIZE$1, c = 0; c < o; c++) n[c * 2] !== 0 ? (i.heap[++i.heap_len] = h = c, i.depth[c] = 0) : n[c * 2 + 1] = 0;
            for (; i.heap_len < 2;) u = i.heap[++i.heap_len] = h < 2 ? ++h : 0, n[u * 2] = 1, i.depth[u] = 0, i.opt_len--, a && (i.static_len -= s[u * 2 + 1]);
            for (r.max_code = h, c = i.heap_len >> 1; c >= 1; c--) pqdownheap(i, n, c);
            u = o;
            do c = i.heap[1], i.heap[1] = i.heap[i.heap_len--], pqdownheap(i, n, 1), p = i.heap[1], i.heap[--i.heap_max] = c, i.heap[--i.heap_max] = p, n[u * 2] = n[c * 2] + n[p * 2], i.depth[u] = (i.depth[c] >= i.depth[p] ? i.depth[c] : i.depth[p]) + 1, n[c * 2 + 1] = n[p * 2 + 1] = u, i.heap[1] = u++, pqdownheap(i, n, 1); while (i.heap_len >= 2);
            i.heap[--i.heap_max] = i.heap[1], gen_bitlen(i, r), gen_codes(n, h, i.bl_count)
        },
        scan_tree = (i, r, n) => {
            let s, a = -1,
                o, c = r[0 * 2 + 1],
                p = 0,
                h = 7,
                u = 4;
            for (c === 0 && (h = 138, u = 3), r[(n + 1) * 2 + 1] = 65535, s = 0; s <= n; s++) o = c, c = r[(s + 1) * 2 + 1], !(++p < h && o === c) && (p < u ? i.bl_tree[o * 2] += p : o !== 0 ? (o !== a && i.bl_tree[o * 2]++, i.bl_tree[REP_3_6 * 2]++) : p <= 10 ? i.bl_tree[REPZ_3_10 * 2]++ : i.bl_tree[REPZ_11_138 * 2]++, p = 0, a = o, c === 0 ? (h = 138, u = 3) : o === c ? (h = 6, u = 3) : (h = 7, u = 4))
        },
        send_tree = (i, r, n) => {
            let s, a = -1,
                o, c = r[0 * 2 + 1],
                p = 0,
                h = 7,
                u = 4;
            for (c === 0 && (h = 138, u = 3), s = 0; s <= n; s++)
                if (o = c, c = r[(s + 1) * 2 + 1], !(++p < h && o === c)) {
                    if (p < u)
                        do send_code(i, o, i.bl_tree); while (--p !== 0);
                    else o !== 0 ? (o !== a && (send_code(i, o, i.bl_tree), p--), send_code(i, REP_3_6, i.bl_tree), send_bits(i, p - 3, 2)) : p <= 10 ? (send_code(i, REPZ_3_10, i.bl_tree), send_bits(i, p - 3, 3)) : (send_code(i, REPZ_11_138, i.bl_tree), send_bits(i, p - 11, 7));
                    p = 0, a = o, c === 0 ? (h = 138, u = 3) : o === c ? (h = 6, u = 3) : (h = 7, u = 4)
                }
        },
        build_bl_tree = i => {
            let r;
            for (scan_tree(i, i.dyn_ltree, i.l_desc.max_code), scan_tree(i, i.dyn_dtree, i.d_desc.max_code), build_tree(i, i.bl_desc), r = BL_CODES$1 - 1; r >= 3 && i.bl_tree[bl_order[r] * 2 + 1] === 0; r--);
            return i.opt_len += 3 * (r + 1) + 5 + 5 + 4, r
        },
        send_all_trees = (i, r, n, s) => {
            let a;
            for (send_bits(i, r - 257, 5), send_bits(i, n - 1, 5), send_bits(i, s - 4, 4), a = 0; a < s; a++) send_bits(i, i.bl_tree[bl_order[a] * 2 + 1], 3);
            send_tree(i, i.dyn_ltree, r - 1), send_tree(i, i.dyn_dtree, n - 1)
        },
        detect_data_type = i => {
            let r = 4093624447,
                n;
            for (n = 0; n <= 31; n++, r >>>= 1)
                if (r & 1 && i.dyn_ltree[n * 2] !== 0) return Z_BINARY;
            if (i.dyn_ltree[9 * 2] !== 0 || i.dyn_ltree[10 * 2] !== 0 || i.dyn_ltree[13 * 2] !== 0) return Z_TEXT;
            for (n = 32; n < LITERALS$1; n++)
                if (i.dyn_ltree[n * 2] !== 0) return Z_TEXT;
            return Z_BINARY
        };
    let static_init_done = !1;
    const _tr_init$1 = i => {
            static_init_done || (tr_static_init(), static_init_done = !0), i.l_desc = new TreeDesc(i.dyn_ltree, static_l_desc), i.d_desc = new TreeDesc(i.dyn_dtree, static_d_desc), i.bl_desc = new TreeDesc(i.bl_tree, static_bl_desc), i.bi_buf = 0, i.bi_valid = 0, init_block(i)
        },
        _tr_stored_block$1 = (i, r, n, s) => {
            send_bits(i, (STORED_BLOCK << 1) + (s ? 1 : 0), 3), copy_block(i, r, n, !0)
        },
        _tr_align$1 = i => {
            send_bits(i, STATIC_TREES << 1, 3), send_code(i, END_BLOCK, static_ltree), bi_flush(i)
        },
        _tr_flush_block$1 = (i, r, n, s) => {
            let a, o, c = 0;
            i.level > 0 ? (i.strm.data_type === Z_UNKNOWN$1 && (i.strm.data_type = detect_data_type(i)), build_tree(i, i.l_desc), build_tree(i, i.d_desc), c = build_bl_tree(i), a = i.opt_len + 3 + 7 >>> 3, o = i.static_len + 3 + 7 >>> 3, o <= a && (a = o)) : a = o = n + 5, n + 4 <= a && r !== -1 ? _tr_stored_block$1(i, r, n, s) : i.strategy === Z_FIXED$1 || o === a ? (send_bits(i, (STATIC_TREES << 1) + (s ? 1 : 0), 3), compress_block(i, static_ltree, static_dtree)) : (send_bits(i, (DYN_TREES << 1) + (s ? 1 : 0), 3), send_all_trees(i, i.l_desc.max_code + 1, i.d_desc.max_code + 1, c + 1), compress_block(i, i.dyn_ltree, i.dyn_dtree)), init_block(i), s && bi_windup(i)
        },
        _tr_tally$1 = (i, r, n) => (i.pending_buf[i.d_buf + i.last_lit * 2] = r >>> 8 & 255, i.pending_buf[i.d_buf + i.last_lit * 2 + 1] = r & 255, i.pending_buf[i.l_buf + i.last_lit] = n & 255, i.last_lit++, r === 0 ? i.dyn_ltree[n * 2]++ : (i.matches++, r--, i.dyn_ltree[(_length_code[n] + LITERALS$1 + 1) * 2]++, i.dyn_dtree[d_code(r) * 2]++), i.last_lit === i.lit_bufsize - 1);
    var _tr_init_1 = _tr_init$1,
        _tr_stored_block_1 = _tr_stored_block$1,
        _tr_flush_block_1 = _tr_flush_block$1,
        _tr_tally_1 = _tr_tally$1,
        _tr_align_1 = _tr_align$1,
        trees = {
            _tr_init: _tr_init_1,
            _tr_stored_block: _tr_stored_block_1,
            _tr_flush_block: _tr_flush_block_1,
            _tr_tally: _tr_tally_1,
            _tr_align: _tr_align_1
        };
    const adler32 = (i, r, n, s) => {
        let a = i & 65535 | 0,
            o = i >>> 16 & 65535 | 0,
            c = 0;
        for (; n !== 0;) {
            c = n > 2e3 ? 2e3 : n, n -= c;
            do a = a + r[s++] | 0, o = o + a | 0; while (--c);
            a %= 65521, o %= 65521
        }
        return a | o << 16 | 0
    };
    var adler32_1 = adler32;
    const makeTable = () => {
            let i, r = [];
            for (var n = 0; n < 256; n++) {
                i = n;
                for (var s = 0; s < 8; s++) i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
                r[n] = i
            }
            return r
        },
        crcTable = new Uint32Array(makeTable()),
        crc32 = (i, r, n, s) => {
            const a = crcTable,
                o = s + n;
            i ^= -1;
            for (let c = s; c < o; c++) i = i >>> 8 ^ a[(i ^ r[c]) & 255];
            return i ^ -1
        };
    var crc32_1 = crc32,
        messages = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        },
        constants$2 = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
    const {
        _tr_init,
        _tr_stored_block,
        _tr_flush_block,
        _tr_tally,
        _tr_align
    } = trees, {
        Z_NO_FLUSH: Z_NO_FLUSH$2,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH: Z_FULL_FLUSH$1,
        Z_FINISH: Z_FINISH$3,
        Z_BLOCK: Z_BLOCK$1,
        Z_OK: Z_OK$3,
        Z_STREAM_END: Z_STREAM_END$3,
        Z_STREAM_ERROR: Z_STREAM_ERROR$2,
        Z_DATA_ERROR: Z_DATA_ERROR$2,
        Z_BUF_ERROR: Z_BUF_ERROR$1,
        Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
        Z_UNKNOWN,
        Z_DEFLATED: Z_DEFLATED$2
    } = constants$2, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (i, r) => (i.msg = messages[r], r), rank = i => (i << 1) - (i > 4 ? 9 : 0), zero = i => {
        let r = i.length;
        for (; --r >= 0;) i[r] = 0
    };
    let HASH_ZLIB = (i, r, n) => (r << i.hash_shift ^ n) & i.hash_mask,
        HASH = HASH_ZLIB;
    const flush_pending = i => {
            const r = i.state;
            let n = r.pending;
            n > i.avail_out && (n = i.avail_out), n !== 0 && (i.output.set(r.pending_buf.subarray(r.pending_out, r.pending_out + n), i.next_out), i.next_out += n, r.pending_out += n, i.total_out += n, i.avail_out -= n, r.pending -= n, r.pending === 0 && (r.pending_out = 0))
        },
        flush_block_only = (i, r) => {
            _tr_flush_block(i, i.block_start >= 0 ? i.block_start : -1, i.strstart - i.block_start, r), i.block_start = i.strstart, flush_pending(i.strm)
        },
        put_byte = (i, r) => {
            i.pending_buf[i.pending++] = r
        },
        putShortMSB = (i, r) => {
            i.pending_buf[i.pending++] = r >>> 8 & 255, i.pending_buf[i.pending++] = r & 255
        },
        read_buf = (i, r, n, s) => {
            let a = i.avail_in;
            return a > s && (a = s), a === 0 ? 0 : (i.avail_in -= a, r.set(i.input.subarray(i.next_in, i.next_in + a), n), i.state.wrap === 1 ? i.adler = adler32_1(i.adler, r, a, n) : i.state.wrap === 2 && (i.adler = crc32_1(i.adler, r, a, n)), i.next_in += a, i.total_in += a, a)
        },
        longest_match = (i, r) => {
            let n = i.max_chain_length,
                s = i.strstart,
                a, o, c = i.prev_length,
                p = i.nice_match;
            const h = i.strstart > i.w_size - MIN_LOOKAHEAD ? i.strstart - (i.w_size - MIN_LOOKAHEAD) : 0,
                u = i.window,
                l = i.w_mask,
                v = i.prev,
                w = i.strstart + MAX_MATCH;
            let m = u[s + c - 1],
                S = u[s + c];
            i.prev_length >= i.good_match && (n >>= 2), p > i.lookahead && (p = i.lookahead);
            do
                if (a = r, !(u[a + c] !== S || u[a + c - 1] !== m || u[a] !== u[s] || u[++a] !== u[s + 1])) {
                    s += 2, a++;
                    do; while (u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && u[++s] === u[++a] && s < w);
                    if (o = MAX_MATCH - (w - s), s = w - MAX_MATCH, o > c) {
                        if (i.match_start = r, c = o, o >= p) break;
                        m = u[s + c - 1], S = u[s + c]
                    }
                } while ((r = v[r & l]) > h && --n !== 0);
            return c <= i.lookahead ? c : i.lookahead
        },
        fill_window = i => {
            const r = i.w_size;
            let n, s, a, o, c;
            do {
                if (o = i.window_size - i.lookahead - i.strstart, i.strstart >= r + (r - MIN_LOOKAHEAD)) {
                    i.window.set(i.window.subarray(r, r + r), 0), i.match_start -= r, i.strstart -= r, i.block_start -= r, s = i.hash_size, n = s;
                    do a = i.head[--n], i.head[n] = a >= r ? a - r : 0; while (--s);
                    s = r, n = s;
                    do a = i.prev[--n], i.prev[n] = a >= r ? a - r : 0; while (--s);
                    o += r
                }
                if (i.strm.avail_in === 0) break;
                if (s = read_buf(i.strm, i.window, i.strstart + i.lookahead, o), i.lookahead += s, i.lookahead + i.insert >= MIN_MATCH)
                    for (c = i.strstart - i.insert, i.ins_h = i.window[c], i.ins_h = HASH(i, i.ins_h, i.window[c + 1]); i.insert && (i.ins_h = HASH(i, i.ins_h, i.window[c + MIN_MATCH - 1]), i.prev[c & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = c, c++, i.insert--, !(i.lookahead + i.insert < MIN_MATCH)););
            } while (i.lookahead < MIN_LOOKAHEAD && i.strm.avail_in !== 0)
        },
        deflate_stored = (i, r) => {
            let n = 65535;
            for (n > i.pending_buf_size - 5 && (n = i.pending_buf_size - 5);;) {
                if (i.lookahead <= 1) {
                    if (fill_window(i), i.lookahead === 0 && r === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (i.lookahead === 0) break
                }
                i.strstart += i.lookahead, i.lookahead = 0;
                const s = i.block_start + n;
                if ((i.strstart === 0 || i.strstart >= s) && (i.lookahead = i.strstart - s, i.strstart = s, flush_block_only(i, !1), i.strm.avail_out === 0) || i.strstart - i.block_start >= i.w_size - MIN_LOOKAHEAD && (flush_block_only(i, !1), i.strm.avail_out === 0)) return BS_NEED_MORE
            }
            return i.insert = 0, r === Z_FINISH$3 ? (flush_block_only(i, !0), i.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : (i.strstart > i.block_start && (flush_block_only(i, !1), i.strm.avail_out === 0), BS_NEED_MORE)
        },
        deflate_fast = (i, r) => {
            let n, s;
            for (;;) {
                if (i.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(i), i.lookahead < MIN_LOOKAHEAD && r === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (i.lookahead === 0) break
                }
                if (n = 0, i.lookahead >= MIN_MATCH && (i.ins_h = HASH(i, i.ins_h, i.window[i.strstart + MIN_MATCH - 1]), n = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart), n !== 0 && i.strstart - n <= i.w_size - MIN_LOOKAHEAD && (i.match_length = longest_match(i, n)), i.match_length >= MIN_MATCH)
                    if (s = _tr_tally(i, i.strstart - i.match_start, i.match_length - MIN_MATCH), i.lookahead -= i.match_length, i.match_length <= i.max_lazy_match && i.lookahead >= MIN_MATCH) {
                        i.match_length--;
                        do i.strstart++, i.ins_h = HASH(i, i.ins_h, i.window[i.strstart + MIN_MATCH - 1]), n = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart; while (--i.match_length !== 0);
                        i.strstart++
                    } else i.strstart += i.match_length, i.match_length = 0, i.ins_h = i.window[i.strstart], i.ins_h = HASH(i, i.ins_h, i.window[i.strstart + 1]);
                else s = _tr_tally(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++;
                if (s && (flush_block_only(i, !1), i.strm.avail_out === 0)) return BS_NEED_MORE
            }
            return i.insert = i.strstart < MIN_MATCH - 1 ? i.strstart : MIN_MATCH - 1, r === Z_FINISH$3 ? (flush_block_only(i, !0), i.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : i.last_lit && (flush_block_only(i, !1), i.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_slow = (i, r) => {
            let n, s, a;
            for (;;) {
                if (i.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(i), i.lookahead < MIN_LOOKAHEAD && r === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (i.lookahead === 0) break
                }
                if (n = 0, i.lookahead >= MIN_MATCH && (i.ins_h = HASH(i, i.ins_h, i.window[i.strstart + MIN_MATCH - 1]), n = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart), i.prev_length = i.match_length, i.prev_match = i.match_start, i.match_length = MIN_MATCH - 1, n !== 0 && i.prev_length < i.max_lazy_match && i.strstart - n <= i.w_size - MIN_LOOKAHEAD && (i.match_length = longest_match(i, n), i.match_length <= 5 && (i.strategy === Z_FILTERED || i.match_length === MIN_MATCH && i.strstart - i.match_start > 4096) && (i.match_length = MIN_MATCH - 1)), i.prev_length >= MIN_MATCH && i.match_length <= i.prev_length) {
                    a = i.strstart + i.lookahead - MIN_MATCH, s = _tr_tally(i, i.strstart - 1 - i.prev_match, i.prev_length - MIN_MATCH), i.lookahead -= i.prev_length - 1, i.prev_length -= 2;
                    do ++i.strstart <= a && (i.ins_h = HASH(i, i.ins_h, i.window[i.strstart + MIN_MATCH - 1]), n = i.prev[i.strstart & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = i.strstart); while (--i.prev_length !== 0);
                    if (i.match_available = 0, i.match_length = MIN_MATCH - 1, i.strstart++, s && (flush_block_only(i, !1), i.strm.avail_out === 0)) return BS_NEED_MORE
                } else if (i.match_available) {
                    if (s = _tr_tally(i, 0, i.window[i.strstart - 1]), s && flush_block_only(i, !1), i.strstart++, i.lookahead--, i.strm.avail_out === 0) return BS_NEED_MORE
                } else i.match_available = 1, i.strstart++, i.lookahead--
            }
            return i.match_available && (s = _tr_tally(i, 0, i.window[i.strstart - 1]), i.match_available = 0), i.insert = i.strstart < MIN_MATCH - 1 ? i.strstart : MIN_MATCH - 1, r === Z_FINISH$3 ? (flush_block_only(i, !0), i.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : i.last_lit && (flush_block_only(i, !1), i.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_rle = (i, r) => {
            let n, s, a, o;
            const c = i.window;
            for (;;) {
                if (i.lookahead <= MAX_MATCH) {
                    if (fill_window(i), i.lookahead <= MAX_MATCH && r === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    if (i.lookahead === 0) break
                }
                if (i.match_length = 0, i.lookahead >= MIN_MATCH && i.strstart > 0 && (a = i.strstart - 1, s = c[a], s === c[++a] && s === c[++a] && s === c[++a])) {
                    o = i.strstart + MAX_MATCH;
                    do; while (s === c[++a] && s === c[++a] && s === c[++a] && s === c[++a] && s === c[++a] && s === c[++a] && s === c[++a] && s === c[++a] && a < o);
                    i.match_length = MAX_MATCH - (o - a), i.match_length > i.lookahead && (i.match_length = i.lookahead)
                }
                if (i.match_length >= MIN_MATCH ? (n = _tr_tally(i, 1, i.match_length - MIN_MATCH), i.lookahead -= i.match_length, i.strstart += i.match_length, i.match_length = 0) : (n = _tr_tally(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++), n && (flush_block_only(i, !1), i.strm.avail_out === 0)) return BS_NEED_MORE
            }
            return i.insert = 0, r === Z_FINISH$3 ? (flush_block_only(i, !0), i.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : i.last_lit && (flush_block_only(i, !1), i.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
        },
        deflate_huff = (i, r) => {
            let n;
            for (;;) {
                if (i.lookahead === 0 && (fill_window(i), i.lookahead === 0)) {
                    if (r === Z_NO_FLUSH$2) return BS_NEED_MORE;
                    break
                }
                if (i.match_length = 0, n = _tr_tally(i, 0, i.window[i.strstart]), i.lookahead--, i.strstart++, n && (flush_block_only(i, !1), i.strm.avail_out === 0)) return BS_NEED_MORE
            }
            return i.insert = 0, r === Z_FINISH$3 ? (flush_block_only(i, !0), i.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : i.last_lit && (flush_block_only(i, !1), i.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE
        };

    function Config(i, r, n, s, a) {
        this.good_length = i, this.max_lazy = r, this.nice_length = n, this.max_chain = s, this.func = a
    }
    const configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)],
        lm_init = i => {
            i.window_size = 2 * i.w_size, zero(i.head), i.max_lazy_match = configuration_table[i.level].max_lazy, i.good_match = configuration_table[i.level].good_length, i.nice_match = configuration_table[i.level].nice_length, i.max_chain_length = configuration_table[i.level].max_chain, i.strstart = 0, i.block_start = 0, i.lookahead = 0, i.insert = 0, i.match_length = i.prev_length = MIN_MATCH - 1, i.match_available = 0, i.ins_h = 0
        };

    function DeflateState() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2), this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2), this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
    }
    const deflateResetKeep = i => {
            if (!i || !i.state) return err(i, Z_STREAM_ERROR$2);
            i.total_in = i.total_out = 0, i.data_type = Z_UNKNOWN;
            const r = i.state;
            return r.pending = 0, r.pending_out = 0, r.wrap < 0 && (r.wrap = -r.wrap), r.status = r.wrap ? INIT_STATE : BUSY_STATE, i.adler = r.wrap === 2 ? 0 : 1, r.last_flush = Z_NO_FLUSH$2, _tr_init(r), Z_OK$3
        },
        deflateReset = i => {
            const r = deflateResetKeep(i);
            return r === Z_OK$3 && lm_init(i.state), r
        },
        deflateSetHeader = (i, r) => !i || !i.state || i.state.wrap !== 2 ? Z_STREAM_ERROR$2 : (i.state.gzhead = r, Z_OK$3),
        deflateInit2 = (i, r, n, s, a, o) => {
            if (!i) return Z_STREAM_ERROR$2;
            let c = 1;
            if (r === Z_DEFAULT_COMPRESSION$1 && (r = 6), s < 0 ? (c = 0, s = -s) : s > 15 && (c = 2, s -= 16), a < 1 || a > MAX_MEM_LEVEL || n !== Z_DEFLATED$2 || s < 8 || s > 15 || r < 0 || r > 9 || o < 0 || o > Z_FIXED) return err(i, Z_STREAM_ERROR$2);
            s === 8 && (s = 9);
            const p = new DeflateState;
            return i.state = p, p.strm = i, p.wrap = c, p.gzhead = null, p.w_bits = s, p.w_size = 1 << p.w_bits, p.w_mask = p.w_size - 1, p.hash_bits = a + 7, p.hash_size = 1 << p.hash_bits, p.hash_mask = p.hash_size - 1, p.hash_shift = ~~((p.hash_bits + MIN_MATCH - 1) / MIN_MATCH), p.window = new Uint8Array(p.w_size * 2), p.head = new Uint16Array(p.hash_size), p.prev = new Uint16Array(p.w_size), p.lit_bufsize = 1 << a + 6, p.pending_buf_size = p.lit_bufsize * 4, p.pending_buf = new Uint8Array(p.pending_buf_size), p.d_buf = 1 * p.lit_bufsize, p.l_buf = (1 + 2) * p.lit_bufsize, p.level = r, p.strategy = o, p.method = n, deflateReset(i)
        },
        deflateInit = (i, r) => deflateInit2(i, r, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1),
        deflate$2 = (i, r) => {
            let n, s;
            if (!i || !i.state || r > Z_BLOCK$1 || r < 0) return i ? err(i, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
            const a = i.state;
            if (!i.output || !i.input && i.avail_in !== 0 || a.status === FINISH_STATE && r !== Z_FINISH$3) return err(i, i.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
            a.strm = i;
            const o = a.last_flush;
            if (a.last_flush = r, a.status === INIT_STATE)
                if (a.wrap === 2) i.adler = 0, put_byte(a, 31), put_byte(a, 139), put_byte(a, 8), a.gzhead ? (put_byte(a, (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)), put_byte(a, a.gzhead.time & 255), put_byte(a, a.gzhead.time >> 8 & 255), put_byte(a, a.gzhead.time >> 16 & 255), put_byte(a, a.gzhead.time >> 24 & 255), put_byte(a, a.level === 9 ? 2 : a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? 4 : 0), put_byte(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (put_byte(a, a.gzhead.extra.length & 255), put_byte(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = EXTRA_STATE) : (put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, 0), put_byte(a, a.level === 9 ? 2 : a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? 4 : 0), put_byte(a, OS_CODE), a.status = BUSY_STATE);
                else {
                    let c = Z_DEFLATED$2 + (a.w_bits - 8 << 4) << 8,
                        p = -1;
                    a.strategy >= Z_HUFFMAN_ONLY || a.level < 2 ? p = 0 : a.level < 6 ? p = 1 : a.level === 6 ? p = 2 : p = 3, c |= p << 6, a.strstart !== 0 && (c |= PRESET_DICT), c += 31 - c % 31, a.status = BUSY_STATE, putShortMSB(a, c), a.strstart !== 0 && (putShortMSB(a, i.adler >>> 16), putShortMSB(a, i.adler & 65535)), i.adler = 1
                } if (a.status === EXTRA_STATE)
                if (a.gzhead.extra) {
                    for (n = a.pending; a.gzindex < (a.gzhead.extra.length & 65535) && !(a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), flush_pending(i), n = a.pending, a.pending === a.pending_buf_size));) put_byte(a, a.gzhead.extra[a.gzindex] & 255), a.gzindex++;
                    a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), a.gzindex === a.gzhead.extra.length && (a.gzindex = 0, a.status = NAME_STATE)
                } else a.status = NAME_STATE;
            if (a.status === NAME_STATE)
                if (a.gzhead.name) {
                    n = a.pending;
                    do {
                        if (a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), flush_pending(i), n = a.pending, a.pending === a.pending_buf_size)) {
                            s = 1;
                            break
                        }
                        a.gzindex < a.gzhead.name.length ? s = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : s = 0, put_byte(a, s)
                    } while (s !== 0);
                    a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), s === 0 && (a.gzindex = 0, a.status = COMMENT_STATE)
                } else a.status = COMMENT_STATE;
            if (a.status === COMMENT_STATE)
                if (a.gzhead.comment) {
                    n = a.pending;
                    do {
                        if (a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), flush_pending(i), n = a.pending, a.pending === a.pending_buf_size)) {
                            s = 1;
                            break
                        }
                        a.gzindex < a.gzhead.comment.length ? s = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : s = 0, put_byte(a, s)
                    } while (s !== 0);
                    a.gzhead.hcrc && a.pending > n && (i.adler = crc32_1(i.adler, a.pending_buf, a.pending - n, n)), s === 0 && (a.status = HCRC_STATE)
                } else a.status = HCRC_STATE;
            if (a.status === HCRC_STATE && (a.gzhead.hcrc ? (a.pending + 2 > a.pending_buf_size && flush_pending(i), a.pending + 2 <= a.pending_buf_size && (put_byte(a, i.adler & 255), put_byte(a, i.adler >> 8 & 255), i.adler = 0, a.status = BUSY_STATE)) : a.status = BUSY_STATE), a.pending !== 0) {
                if (flush_pending(i), i.avail_out === 0) return a.last_flush = -1, Z_OK$3
            } else if (i.avail_in === 0 && rank(r) <= rank(o) && r !== Z_FINISH$3) return err(i, Z_BUF_ERROR$1);
            if (a.status === FINISH_STATE && i.avail_in !== 0) return err(i, Z_BUF_ERROR$1);
            if (i.avail_in !== 0 || a.lookahead !== 0 || r !== Z_NO_FLUSH$2 && a.status !== FINISH_STATE) {
                let c = a.strategy === Z_HUFFMAN_ONLY ? deflate_huff(a, r) : a.strategy === Z_RLE ? deflate_rle(a, r) : configuration_table[a.level].func(a, r);
                if ((c === BS_FINISH_STARTED || c === BS_FINISH_DONE) && (a.status = FINISH_STATE), c === BS_NEED_MORE || c === BS_FINISH_STARTED) return i.avail_out === 0 && (a.last_flush = -1), Z_OK$3;
                if (c === BS_BLOCK_DONE && (r === Z_PARTIAL_FLUSH ? _tr_align(a) : r !== Z_BLOCK$1 && (_tr_stored_block(a, 0, 0, !1), r === Z_FULL_FLUSH$1 && (zero(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), flush_pending(i), i.avail_out === 0)) return a.last_flush = -1, Z_OK$3
            }
            return r !== Z_FINISH$3 ? Z_OK$3 : a.wrap <= 0 ? Z_STREAM_END$3 : (a.wrap === 2 ? (put_byte(a, i.adler & 255), put_byte(a, i.adler >> 8 & 255), put_byte(a, i.adler >> 16 & 255), put_byte(a, i.adler >> 24 & 255), put_byte(a, i.total_in & 255), put_byte(a, i.total_in >> 8 & 255), put_byte(a, i.total_in >> 16 & 255), put_byte(a, i.total_in >> 24 & 255)) : (putShortMSB(a, i.adler >>> 16), putShortMSB(a, i.adler & 65535)), flush_pending(i), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3)
        },
        deflateEnd = i => {
            if (!i || !i.state) return Z_STREAM_ERROR$2;
            const r = i.state.status;
            return r !== INIT_STATE && r !== EXTRA_STATE && r !== NAME_STATE && r !== COMMENT_STATE && r !== HCRC_STATE && r !== BUSY_STATE && r !== FINISH_STATE ? err(i, Z_STREAM_ERROR$2) : (i.state = null, r === BUSY_STATE ? err(i, Z_DATA_ERROR$2) : Z_OK$3)
        },
        deflateSetDictionary = (i, r) => {
            let n = r.length;
            if (!i || !i.state) return Z_STREAM_ERROR$2;
            const s = i.state,
                a = s.wrap;
            if (a === 2 || a === 1 && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR$2;
            if (a === 1 && (i.adler = adler32_1(i.adler, r, n, 0)), s.wrap = 0, n >= s.w_size) {
                a === 0 && (zero(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0);
                let h = new Uint8Array(s.w_size);
                h.set(r.subarray(n - s.w_size, n), 0), r = h, n = s.w_size
            }
            const o = i.avail_in,
                c = i.next_in,
                p = i.input;
            for (i.avail_in = n, i.next_in = 0, i.input = r, fill_window(s); s.lookahead >= MIN_MATCH;) {
                let h = s.strstart,
                    u = s.lookahead - (MIN_MATCH - 1);
                do s.ins_h = HASH(s, s.ins_h, s.window[h + MIN_MATCH - 1]), s.prev[h & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = h, h++; while (--u);
                s.strstart = h, s.lookahead = MIN_MATCH - 1, fill_window(s)
            }
            return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, i.next_in = c, i.input = p, i.avail_in = o, s.wrap = a, Z_OK$3
        };
    var deflateInit_1 = deflateInit,
        deflateInit2_1 = deflateInit2,
        deflateReset_1 = deflateReset,
        deflateResetKeep_1 = deflateResetKeep,
        deflateSetHeader_1 = deflateSetHeader,
        deflate_2$1 = deflate$2,
        deflateEnd_1 = deflateEnd,
        deflateSetDictionary_1 = deflateSetDictionary,
        deflateInfo = "pako deflate (from Nodeca project)",
        deflate_1$2 = {
            deflateInit: deflateInit_1,
            deflateInit2: deflateInit2_1,
            deflateReset: deflateReset_1,
            deflateResetKeep: deflateResetKeep_1,
            deflateSetHeader: deflateSetHeader_1,
            deflate: deflate_2$1,
            deflateEnd: deflateEnd_1,
            deflateSetDictionary: deflateSetDictionary_1,
            deflateInfo
        };
    const _has = (i, r) => Object.prototype.hasOwnProperty.call(i, r);
    var assign = function(i) {
            const r = Array.prototype.slice.call(arguments, 1);
            for (; r.length;) {
                const n = r.shift();
                if (!!n) {
                    if (typeof n != "object") throw new TypeError(n + "must be non-object");
                    for (const s in n) _has(n, s) && (i[s] = n[s])
                }
            }
            return i
        },
        flattenChunks = i => {
            let r = 0;
            for (let s = 0, a = i.length; s < a; s++) r += i[s].length;
            const n = new Uint8Array(r);
            for (let s = 0, a = 0, o = i.length; s < o; s++) {
                let c = i[s];
                n.set(c, a), a += c.length
            }
            return n
        },
        common = {
            assign,
            flattenChunks
        };
    let STR_APPLY_UIA_OK = !0;
    try {
        String.fromCharCode.apply(null, new Uint8Array(1))
    } catch (i) {
        STR_APPLY_UIA_OK = !1
    }
    const _utf8len = new Uint8Array(256);
    for (let i = 0; i < 256; i++) _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = i => {
        if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(i);
        let r, n, s, a, o, c = i.length,
            p = 0;
        for (a = 0; a < c; a++) n = i.charCodeAt(a), (n & 64512) === 55296 && a + 1 < c && (s = i.charCodeAt(a + 1), (s & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (s - 56320), a++)), p += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
        for (r = new Uint8Array(p), o = 0, a = 0; o < p; a++) n = i.charCodeAt(a), (n & 64512) === 55296 && a + 1 < c && (s = i.charCodeAt(a + 1), (s & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (s - 56320), a++)), n < 128 ? r[o++] = n : n < 2048 ? (r[o++] = 192 | n >>> 6, r[o++] = 128 | n & 63) : n < 65536 ? (r[o++] = 224 | n >>> 12, r[o++] = 128 | n >>> 6 & 63, r[o++] = 128 | n & 63) : (r[o++] = 240 | n >>> 18, r[o++] = 128 | n >>> 12 & 63, r[o++] = 128 | n >>> 6 & 63, r[o++] = 128 | n & 63);
        return r
    };
    const buf2binstring = (i, r) => {
        if (r < 65534 && i.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, i.length === r ? i : i.subarray(0, r));
        let n = "";
        for (let s = 0; s < r; s++) n += String.fromCharCode(i[s]);
        return n
    };
    var buf2string = (i, r) => {
            const n = r || i.length;
            if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(i.subarray(0, r));
            let s, a;
            const o = new Array(n * 2);
            for (a = 0, s = 0; s < n;) {
                let c = i[s++];
                if (c < 128) {
                    o[a++] = c;
                    continue
                }
                let p = _utf8len[c];
                if (p > 4) {
                    o[a++] = 65533, s += p - 1;
                    continue
                }
                for (c &= p === 2 ? 31 : p === 3 ? 15 : 7; p > 1 && s < n;) c = c << 6 | i[s++] & 63, p--;
                if (p > 1) {
                    o[a++] = 65533;
                    continue
                }
                c < 65536 ? o[a++] = c : (c -= 65536, o[a++] = 55296 | c >> 10 & 1023, o[a++] = 56320 | c & 1023)
            }
            return buf2binstring(o, a)
        },
        utf8border = (i, r) => {
            r = r || i.length, r > i.length && (r = i.length);
            let n = r - 1;
            for (; n >= 0 && (i[n] & 192) === 128;) n--;
            return n < 0 || n === 0 ? r : n + _utf8len[i[n]] > r ? n : r
        },
        strings = {
            string2buf,
            buf2string,
            utf8border
        };

    function ZStream() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
    }
    var zstream = ZStream;
    const toString$1 = Object.prototype.toString,
        {
            Z_NO_FLUSH: Z_NO_FLUSH$1,
            Z_SYNC_FLUSH,
            Z_FULL_FLUSH,
            Z_FINISH: Z_FINISH$2,
            Z_OK: Z_OK$2,
            Z_STREAM_END: Z_STREAM_END$2,
            Z_DEFAULT_COMPRESSION,
            Z_DEFAULT_STRATEGY,
            Z_DEFLATED: Z_DEFLATED$1
        } = constants$2;

    function Deflate$1(i) {
        this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, i || {});
        let r = this.options;
        r.raw && r.windowBits > 0 ? r.windowBits = -r.windowBits : r.gzip && r.windowBits > 0 && r.windowBits < 16 && (r.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
        let n = deflate_1$2.deflateInit2(this.strm, r.level, r.method, r.windowBits, r.memLevel, r.strategy);
        if (n !== Z_OK$2) throw new Error(messages[n]);
        if (r.header && deflate_1$2.deflateSetHeader(this.strm, r.header), r.dictionary) {
            let s;
            if (typeof r.dictionary == "string" ? s = strings.string2buf(r.dictionary) : toString$1.call(r.dictionary) === "[object ArrayBuffer]" ? s = new Uint8Array(r.dictionary) : s = r.dictionary, n = deflate_1$2.deflateSetDictionary(this.strm, s), n !== Z_OK$2) throw new Error(messages[n]);
            this._dict_set = !0
        }
    }
    Deflate$1.prototype.push = function(i, r) {
        const n = this.strm,
            s = this.options.chunkSize;
        let a, o;
        if (this.ended) return !1;
        for (r === ~~r ? o = r : o = r === !0 ? Z_FINISH$2 : Z_NO_FLUSH$1, typeof i == "string" ? n.input = strings.string2buf(i) : toString$1.call(i) === "[object ArrayBuffer]" ? n.input = new Uint8Array(i) : n.input = i, n.next_in = 0, n.avail_in = n.input.length;;) {
            if (n.avail_out === 0 && (n.output = new Uint8Array(s), n.next_out = 0, n.avail_out = s), (o === Z_SYNC_FLUSH || o === Z_FULL_FLUSH) && n.avail_out <= 6) {
                this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                continue
            }
            if (a = deflate_1$2.deflate(n, o), a === Z_STREAM_END$2) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), a = deflate_1$2.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === Z_OK$2;
            if (n.avail_out === 0) {
                this.onData(n.output);
                continue
            }
            if (o > 0 && n.next_out > 0) {
                this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                continue
            }
            if (n.avail_in === 0) break
        }
        return !0
    }, Deflate$1.prototype.onData = function(i) {
        this.chunks.push(i)
    }, Deflate$1.prototype.onEnd = function(i) {
        i === Z_OK$2 && (this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = i, this.msg = this.strm.msg
    };
    const BAD$1 = 30,
        TYPE$1 = 12;
    var inffast = function i(r, n) {
        let s, a, o, c, p, h, u, l, v, w, m, S, C, O, x, I, B, b, f, d, g, E, T, N;
        const P = r.state;
        s = r.next_in, T = r.input, a = s + (r.avail_in - 5), o = r.next_out, N = r.output, c = o - (n - r.avail_out), p = o + (r.avail_out - 257), h = P.dmax, u = P.wsize, l = P.whave, v = P.wnext, w = P.window, m = P.hold, S = P.bits, C = P.lencode, O = P.distcode, x = (1 << P.lenbits) - 1, I = (1 << P.distbits) - 1;
        e: do {
            S < 15 && (m += T[s++] << S, S += 8, m += T[s++] << S, S += 8), B = C[m & x];
            t: for (;;) {
                if (b = B >>> 24, m >>>= b, S -= b, b = B >>> 16 & 255, b === 0) N[o++] = B & 65535;
                else if (b & 16) {
                    f = B & 65535, b &= 15, b && (S < b && (m += T[s++] << S, S += 8), f += m & (1 << b) - 1, m >>>= b, S -= b), S < 15 && (m += T[s++] << S, S += 8, m += T[s++] << S, S += 8), B = O[m & I];
                    r: for (;;) {
                        if (b = B >>> 24, m >>>= b, S -= b, b = B >>> 16 & 255, b & 16) {
                            if (d = B & 65535, b &= 15, S < b && (m += T[s++] << S, S += 8, S < b && (m += T[s++] << S, S += 8)), d += m & (1 << b) - 1, d > h) {
                                r.msg = "invalid distance too far back", P.mode = BAD$1;
                                break e
                            }
                            if (m >>>= b, S -= b, b = o - c, d > b) {
                                if (b = d - b, b > l && P.sane) {
                                    r.msg = "invalid distance too far back", P.mode = BAD$1;
                                    break e
                                }
                                if (g = 0, E = w, v === 0) {
                                    if (g += u - b, b < f) {
                                        f -= b;
                                        do N[o++] = w[g++]; while (--b);
                                        g = o - d, E = N
                                    }
                                } else if (v < b) {
                                    if (g += u + v - b, b -= v, b < f) {
                                        f -= b;
                                        do N[o++] = w[g++]; while (--b);
                                        if (g = 0, v < f) {
                                            b = v, f -= b;
                                            do N[o++] = w[g++]; while (--b);
                                            g = o - d, E = N
                                        }
                                    }
                                } else if (g += v - b, b < f) {
                                    f -= b;
                                    do N[o++] = w[g++]; while (--b);
                                    g = o - d, E = N
                                }
                                for (; f > 2;) N[o++] = E[g++], N[o++] = E[g++], N[o++] = E[g++], f -= 3;
                                f && (N[o++] = E[g++], f > 1 && (N[o++] = E[g++]))
                            } else {
                                g = o - d;
                                do N[o++] = N[g++], N[o++] = N[g++], N[o++] = N[g++], f -= 3; while (f > 2);
                                f && (N[o++] = N[g++], f > 1 && (N[o++] = N[g++]))
                            }
                        } else if ((b & 64) === 0) {
                            B = O[(B & 65535) + (m & (1 << b) - 1)];
                            continue r
                        } else {
                            r.msg = "invalid distance code", P.mode = BAD$1;
                            break e
                        }
                        break
                    }
                } else if ((b & 64) === 0) {
                    B = C[(B & 65535) + (m & (1 << b) - 1)];
                    continue t
                } else if (b & 32) {
                    P.mode = TYPE$1;
                    break e
                } else {
                    r.msg = "invalid literal/length code", P.mode = BAD$1;
                    break e
                }
                break
            }
        } while (s < a && o < p);
        f = S >> 3, s -= f, S -= f << 3, m &= (1 << S) - 1, r.next_in = s, r.next_out = o, r.avail_in = s < a ? 5 + (a - s) : 5 - (s - a), r.avail_out = o < p ? 257 + (p - o) : 257 - (o - p), P.hold = m, P.bits = S
    };
    const MAXBITS = 15,
        ENOUGH_LENS$1 = 852,
        ENOUGH_DISTS$1 = 592,
        CODES$1 = 0,
        LENS$1 = 1,
        DISTS$1 = 2,
        lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
        lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
        dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
        dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
        inflate_table = (i, r, n, s, a, o, c, p) => {
            const h = p.bits;
            let u = 0,
                l = 0,
                v = 0,
                w = 0,
                m = 0,
                S = 0,
                C = 0,
                O = 0,
                x = 0,
                I = 0,
                B, b, f, d, g, E = null,
                T = 0,
                N;
            const P = new Uint16Array(MAXBITS + 1),
                U = new Uint16Array(MAXBITS + 1);
            let F = null,
                L = 0,
                G, M, _;
            for (u = 0; u <= MAXBITS; u++) P[u] = 0;
            for (l = 0; l < s; l++) P[r[n + l]]++;
            for (m = h, w = MAXBITS; w >= 1 && P[w] === 0; w--);
            if (m > w && (m = w), w === 0) return a[o++] = 1 << 24 | 64 << 16 | 0, a[o++] = 1 << 24 | 64 << 16 | 0, p.bits = 1, 0;
            for (v = 1; v < w && P[v] === 0; v++);
            for (m < v && (m = v), O = 1, u = 1; u <= MAXBITS; u++)
                if (O <<= 1, O -= P[u], O < 0) return -1;
            if (O > 0 && (i === CODES$1 || w !== 1)) return -1;
            for (U[1] = 0, u = 1; u < MAXBITS; u++) U[u + 1] = U[u] + P[u];
            for (l = 0; l < s; l++) r[n + l] !== 0 && (c[U[r[n + l]]++] = l);
            if (i === CODES$1 ? (E = F = c, N = 19) : i === LENS$1 ? (E = lbase, T -= 257, F = lext, L -= 257, N = 256) : (E = dbase, F = dext, N = -1), I = 0, l = 0, u = v, g = o, S = m, C = 0, f = -1, x = 1 << m, d = x - 1, i === LENS$1 && x > ENOUGH_LENS$1 || i === DISTS$1 && x > ENOUGH_DISTS$1) return 1;
            for (;;) {
                G = u - C, c[l] < N ? (M = 0, _ = c[l]) : c[l] > N ? (M = F[L + c[l]], _ = E[T + c[l]]) : (M = 32 + 64, _ = 0), B = 1 << u - C, b = 1 << S, v = b;
                do b -= B, a[g + (I >> C) + b] = G << 24 | M << 16 | _ | 0; while (b !== 0);
                for (B = 1 << u - 1; I & B;) B >>= 1;
                if (B !== 0 ? (I &= B - 1, I += B) : I = 0, l++, --P[u] === 0) {
                    if (u === w) break;
                    u = r[n + c[l]]
                }
                if (u > m && (I & d) !== f) {
                    for (C === 0 && (C = m), g += v, S = u - C, O = 1 << S; S + C < w && (O -= P[S + C], !(O <= 0));) S++, O <<= 1;
                    if (x += 1 << S, i === LENS$1 && x > ENOUGH_LENS$1 || i === DISTS$1 && x > ENOUGH_DISTS$1) return 1;
                    f = I & d, a[f] = m << 24 | S << 16 | g - o | 0
                }
            }
            return I !== 0 && (a[g + I] = u - C << 24 | 64 << 16 | 0), p.bits = m, 0
        };
    var inftrees = inflate_table;
    const CODES = 0,
        LENS = 1,
        DISTS = 2,
        {
            Z_FINISH: Z_FINISH$1,
            Z_BLOCK,
            Z_TREES,
            Z_OK: Z_OK$1,
            Z_STREAM_END: Z_STREAM_END$1,
            Z_NEED_DICT: Z_NEED_DICT$1,
            Z_STREAM_ERROR: Z_STREAM_ERROR$1,
            Z_DATA_ERROR: Z_DATA_ERROR$1,
            Z_MEM_ERROR: Z_MEM_ERROR$1,
            Z_BUF_ERROR,
            Z_DEFLATED
        } = constants$2,
        HEAD = 1,
        FLAGS = 2,
        TIME = 3,
        OS = 4,
        EXLEN = 5,
        EXTRA = 6,
        NAME = 7,
        COMMENT = 8,
        HCRC = 9,
        DICTID = 10,
        DICT = 11,
        TYPE = 12,
        TYPEDO = 13,
        STORED = 14,
        COPY_ = 15,
        COPY = 16,
        TABLE = 17,
        LENLENS = 18,
        CODELENS = 19,
        LEN_ = 20,
        LEN = 21,
        LENEXT = 22,
        DIST = 23,
        DISTEXT = 24,
        MATCH = 25,
        LIT = 26,
        CHECK = 27,
        LENGTH$1 = 28,
        DONE = 29,
        BAD = 30,
        MEM = 31,
        SYNC = 32,
        ENOUGH_LENS = 852,
        ENOUGH_DISTS = 592,
        MAX_WBITS = 15,
        DEF_WBITS = MAX_WBITS,
        zswap32 = i => (i >>> 24 & 255) + (i >>> 8 & 65280) + ((i & 65280) << 8) + ((i & 255) << 24);

    function InflateState() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
    }
    const inflateResetKeep = i => {
            if (!i || !i.state) return Z_STREAM_ERROR$1;
            const r = i.state;
            return i.total_in = i.total_out = r.total = 0, i.msg = "", r.wrap && (i.adler = r.wrap & 1), r.mode = HEAD, r.last = 0, r.havedict = 0, r.dmax = 32768, r.head = null, r.hold = 0, r.bits = 0, r.lencode = r.lendyn = new Int32Array(ENOUGH_LENS), r.distcode = r.distdyn = new Int32Array(ENOUGH_DISTS), r.sane = 1, r.back = -1, Z_OK$1
        },
        inflateReset = i => {
            if (!i || !i.state) return Z_STREAM_ERROR$1;
            const r = i.state;
            return r.wsize = 0, r.whave = 0, r.wnext = 0, inflateResetKeep(i)
        },
        inflateReset2 = (i, r) => {
            let n;
            if (!i || !i.state) return Z_STREAM_ERROR$1;
            const s = i.state;
            return r < 0 ? (n = 0, r = -r) : (n = (r >> 4) + 1, r < 48 && (r &= 15)), r && (r < 8 || r > 15) ? Z_STREAM_ERROR$1 : (s.window !== null && s.wbits !== r && (s.window = null), s.wrap = n, s.wbits = r, inflateReset(i))
        },
        inflateInit2 = (i, r) => {
            if (!i) return Z_STREAM_ERROR$1;
            const n = new InflateState;
            i.state = n, n.window = null;
            const s = inflateReset2(i, r);
            return s !== Z_OK$1 && (i.state = null), s
        },
        inflateInit = i => inflateInit2(i, DEF_WBITS);
    let virgin = !0,
        lenfix, distfix;
    const fixedtables = i => {
            if (virgin) {
                lenfix = new Int32Array(512), distfix = new Int32Array(32);
                let r = 0;
                for (; r < 144;) i.lens[r++] = 8;
                for (; r < 256;) i.lens[r++] = 9;
                for (; r < 280;) i.lens[r++] = 7;
                for (; r < 288;) i.lens[r++] = 8;
                for (inftrees(LENS, i.lens, 0, 288, lenfix, 0, i.work, {
                        bits: 9
                    }), r = 0; r < 32;) i.lens[r++] = 5;
                inftrees(DISTS, i.lens, 0, 32, distfix, 0, i.work, {
                    bits: 5
                }), virgin = !1
            }
            i.lencode = lenfix, i.lenbits = 9, i.distcode = distfix, i.distbits = 5
        },
        updatewindow = (i, r, n, s) => {
            let a;
            const o = i.state;
            return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), s >= o.wsize ? (o.window.set(r.subarray(n - o.wsize, n), 0), o.wnext = 0, o.whave = o.wsize) : (a = o.wsize - o.wnext, a > s && (a = s), o.window.set(r.subarray(n - s, n - s + a), o.wnext), s -= a, s ? (o.window.set(r.subarray(n - s, n), 0), o.wnext = s, o.whave = o.wsize) : (o.wnext += a, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += a))), 0
        },
        inflate$2 = (i, r) => {
            let n, s, a, o, c, p, h, u, l, v, w, m, S, C, O = 0,
                x, I, B, b, f, d, g, E;
            const T = new Uint8Array(4);
            let N, P;
            const U = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
            if (!i || !i.state || !i.output || !i.input && i.avail_in !== 0) return Z_STREAM_ERROR$1;
            n = i.state, n.mode === TYPE && (n.mode = TYPEDO), c = i.next_out, a = i.output, h = i.avail_out, o = i.next_in, s = i.input, p = i.avail_in, u = n.hold, l = n.bits, v = p, w = h, E = Z_OK$1;
            e: for (;;) switch (n.mode) {
                case HEAD:
                    if (n.wrap === 0) {
                        n.mode = TYPEDO;
                        break
                    }
                    for (; l < 16;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if (n.wrap & 2 && u === 35615) {
                        n.check = 0, T[0] = u & 255, T[1] = u >>> 8 & 255, n.check = crc32_1(n.check, T, 2, 0), u = 0, l = 0, n.mode = FLAGS;
                        break
                    }
                    if (n.flags = 0, n.head && (n.head.done = !1), !(n.wrap & 1) || (((u & 255) << 8) + (u >> 8)) % 31) {
                        i.msg = "incorrect header check", n.mode = BAD;
                        break
                    }
                    if ((u & 15) !== Z_DEFLATED) {
                        i.msg = "unknown compression method", n.mode = BAD;
                        break
                    }
                    if (u >>>= 4, l -= 4, g = (u & 15) + 8, n.wbits === 0) n.wbits = g;
                    else if (g > n.wbits) {
                        i.msg = "invalid window size", n.mode = BAD;
                        break
                    }
                    n.dmax = 1 << n.wbits, i.adler = n.check = 1, n.mode = u & 512 ? DICTID : TYPE, u = 0, l = 0;
                    break;
                case FLAGS:
                    for (; l < 16;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if (n.flags = u, (n.flags & 255) !== Z_DEFLATED) {
                        i.msg = "unknown compression method", n.mode = BAD;
                        break
                    }
                    if (n.flags & 57344) {
                        i.msg = "unknown header flags set", n.mode = BAD;
                        break
                    }
                    n.head && (n.head.text = u >> 8 & 1), n.flags & 512 && (T[0] = u & 255, T[1] = u >>> 8 & 255, n.check = crc32_1(n.check, T, 2, 0)), u = 0, l = 0, n.mode = TIME;
                case TIME:
                    for (; l < 32;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    n.head && (n.head.time = u), n.flags & 512 && (T[0] = u & 255, T[1] = u >>> 8 & 255, T[2] = u >>> 16 & 255, T[3] = u >>> 24 & 255, n.check = crc32_1(n.check, T, 4, 0)), u = 0, l = 0, n.mode = OS;
                case OS:
                    for (; l < 16;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    n.head && (n.head.xflags = u & 255, n.head.os = u >> 8), n.flags & 512 && (T[0] = u & 255, T[1] = u >>> 8 & 255, n.check = crc32_1(n.check, T, 2, 0)), u = 0, l = 0, n.mode = EXLEN;
                case EXLEN:
                    if (n.flags & 1024) {
                        for (; l < 16;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        n.length = u, n.head && (n.head.extra_len = u), n.flags & 512 && (T[0] = u & 255, T[1] = u >>> 8 & 255, n.check = crc32_1(n.check, T, 2, 0)), u = 0, l = 0
                    } else n.head && (n.head.extra = null);
                    n.mode = EXTRA;
                case EXTRA:
                    if (n.flags & 1024 && (m = n.length, m > p && (m = p), m && (n.head && (g = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(s.subarray(o, o + m), g)), n.flags & 512 && (n.check = crc32_1(n.check, s, m, o)), p -= m, o += m, n.length -= m), n.length)) break e;
                    n.length = 0, n.mode = NAME;
                case NAME:
                    if (n.flags & 2048) {
                        if (p === 0) break e;
                        m = 0;
                        do g = s[o + m++], n.head && g && n.length < 65536 && (n.head.name += String.fromCharCode(g)); while (g && m < p);
                        if (n.flags & 512 && (n.check = crc32_1(n.check, s, m, o)), p -= m, o += m, g) break e
                    } else n.head && (n.head.name = null);
                    n.length = 0, n.mode = COMMENT;
                case COMMENT:
                    if (n.flags & 4096) {
                        if (p === 0) break e;
                        m = 0;
                        do g = s[o + m++], n.head && g && n.length < 65536 && (n.head.comment += String.fromCharCode(g)); while (g && m < p);
                        if (n.flags & 512 && (n.check = crc32_1(n.check, s, m, o)), p -= m, o += m, g) break e
                    } else n.head && (n.head.comment = null);
                    n.mode = HCRC;
                case HCRC:
                    if (n.flags & 512) {
                        for (; l < 16;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        if (u !== (n.check & 65535)) {
                            i.msg = "header crc mismatch", n.mode = BAD;
                            break
                        }
                        u = 0, l = 0
                    }
                    n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), i.adler = n.check = 0, n.mode = TYPE;
                    break;
                case DICTID:
                    for (; l < 32;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    i.adler = n.check = zswap32(u), u = 0, l = 0, n.mode = DICT;
                case DICT:
                    if (n.havedict === 0) return i.next_out = c, i.avail_out = h, i.next_in = o, i.avail_in = p, n.hold = u, n.bits = l, Z_NEED_DICT$1;
                    i.adler = n.check = 1, n.mode = TYPE;
                case TYPE:
                    if (r === Z_BLOCK || r === Z_TREES) break e;
                case TYPEDO:
                    if (n.last) {
                        u >>>= l & 7, l -= l & 7, n.mode = CHECK;
                        break
                    }
                    for (; l < 3;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    switch (n.last = u & 1, u >>>= 1, l -= 1, u & 3) {
                        case 0:
                            n.mode = STORED;
                            break;
                        case 1:
                            if (fixedtables(n), n.mode = LEN_, r === Z_TREES) {
                                u >>>= 2, l -= 2;
                                break e
                            }
                            break;
                        case 2:
                            n.mode = TABLE;
                            break;
                        case 3:
                            i.msg = "invalid block type", n.mode = BAD
                    }
                    u >>>= 2, l -= 2;
                    break;
                case STORED:
                    for (u >>>= l & 7, l -= l & 7; l < 32;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if ((u & 65535) !== (u >>> 16 ^ 65535)) {
                        i.msg = "invalid stored block lengths", n.mode = BAD;
                        break
                    }
                    if (n.length = u & 65535, u = 0, l = 0, n.mode = COPY_, r === Z_TREES) break e;
                case COPY_:
                    n.mode = COPY;
                case COPY:
                    if (m = n.length, m) {
                        if (m > p && (m = p), m > h && (m = h), m === 0) break e;
                        a.set(s.subarray(o, o + m), c), p -= m, o += m, h -= m, c += m, n.length -= m;
                        break
                    }
                    n.mode = TYPE;
                    break;
                case TABLE:
                    for (; l < 14;) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if (n.nlen = (u & 31) + 257, u >>>= 5, l -= 5, n.ndist = (u & 31) + 1, u >>>= 5, l -= 5, n.ncode = (u & 15) + 4, u >>>= 4, l -= 4, n.nlen > 286 || n.ndist > 30) {
                        i.msg = "too many length or distance symbols", n.mode = BAD;
                        break
                    }
                    n.have = 0, n.mode = LENLENS;
                case LENLENS:
                    for (; n.have < n.ncode;) {
                        for (; l < 3;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        n.lens[U[n.have++]] = u & 7, u >>>= 3, l -= 3
                    }
                    for (; n.have < 19;) n.lens[U[n.have++]] = 0;
                    if (n.lencode = n.lendyn, n.lenbits = 7, N = {
                            bits: n.lenbits
                        }, E = inftrees(CODES, n.lens, 0, 19, n.lencode, 0, n.work, N), n.lenbits = N.bits, E) {
                        i.msg = "invalid code lengths set", n.mode = BAD;
                        break
                    }
                    n.have = 0, n.mode = CODELENS;
                case CODELENS:
                    for (; n.have < n.nlen + n.ndist;) {
                        for (; O = n.lencode[u & (1 << n.lenbits) - 1], x = O >>> 24, I = O >>> 16 & 255, B = O & 65535, !(x <= l);) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        if (B < 16) u >>>= x, l -= x, n.lens[n.have++] = B;
                        else {
                            if (B === 16) {
                                for (P = x + 2; l < P;) {
                                    if (p === 0) break e;
                                    p--, u += s[o++] << l, l += 8
                                }
                                if (u >>>= x, l -= x, n.have === 0) {
                                    i.msg = "invalid bit length repeat", n.mode = BAD;
                                    break
                                }
                                g = n.lens[n.have - 1], m = 3 + (u & 3), u >>>= 2, l -= 2
                            } else if (B === 17) {
                                for (P = x + 3; l < P;) {
                                    if (p === 0) break e;
                                    p--, u += s[o++] << l, l += 8
                                }
                                u >>>= x, l -= x, g = 0, m = 3 + (u & 7), u >>>= 3, l -= 3
                            } else {
                                for (P = x + 7; l < P;) {
                                    if (p === 0) break e;
                                    p--, u += s[o++] << l, l += 8
                                }
                                u >>>= x, l -= x, g = 0, m = 11 + (u & 127), u >>>= 7, l -= 7
                            }
                            if (n.have + m > n.nlen + n.ndist) {
                                i.msg = "invalid bit length repeat", n.mode = BAD;
                                break
                            }
                            for (; m--;) n.lens[n.have++] = g
                        }
                    }
                    if (n.mode === BAD) break;
                    if (n.lens[256] === 0) {
                        i.msg = "invalid code -- missing end-of-block", n.mode = BAD;
                        break
                    }
                    if (n.lenbits = 9, N = {
                            bits: n.lenbits
                        }, E = inftrees(LENS, n.lens, 0, n.nlen, n.lencode, 0, n.work, N), n.lenbits = N.bits, E) {
                        i.msg = "invalid literal/lengths set", n.mode = BAD;
                        break
                    }
                    if (n.distbits = 6, n.distcode = n.distdyn, N = {
                            bits: n.distbits
                        }, E = inftrees(DISTS, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, N), n.distbits = N.bits, E) {
                        i.msg = "invalid distances set", n.mode = BAD;
                        break
                    }
                    if (n.mode = LEN_, r === Z_TREES) break e;
                case LEN_:
                    n.mode = LEN;
                case LEN:
                    if (p >= 6 && h >= 258) {
                        i.next_out = c, i.avail_out = h, i.next_in = o, i.avail_in = p, n.hold = u, n.bits = l, inffast(i, w), c = i.next_out, a = i.output, h = i.avail_out, o = i.next_in, s = i.input, p = i.avail_in, u = n.hold, l = n.bits, n.mode === TYPE && (n.back = -1);
                        break
                    }
                    for (n.back = 0; O = n.lencode[u & (1 << n.lenbits) - 1], x = O >>> 24, I = O >>> 16 & 255, B = O & 65535, !(x <= l);) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if (I && (I & 240) === 0) {
                        for (b = x, f = I, d = B; O = n.lencode[d + ((u & (1 << b + f) - 1) >> b)], x = O >>> 24, I = O >>> 16 & 255, B = O & 65535, !(b + x <= l);) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        u >>>= b, l -= b, n.back += b
                    }
                    if (u >>>= x, l -= x, n.back += x, n.length = B, I === 0) {
                        n.mode = LIT;
                        break
                    }
                    if (I & 32) {
                        n.back = -1, n.mode = TYPE;
                        break
                    }
                    if (I & 64) {
                        i.msg = "invalid literal/length code", n.mode = BAD;
                        break
                    }
                    n.extra = I & 15, n.mode = LENEXT;
                case LENEXT:
                    if (n.extra) {
                        for (P = n.extra; l < P;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        n.length += u & (1 << n.extra) - 1, u >>>= n.extra, l -= n.extra, n.back += n.extra
                    }
                    n.was = n.length, n.mode = DIST;
                case DIST:
                    for (; O = n.distcode[u & (1 << n.distbits) - 1], x = O >>> 24, I = O >>> 16 & 255, B = O & 65535, !(x <= l);) {
                        if (p === 0) break e;
                        p--, u += s[o++] << l, l += 8
                    }
                    if ((I & 240) === 0) {
                        for (b = x, f = I, d = B; O = n.distcode[d + ((u & (1 << b + f) - 1) >> b)], x = O >>> 24, I = O >>> 16 & 255, B = O & 65535, !(b + x <= l);) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        u >>>= b, l -= b, n.back += b
                    }
                    if (u >>>= x, l -= x, n.back += x, I & 64) {
                        i.msg = "invalid distance code", n.mode = BAD;
                        break
                    }
                    n.offset = B, n.extra = I & 15, n.mode = DISTEXT;
                case DISTEXT:
                    if (n.extra) {
                        for (P = n.extra; l < P;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        n.offset += u & (1 << n.extra) - 1, u >>>= n.extra, l -= n.extra, n.back += n.extra
                    }
                    if (n.offset > n.dmax) {
                        i.msg = "invalid distance too far back", n.mode = BAD;
                        break
                    }
                    n.mode = MATCH;
                case MATCH:
                    if (h === 0) break e;
                    if (m = w - h, n.offset > m) {
                        if (m = n.offset - m, m > n.whave && n.sane) {
                            i.msg = "invalid distance too far back", n.mode = BAD;
                            break
                        }
                        m > n.wnext ? (m -= n.wnext, S = n.wsize - m) : S = n.wnext - m, m > n.length && (m = n.length), C = n.window
                    } else C = a, S = c - n.offset, m = n.length;
                    m > h && (m = h), h -= m, n.length -= m;
                    do a[c++] = C[S++]; while (--m);
                    n.length === 0 && (n.mode = LEN);
                    break;
                case LIT:
                    if (h === 0) break e;
                    a[c++] = n.length, h--, n.mode = LEN;
                    break;
                case CHECK:
                    if (n.wrap) {
                        for (; l < 32;) {
                            if (p === 0) break e;
                            p--, u |= s[o++] << l, l += 8
                        }
                        if (w -= h, i.total_out += w, n.total += w, w && (i.adler = n.check = n.flags ? crc32_1(n.check, a, w, c - w) : adler32_1(n.check, a, w, c - w)), w = h, (n.flags ? u : zswap32(u)) !== n.check) {
                            i.msg = "incorrect data check", n.mode = BAD;
                            break
                        }
                        u = 0, l = 0
                    }
                    n.mode = LENGTH$1;
                case LENGTH$1:
                    if (n.wrap && n.flags) {
                        for (; l < 32;) {
                            if (p === 0) break e;
                            p--, u += s[o++] << l, l += 8
                        }
                        if (u !== (n.total & 4294967295)) {
                            i.msg = "incorrect length check", n.mode = BAD;
                            break
                        }
                        u = 0, l = 0
                    }
                    n.mode = DONE;
                case DONE:
                    E = Z_STREAM_END$1;
                    break e;
                case BAD:
                    E = Z_DATA_ERROR$1;
                    break e;
                case MEM:
                    return Z_MEM_ERROR$1;
                case SYNC:
                default:
                    return Z_STREAM_ERROR$1
            }
            return i.next_out = c, i.avail_out = h, i.next_in = o, i.avail_in = p, n.hold = u, n.bits = l, (n.wsize || w !== i.avail_out && n.mode < BAD && (n.mode < CHECK || r !== Z_FINISH$1)) && updatewindow(i, i.output, i.next_out, w - i.avail_out), v -= i.avail_in, w -= i.avail_out, i.total_in += v, i.total_out += w, n.total += w, n.wrap && w && (i.adler = n.check = n.flags ? crc32_1(n.check, a, w, i.next_out - w) : adler32_1(n.check, a, w, i.next_out - w)), i.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === TYPE ? 128 : 0) + (n.mode === LEN_ || n.mode === COPY_ ? 256 : 0), (v === 0 && w === 0 || r === Z_FINISH$1) && E === Z_OK$1 && (E = Z_BUF_ERROR), E
        },
        inflateEnd = i => {
            if (!i || !i.state) return Z_STREAM_ERROR$1;
            let r = i.state;
            return r.window && (r.window = null), i.state = null, Z_OK$1
        },
        inflateGetHeader = (i, r) => {
            if (!i || !i.state) return Z_STREAM_ERROR$1;
            const n = i.state;
            return (n.wrap & 2) === 0 ? Z_STREAM_ERROR$1 : (n.head = r, r.done = !1, Z_OK$1)
        },
        inflateSetDictionary = (i, r) => {
            const n = r.length;
            let s, a, o;
            return !i || !i.state || (s = i.state, s.wrap !== 0 && s.mode !== DICT) ? Z_STREAM_ERROR$1 : s.mode === DICT && (a = 1, a = adler32_1(a, r, n, 0), a !== s.check) ? Z_DATA_ERROR$1 : (o = updatewindow(i, r, n, n), o ? (s.mode = MEM, Z_MEM_ERROR$1) : (s.havedict = 1, Z_OK$1))
        };
    var inflateReset_1 = inflateReset,
        inflateReset2_1 = inflateReset2,
        inflateResetKeep_1 = inflateResetKeep,
        inflateInit_1 = inflateInit,
        inflateInit2_1 = inflateInit2,
        inflate_2$1 = inflate$2,
        inflateEnd_1 = inflateEnd,
        inflateGetHeader_1 = inflateGetHeader,
        inflateSetDictionary_1 = inflateSetDictionary,
        inflateInfo = "pako inflate (from Nodeca project)",
        inflate_1$2 = {
            inflateReset: inflateReset_1,
            inflateReset2: inflateReset2_1,
            inflateResetKeep: inflateResetKeep_1,
            inflateInit: inflateInit_1,
            inflateInit2: inflateInit2_1,
            inflate: inflate_2$1,
            inflateEnd: inflateEnd_1,
            inflateGetHeader: inflateGetHeader_1,
            inflateSetDictionary: inflateSetDictionary_1,
            inflateInfo
        };

    function GZheader() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
    }
    var gzheader = GZheader;
    const toString = Object.prototype.toString,
        {
            Z_NO_FLUSH,
            Z_FINISH,
            Z_OK,
            Z_STREAM_END,
            Z_NEED_DICT,
            Z_STREAM_ERROR,
            Z_DATA_ERROR,
            Z_MEM_ERROR
        } = constants$2;

    function Inflate$1(i) {
        this.options = common.assign({
            chunkSize: 65536,
            windowBits: 15,
            to: ""
        }, i || {});
        const r = this.options;
        r.raw && r.windowBits >= 0 && r.windowBits < 16 && (r.windowBits = -r.windowBits, r.windowBits === 0 && (r.windowBits = -15)), r.windowBits >= 0 && r.windowBits < 16 && !(i && i.windowBits) && (r.windowBits += 32), r.windowBits > 15 && r.windowBits < 48 && (r.windowBits & 15) === 0 && (r.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0;
        let n = inflate_1$2.inflateInit2(this.strm, r.windowBits);
        if (n !== Z_OK) throw new Error(messages[n]);
        if (this.header = new gzheader, inflate_1$2.inflateGetHeader(this.strm, this.header), r.dictionary && (typeof r.dictionary == "string" ? r.dictionary = strings.string2buf(r.dictionary) : toString.call(r.dictionary) === "[object ArrayBuffer]" && (r.dictionary = new Uint8Array(r.dictionary)), r.raw && (n = inflate_1$2.inflateSetDictionary(this.strm, r.dictionary), n !== Z_OK))) throw new Error(messages[n])
    }
    Inflate$1.prototype.push = function(i, r) {
        const n = this.strm,
            s = this.options.chunkSize,
            a = this.options.dictionary;
        let o, c, p;
        if (this.ended) return !1;
        for (r === ~~r ? c = r : c = r === !0 ? Z_FINISH : Z_NO_FLUSH, toString.call(i) === "[object ArrayBuffer]" ? n.input = new Uint8Array(i) : n.input = i, n.next_in = 0, n.avail_in = n.input.length;;) {
            for (n.avail_out === 0 && (n.output = new Uint8Array(s), n.next_out = 0, n.avail_out = s), o = inflate_1$2.inflate(n, c), o === Z_NEED_DICT && a && (o = inflate_1$2.inflateSetDictionary(n, a), o === Z_OK ? o = inflate_1$2.inflate(n, c) : o === Z_DATA_ERROR && (o = Z_NEED_DICT)); n.avail_in > 0 && o === Z_STREAM_END && n.state.wrap > 0 && i[n.next_in] !== 0;) inflate_1$2.inflateReset(n), o = inflate_1$2.inflate(n, c);
            switch (o) {
                case Z_STREAM_ERROR:
                case Z_DATA_ERROR:
                case Z_NEED_DICT:
                case Z_MEM_ERROR:
                    return this.onEnd(o), this.ended = !0, !1
            }
            if (p = n.avail_out, n.next_out && (n.avail_out === 0 || o === Z_STREAM_END))
                if (this.options.to === "string") {
                    let h = strings.utf8border(n.output, n.next_out),
                        u = n.next_out - h,
                        l = strings.buf2string(n.output, h);
                    n.next_out = u, n.avail_out = s - u, u && n.output.set(n.output.subarray(h, h + u), 0), this.onData(l)
                } else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
            if (!(o === Z_OK && p === 0)) {
                if (o === Z_STREAM_END) return o = inflate_1$2.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, !0;
                if (n.avail_in === 0) break
            }
        }
        return !0
    }, Inflate$1.prototype.onData = function(i) {
        this.chunks.push(i)
    }, Inflate$1.prototype.onEnd = function(i) {
        i === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = i, this.msg = this.strm.msg
    };

    function inflate$1(i, r) {
        const n = new Inflate$1(r);
        if (n.push(i), n.err) throw n.msg || messages[n.err];
        return n.result
    }

    function inflateRaw$1(i, r) {
        return r = r || {}, r.raw = !0, inflate$1(i, r)
    }
    var Inflate_1$1 = Inflate$1,
        inflate_2 = inflate$1,
        inflateRaw_1$1 = inflateRaw$1,
        ungzip$1 = inflate$1,
        constants$1 = constants$2,
        inflate_1$1 = {
            Inflate: Inflate_1$1,
            inflate: inflate_2,
            inflateRaw: inflateRaw_1$1,
            ungzip: ungzip$1,
            constants: constants$1
        };
    const {
        Inflate,
        inflate,
        inflateRaw,
        ungzip
    } = inflate_1$1;
    var inflate_1 = inflate,
        iterator, hasRequiredIterator;

    function requireIterator() {
        return hasRequiredIterator || (hasRequiredIterator = 1, iterator = function(i) {
            i.prototype[Symbol.iterator] = function*() {
                for (let r = this.head; r; r = r.next) yield r.value
            }
        }), iterator
    }
    var yallist = Yallist$1;
    Yallist$1.Node = Node, Yallist$1.create = Yallist$1;

    function Yallist$1(i) {
        var r = this;
        if (r instanceof Yallist$1 || (r = new Yallist$1), r.tail = null, r.head = null, r.length = 0, i && typeof i.forEach == "function") i.forEach(function(a) {
            r.push(a)
        });
        else if (arguments.length > 0)
            for (var n = 0, s = arguments.length; n < s; n++) r.push(arguments[n]);
        return r
    }
    Yallist$1.prototype.removeNode = function(i) {
        if (i.list !== this) throw new Error("removing node which does not belong to this list");
        var r = i.next,
            n = i.prev;
        return r && (r.prev = n), n && (n.next = r), i === this.head && (this.head = r), i === this.tail && (this.tail = n), i.list.length--, i.next = null, i.prev = null, i.list = null, r
    }, Yallist$1.prototype.unshiftNode = function(i) {
        if (i !== this.head) {
            i.list && i.list.removeNode(i);
            var r = this.head;
            i.list = this, i.next = r, r && (r.prev = i), this.head = i, this.tail || (this.tail = i), this.length++
        }
    }, Yallist$1.prototype.pushNode = function(i) {
        if (i !== this.tail) {
            i.list && i.list.removeNode(i);
            var r = this.tail;
            i.list = this, i.prev = r, r && (r.next = i), this.tail = i, this.head || (this.head = i), this.length++
        }
    }, Yallist$1.prototype.push = function() {
        for (var i = 0, r = arguments.length; i < r; i++) push(this, arguments[i]);
        return this.length
    }, Yallist$1.prototype.unshift = function() {
        for (var i = 0, r = arguments.length; i < r; i++) unshift(this, arguments[i]);
        return this.length
    }, Yallist$1.prototype.pop = function() {
        if (!!this.tail) {
            var i = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, i
        }
    }, Yallist$1.prototype.shift = function() {
        if (!!this.head) {
            var i = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, i
        }
    }, Yallist$1.prototype.forEach = function(i, r) {
        r = r || this;
        for (var n = this.head, s = 0; n !== null; s++) i.call(r, n.value, s, this), n = n.next
    }, Yallist$1.prototype.forEachReverse = function(i, r) {
        r = r || this;
        for (var n = this.tail, s = this.length - 1; n !== null; s--) i.call(r, n.value, s, this), n = n.prev
    }, Yallist$1.prototype.get = function(i) {
        for (var r = 0, n = this.head; n !== null && r < i; r++) n = n.next;
        if (r === i && n !== null) return n.value
    }, Yallist$1.prototype.getReverse = function(i) {
        for (var r = 0, n = this.tail; n !== null && r < i; r++) n = n.prev;
        if (r === i && n !== null) return n.value
    }, Yallist$1.prototype.map = function(i, r) {
        r = r || this;
        for (var n = new Yallist$1, s = this.head; s !== null;) n.push(i.call(r, s.value, this)), s = s.next;
        return n
    }, Yallist$1.prototype.mapReverse = function(i, r) {
        r = r || this;
        for (var n = new Yallist$1, s = this.tail; s !== null;) n.push(i.call(r, s.value, this)), s = s.prev;
        return n
    }, Yallist$1.prototype.reduce = function(i, r) {
        var n, s = this.head;
        if (arguments.length > 1) n = r;
        else if (this.head) s = this.head.next, n = this.head.value;
        else throw new TypeError("Reduce of empty list with no initial value");
        for (var a = 0; s !== null; a++) n = i(n, s.value, a), s = s.next;
        return n
    }, Yallist$1.prototype.reduceReverse = function(i, r) {
        var n, s = this.tail;
        if (arguments.length > 1) n = r;
        else if (this.tail) s = this.tail.prev, n = this.tail.value;
        else throw new TypeError("Reduce of empty list with no initial value");
        for (var a = this.length - 1; s !== null; a--) n = i(n, s.value, a), s = s.prev;
        return n
    }, Yallist$1.prototype.toArray = function() {
        for (var i = new Array(this.length), r = 0, n = this.head; n !== null; r++) i[r] = n.value, n = n.next;
        return i
    }, Yallist$1.prototype.toArrayReverse = function() {
        for (var i = new Array(this.length), r = 0, n = this.tail; n !== null; r++) i[r] = n.value, n = n.prev;
        return i
    }, Yallist$1.prototype.slice = function(i, r) {
        r = r || this.length, r < 0 && (r += this.length), i = i || 0, i < 0 && (i += this.length);
        var n = new Yallist$1;
        if (r < i || r < 0) return n;
        i < 0 && (i = 0), r > this.length && (r = this.length);
        for (var s = 0, a = this.head; a !== null && s < i; s++) a = a.next;
        for (; a !== null && s < r; s++, a = a.next) n.push(a.value);
        return n
    }, Yallist$1.prototype.sliceReverse = function(i, r) {
        r = r || this.length, r < 0 && (r += this.length), i = i || 0, i < 0 && (i += this.length);
        var n = new Yallist$1;
        if (r < i || r < 0) return n;
        i < 0 && (i = 0), r > this.length && (r = this.length);
        for (var s = this.length, a = this.tail; a !== null && s > r; s--) a = a.prev;
        for (; a !== null && s > i; s--, a = a.prev) n.push(a.value);
        return n
    }, Yallist$1.prototype.splice = function(i, r, ...n) {
        i > this.length && (i = this.length - 1), i < 0 && (i = this.length + i);
        for (var s = 0, a = this.head; a !== null && s < i; s++) a = a.next;
        for (var o = [], s = 0; a && s < r; s++) o.push(a.value), a = this.removeNode(a);
        a === null && (a = this.tail), a !== this.head && a !== this.tail && (a = a.prev);
        for (var s = 0; s < n.length; s++) a = insert(this, a, n[s]);
        return o
    }, Yallist$1.prototype.reverse = function() {
        for (var i = this.head, r = this.tail, n = i; n !== null; n = n.prev) {
            var s = n.prev;
            n.prev = n.next, n.next = s
        }
        return this.head = r, this.tail = i, this
    };

    function insert(i, r, n) {
        var s = r === i.head ? new Node(n, null, r, i) : new Node(n, r, r.next, i);
        return s.next === null && (i.tail = s), s.prev === null && (i.head = s), i.length++, s
    }

    function push(i, r) {
        i.tail = new Node(r, i.tail, null, i), i.head || (i.head = i.tail), i.length++
    }

    function unshift(i, r) {
        i.head = new Node(r, null, i.head, i), i.tail || (i.tail = i.head), i.length++
    }

    function Node(i, r, n, s) {
        if (!(this instanceof Node)) return new Node(i, r, n, s);
        this.list = s, this.value = i, r ? (r.next = this, this.prev = r) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
    }
    try {
        requireIterator()(Yallist$1)
    } catch (i) {}
    const Yallist = yallist,
        MAX = Symbol("max"),
        LENGTH = Symbol("length"),
        LENGTH_CALCULATOR = Symbol("lengthCalculator"),
        ALLOW_STALE = Symbol("allowStale"),
        MAX_AGE = Symbol("maxAge"),
        DISPOSE = Symbol("dispose"),
        NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"),
        LRU_LIST = Symbol("lruList"),
        CACHE = Symbol("cache"),
        UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"),
        naiveLength = () => 1;
    class LRUCache {
        constructor(r) {
            if (typeof r == "number" && (r = {
                    max: r
                }), r || (r = {}), r.max && (typeof r.max != "number" || r.max < 0)) throw new TypeError("max must be a non-negative number");
            this[MAX] = r.max || 1 / 0;
            const n = r.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = typeof n != "function" ? naiveLength : n, this[ALLOW_STALE] = r.stale || !1, r.maxAge && typeof r.maxAge != "number") throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = r.maxAge || 0, this[DISPOSE] = r.dispose, this[NO_DISPOSE_ON_SET] = r.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = r.updateAgeOnGet || !1, this.reset()
        }
        set max(r) {
            if (typeof r != "number" || r < 0) throw new TypeError("max must be a non-negative number");
            this[MAX] = r || 1 / 0, trim(this)
        }
        get max() {
            return this[MAX]
        }
        set allowStale(r) {
            this[ALLOW_STALE] = !!r
        }
        get allowStale() {
            return this[ALLOW_STALE]
        }
        set maxAge(r) {
            if (typeof r != "number") throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = r, trim(this)
        }
        get maxAge() {
            return this[MAX_AGE]
        }
        set lengthCalculator(r) {
            typeof r != "function" && (r = naiveLength), r !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = r, this[LENGTH] = 0, this[LRU_LIST].forEach(n => {
                n.length = this[LENGTH_CALCULATOR](n.value, n.key), this[LENGTH] += n.length
            })), trim(this)
        }
        get lengthCalculator() {
            return this[LENGTH_CALCULATOR]
        }
        get length() {
            return this[LENGTH]
        }
        get itemCount() {
            return this[LRU_LIST].length
        }
        rforEach(r, n) {
            n = n || this;
            for (let s = this[LRU_LIST].tail; s !== null;) {
                const a = s.prev;
                forEachStep(this, r, s, n), s = a
            }
        }
        forEach(r, n) {
            n = n || this;
            for (let s = this[LRU_LIST].head; s !== null;) {
                const a = s.next;
                forEachStep(this, r, s, n), s = a
            }
        }
        keys() {
            return this[LRU_LIST].toArray().map(r => r.key)
        }
        values() {
            return this[LRU_LIST].toArray().map(r => r.value)
        }
        reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(r => this[DISPOSE](r.key, r.value)), this[CACHE] = new Map, this[LRU_LIST] = new Yallist, this[LENGTH] = 0
        }
        dump() {
            return this[LRU_LIST].map(r => isStale(this, r) ? !1 : {
                k: r.key,
                v: r.value,
                e: r.now + (r.maxAge || 0)
            }).toArray().filter(r => r)
        }
        dumpLru() {
            return this[LRU_LIST]
        }
        set(r, n, s) {
            if (s = s || this[MAX_AGE], s && typeof s != "number") throw new TypeError("maxAge must be a number");
            const a = s ? Date.now() : 0,
                o = this[LENGTH_CALCULATOR](n, r);
            if (this[CACHE].has(r)) {
                if (o > this[MAX]) return del(this, this[CACHE].get(r)), !1;
                const h = this[CACHE].get(r).value;
                return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](r, h.value)), h.now = a, h.maxAge = s, h.value = n, this[LENGTH] += o - h.length, h.length = o, this.get(r), trim(this), !0
            }
            const c = new Entry(r, n, o, a, s);
            return c.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](r, n), !1) : (this[LENGTH] += c.length, this[LRU_LIST].unshift(c), this[CACHE].set(r, this[LRU_LIST].head), trim(this), !0)
        }
        has(r) {
            if (!this[CACHE].has(r)) return !1;
            const n = this[CACHE].get(r).value;
            return !isStale(this, n)
        }
        get(r) {
            return get(this, r, !0)
        }
        peek(r) {
            return get(this, r, !1)
        }
        pop() {
            const r = this[LRU_LIST].tail;
            return r ? (del(this, r), r.value) : null
        }
        del(r) {
            del(this, this[CACHE].get(r))
        }
        load(r) {
            this.reset();
            const n = Date.now();
            for (let s = r.length - 1; s >= 0; s--) {
                const a = r[s],
                    o = a.e || 0;
                if (o === 0) this.set(a.k, a.v);
                else {
                    const c = o - n;
                    c > 0 && this.set(a.k, a.v, c)
                }
            }
        }
        prune() {
            this[CACHE].forEach((r, n) => get(this, n, !1))
        }
    }
    const get = (i, r, n) => {
            const s = i[CACHE].get(r);
            if (s) {
                const a = s.value;
                if (isStale(i, a)) {
                    if (del(i, s), !i[ALLOW_STALE]) return
                } else n && (i[UPDATE_AGE_ON_GET] && (s.value.now = Date.now()), i[LRU_LIST].unshiftNode(s));
                return a.value
            }
        },
        isStale = (i, r) => {
            if (!r || !r.maxAge && !i[MAX_AGE]) return !1;
            const n = Date.now() - r.now;
            return r.maxAge ? n > r.maxAge : i[MAX_AGE] && n > i[MAX_AGE]
        },
        trim = i => {
            if (i[LENGTH] > i[MAX])
                for (let r = i[LRU_LIST].tail; i[LENGTH] > i[MAX] && r !== null;) {
                    const n = r.prev;
                    del(i, r), r = n
                }
        },
        del = (i, r) => {
            if (r) {
                const n = r.value;
                i[DISPOSE] && i[DISPOSE](n.key, n.value), i[LENGTH] -= n.length, i[CACHE].delete(n.key), i[LRU_LIST].removeNode(r)
            }
        };
    class Entry {
        constructor(r, n, s, a, o) {
            this.key = r, this.value = n, this.length = s, this.now = a, this.maxAge = o || 0
        }
    }
    const forEachStep = (i, r, n, s) => {
        let a = n.value;
        isStale(i, a) && (del(i, n), i[ALLOW_STALE] || (a = void 0)), a && r.call(s, a.value, a.key, i)
    };
    var lruCache = LRUCache;
    const opts = ["includePrerelease", "loose", "rtl"],
        parseOptions$1 = i => i ? typeof i != "object" ? {
            loose: !0
        } : opts.filter(r => i[r]).reduce((r, n) => (r[n] = !0, r), {}) : {};
    var parseOptions_1 = parseOptions$1,
        re$1 = {
            exports: {}
        };
    const SEMVER_SPEC_VERSION = "2.0.0",
        MAX_LENGTH$1 = 256,
        MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991,
        MAX_SAFE_COMPONENT_LENGTH = 16;
    var constants = {
        SEMVER_SPEC_VERSION,
        MAX_LENGTH: MAX_LENGTH$1,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
        MAX_SAFE_COMPONENT_LENGTH
    };
    const debug$1 = typeof process == "object" && {
        mode: "production",
        command: "build",
        ssrBuild: !1
    } && {
        mode: "production",
        command: "build",
        ssrBuild: !1
    }.NODE_DEBUG && /\bsemver\b/i.test({
        mode: "production",
        command: "build",
        ssrBuild: !1
    }.NODE_DEBUG) ? (...i) => console.error("SEMVER", ...i) : () => {};
    var debug_1 = debug$1;
    (function(i, r) {
        const {
            MAX_SAFE_COMPONENT_LENGTH: n
        } = constants, s = debug_1;
        r = i.exports = {};
        const a = r.re = [],
            o = r.src = [],
            c = r.t = {};
        let p = 0;
        const h = (u, l, v) => {
            const w = p++;
            s(u, w, l), c[u] = w, o[w] = l, a[w] = new RegExp(l, v ? "g" : void 0)
        };
        h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "[0-9]+"), h("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), h("MAINVERSION", `(${o[c.NUMERICIDENTIFIER]})\\.(${o[c.NUMERICIDENTIFIER]})\\.(${o[c.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${o[c.NUMERICIDENTIFIERLOOSE]})\\.(${o[c.NUMERICIDENTIFIERLOOSE]})\\.(${o[c.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${o[c.NUMERICIDENTIFIER]}|${o[c.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${o[c.NUMERICIDENTIFIERLOOSE]}|${o[c.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${o[c.PRERELEASEIDENTIFIER]}(?:\\.${o[c.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${o[c.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[c.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), h("BUILD", `(?:\\+(${o[c.BUILDIDENTIFIER]}(?:\\.${o[c.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${o[c.MAINVERSION]}${o[c.PRERELEASE]}?${o[c.BUILD]}?`), h("FULL", `^${o[c.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${o[c.MAINVERSIONLOOSE]}${o[c.PRERELEASELOOSE]}?${o[c.BUILD]}?`), h("LOOSE", `^${o[c.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${o[c.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${o[c.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${o[c.XRANGEIDENTIFIER]})(?:\\.(${o[c.XRANGEIDENTIFIER]})(?:\\.(${o[c.XRANGEIDENTIFIER]})(?:${o[c.PRERELEASE]})?${o[c.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${o[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[c.XRANGEIDENTIFIERLOOSE]})(?:${o[c.PRERELEASELOOSE]})?${o[c.BUILD]}?)?)?`), h("XRANGE", `^${o[c.GTLT]}\\s*${o[c.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${o[c.GTLT]}\\s*${o[c.XRANGEPLAINLOOSE]}$`), h("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), h("COERCERTL", o[c.COERCE], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${o[c.LONETILDE]}\\s+`, !0), r.tildeTrimReplace = "$1~", h("TILDE", `^${o[c.LONETILDE]}${o[c.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${o[c.LONETILDE]}${o[c.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${o[c.LONECARET]}\\s+`, !0), r.caretTrimReplace = "$1^", h("CARET", `^${o[c.LONECARET]}${o[c.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${o[c.LONECARET]}${o[c.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${o[c.GTLT]}\\s*(${o[c.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${o[c.GTLT]}\\s*(${o[c.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${o[c.GTLT]}\\s*(${o[c.LOOSEPLAIN]}|${o[c.XRANGEPLAIN]})`, !0), r.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${o[c.XRANGEPLAIN]})\\s+-\\s+(${o[c.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${o[c.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[c.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
    })(re$1, re$1.exports);
    const numeric = /^[0-9]+$/,
        compareIdentifiers$1 = (i, r) => {
            const n = numeric.test(i),
                s = numeric.test(r);
            return n && s && (i = +i, r = +r), i === r ? 0 : n && !s ? -1 : s && !n ? 1 : i < r ? -1 : 1
        },
        rcompareIdentifiers = (i, r) => compareIdentifiers$1(r, i);
    var identifiers = {
        compareIdentifiers: compareIdentifiers$1,
        rcompareIdentifiers
    };
    const debug = debug_1,
        {
            MAX_LENGTH,
            MAX_SAFE_INTEGER
        } = constants,
        {
            re,
            t
        } = re$1.exports,
        parseOptions = parseOptions_1,
        {
            compareIdentifiers
        } = identifiers;
    class SemVer$1 {
        constructor(r, n) {
            if (n = parseOptions(n), r instanceof SemVer$1) {
                if (r.loose === !!n.loose && r.includePrerelease === !!n.includePrerelease) return r;
                r = r.version
            } else if (typeof r != "string") throw new TypeError(`Invalid Version: ${r}`);
            if (r.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
            debug("SemVer", r, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
            const s = r.trim().match(n.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!s) throw new TypeError(`Invalid Version: ${r}`);
            if (this.raw = r, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
            s[4] ? this.prerelease = s[4].split(".").map(a => {
                if (/^[0-9]+$/.test(a)) {
                    const o = +a;
                    if (o >= 0 && o < MAX_SAFE_INTEGER) return o
                }
                return a
            }) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format()
        }
        format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
        }
        toString() {
            return this.version
        }
        compare(r) {
            if (debug("SemVer.compare", this.version, this.options, r), !(r instanceof SemVer$1)) {
                if (typeof r == "string" && r === this.version) return 0;
                r = new SemVer$1(r, this.options)
            }
            return r.version === this.version ? 0 : this.compareMain(r) || this.comparePre(r)
        }
        compareMain(r) {
            return r instanceof SemVer$1 || (r = new SemVer$1(r, this.options)), compareIdentifiers(this.major, r.major) || compareIdentifiers(this.minor, r.minor) || compareIdentifiers(this.patch, r.patch)
        }
        comparePre(r) {
            if (r instanceof SemVer$1 || (r = new SemVer$1(r, this.options)), this.prerelease.length && !r.prerelease.length) return -1;
            if (!this.prerelease.length && r.prerelease.length) return 1;
            if (!this.prerelease.length && !r.prerelease.length) return 0;
            let n = 0;
            do {
                const s = this.prerelease[n],
                    a = r.prerelease[n];
                if (debug("prerelease compare", n, s, a), s === void 0 && a === void 0) return 0;
                if (a === void 0) return 1;
                if (s === void 0) return -1;
                if (s === a) continue;
                return compareIdentifiers(s, a)
            } while (++n)
        }
        compareBuild(r) {
            r instanceof SemVer$1 || (r = new SemVer$1(r, this.options));
            let n = 0;
            do {
                const s = this.build[n],
                    a = r.build[n];
                if (debug("prerelease compare", n, s, a), s === void 0 && a === void 0) return 0;
                if (a === void 0) return 1;
                if (s === void 0) return -1;
                if (s === a) continue;
                return compareIdentifiers(s, a)
            } while (++n)
        }
        inc(r, n) {
            switch (r) {
                case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n);
                    break;
                case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n);
                    break;
                case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", n), this.inc("pre", n);
                    break;
                case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", n), this.inc("pre", n);
                    break;
                case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                case "pre":
                    if (this.prerelease.length === 0) this.prerelease = [0];
                    else {
                        let s = this.prerelease.length;
                        for (; --s >= 0;) typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
                        s === -1 && this.prerelease.push(0)
                    }
                    n && (compareIdentifiers(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0]) : this.prerelease = [n, 0]);
                    break;
                default:
                    throw new Error(`invalid increment argument: ${r}`)
            }
            return this.format(), this.raw = this.version, this
        }
    }
    var semver = SemVer$1;
    const SemVer = semver,
        compare$6 = (i, r, n) => new SemVer(i, n).compare(new SemVer(r, n));
    var compare_1 = compare$6;
    const compare$5 = compare_1,
        eq$1 = (i, r, n) => compare$5(i, r, n) === 0;
    var eq_1 = eq$1;
    const compare$4 = compare_1,
        neq$1 = (i, r, n) => compare$4(i, r, n) !== 0;
    var neq_1 = neq$1;
    const compare$3 = compare_1,
        gt$1 = (i, r, n) => compare$3(i, r, n) > 0;
    var gt_1 = gt$1;
    const compare$2 = compare_1,
        gte$1 = (i, r, n) => compare$2(i, r, n) >= 0;
    var gte_1 = gte$1;
    const compare$1 = compare_1,
        lt$1 = (i, r, n) => compare$1(i, r, n) < 0;
    var lt_1 = lt$1;
    const compare = compare_1,
        lte$1 = (i, r, n) => compare(i, r, n) <= 0;
    var lte_1 = lte$1;
    const eq = eq_1,
        neq = neq_1,
        gt = gt_1,
        gte = gte_1,
        lt = lt_1,
        lte = lte_1,
        cmp = (i, r, n, s) => {
            switch (r) {
                case "===":
                    return typeof i == "object" && (i = i.version), typeof n == "object" && (n = n.version), i === n;
                case "!==":
                    return typeof i == "object" && (i = i.version), typeof n == "object" && (n = n.version), i !== n;
                case "":
                case "=":
                case "==":
                    return eq(i, n, s);
                case "!=":
                    return neq(i, n, s);
                case ">":
                    return gt(i, n, s);
                case ">=":
                    return gte(i, n, s);
                case "<":
                    return lt(i, n, s);
                case "<=":
                    return lte(i, n, s);
                default:
                    throw new TypeError(`Invalid operator: ${r}`)
            }
        };
    var cmp_1 = cmp,
        comparator, hasRequiredComparator;

    function requireComparator() {
        if (hasRequiredComparator) return comparator;
        hasRequiredComparator = 1;
        const i = Symbol("SemVer ANY");
        class r {
            static get ANY() {
                return i
            }
            constructor(l, v) {
                if (v = n(v), l instanceof r) {
                    if (l.loose === !!v.loose) return l;
                    l = l.value
                }
                c("comparator", l, v), this.options = v, this.loose = !!v.loose, this.parse(l), this.semver === i ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this)
            }
            parse(l) {
                const v = this.options.loose ? s[a.COMPARATORLOOSE] : s[a.COMPARATOR],
                    w = l.match(v);
                if (!w) throw new TypeError(`Invalid comparator: ${l}`);
                this.operator = w[1] !== void 0 ? w[1] : "", this.operator === "=" && (this.operator = ""), w[2] ? this.semver = new p(w[2], this.options.loose) : this.semver = i
            }
            toString() {
                return this.value
            }
            test(l) {
                if (c("Comparator.test", l, this.options.loose), this.semver === i || l === i) return !0;
                if (typeof l == "string") try {
                    l = new p(l, this.options)
                } catch {
                    return !1
                }
                return o(l, this.operator, this.semver, this.options)
            }
            intersects(l, v) {
                if (!(l instanceof r)) throw new TypeError("a Comparator is required");
                if ((!v || typeof v != "object") && (v = {
                        loose: !!v,
                        includePrerelease: !1
                    }), this.operator === "") return this.value === "" ? !0 : new h(l.value, v).test(this.value);
                if (l.operator === "") return l.value === "" ? !0 : new h(this.value, v).test(l.semver);
                const w = (this.operator === ">=" || this.operator === ">") && (l.operator === ">=" || l.operator === ">"),
                    m = (this.operator === "<=" || this.operator === "<") && (l.operator === "<=" || l.operator === "<"),
                    S = this.semver.version === l.semver.version,
                    C = (this.operator === ">=" || this.operator === "<=") && (l.operator === ">=" || l.operator === "<="),
                    O = o(this.semver, "<", l.semver, v) && (this.operator === ">=" || this.operator === ">") && (l.operator === "<=" || l.operator === "<"),
                    x = o(this.semver, ">", l.semver, v) && (this.operator === "<=" || this.operator === "<") && (l.operator === ">=" || l.operator === ">");
                return w || m || S && C || O || x
            }
        }
        comparator = r;
        const n = parseOptions_1,
            {
                re: s,
                t: a
            } = re$1.exports,
            o = cmp_1,
            c = debug_1,
            p = semver,
            h = requireRange();
        return comparator
    }
    var range, hasRequiredRange;

    function requireRange() {
        if (hasRequiredRange) return range;
        hasRequiredRange = 1;
        class i {
            constructor(U, F) {
                if (F = s(F), U instanceof i) return U.loose === !!F.loose && U.includePrerelease === !!F.includePrerelease ? U : new i(U.raw, F);
                if (U instanceof a) return this.raw = U.value, this.set = [
                    [U]
                ], this.format(), this;
                if (this.options = F, this.loose = !!F.loose, this.includePrerelease = !!F.includePrerelease, this.raw = U, this.set = U.split("||").map(L => this.parseRange(L.trim())).filter(L => L.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${U}`);
                if (this.set.length > 1) {
                    const L = this.set[0];
                    if (this.set = this.set.filter(G => !w(G[0])), this.set.length === 0) this.set = [L];
                    else if (this.set.length > 1) {
                        for (const G of this.set)
                            if (G.length === 1 && m(G[0])) {
                                this.set = [G];
                                break
                            }
                    }
                }
                this.format()
            }
            format() {
                return this.range = this.set.map(U => U.join(" ").trim()).join("||").trim(), this.range
            }
            toString() {
                return this.range
            }
            parseRange(U) {
                U = U.trim();
                const L = `parseRange:${Object.keys(this.options).join(",")}:${U}`,
                    G = n.get(L);
                if (G) return G;
                const M = this.options.loose,
                    _ = M ? p[h.HYPHENRANGELOOSE] : p[h.HYPHENRANGE];
                U = U.replace(_, T(this.options.includePrerelease)), o("hyphen replace", U), U = U.replace(p[h.COMPARATORTRIM], u), o("comparator trim", U), U = U.replace(p[h.TILDETRIM], l), U = U.replace(p[h.CARETTRIM], v), U = U.split(/\s+/).join(" ");
                let A = U.split(" ").map(D => C(D, this.options)).join(" ").split(/\s+/).map(D => E(D, this.options));
                M && (A = A.filter(D => (o("loose invalid filter", D, this.options), !!D.match(p[h.COMPARATORLOOSE])))), o("range list", A);
                const y = new Map,
                    k = A.map(D => new a(D, this.options));
                for (const D of k) {
                    if (w(D)) return [D];
                    y.set(D.value, D)
                }
                y.size > 1 && y.has("") && y.delete("");
                const R = [...y.values()];
                return n.set(L, R), R
            }
            intersects(U, F) {
                if (!(U instanceof i)) throw new TypeError("a Range is required");
                return this.set.some(L => S(L, F) && U.set.some(G => S(G, F) && L.every(M => G.every(_ => M.intersects(_, F)))))
            }
            test(U) {
                if (!U) return !1;
                if (typeof U == "string") try {
                    U = new c(U, this.options)
                } catch {
                    return !1
                }
                for (let F = 0; F < this.set.length; F++)
                    if (N(this.set[F], U, this.options)) return !0;
                return !1
            }
        }
        range = i;
        const r = lruCache,
            n = new r({
                max: 1e3
            }),
            s = parseOptions_1,
            a = requireComparator(),
            o = debug_1,
            c = semver,
            {
                re: p,
                t: h,
                comparatorTrimReplace: u,
                tildeTrimReplace: l,
                caretTrimReplace: v
            } = re$1.exports,
            w = P => P.value === "<0.0.0-0",
            m = P => P.value === "",
            S = (P, U) => {
                let F = !0;
                const L = P.slice();
                let G = L.pop();
                for (; F && L.length;) F = L.every(M => G.intersects(M, U)), G = L.pop();
                return F
            },
            C = (P, U) => (o("comp", P, U), P = B(P, U), o("caret", P), P = x(P, U), o("tildes", P), P = f(P, U), o("xrange", P), P = g(P, U), o("stars", P), P),
            O = P => !P || P.toLowerCase() === "x" || P === "*",
            x = (P, U) => P.trim().split(/\s+/).map(F => I(F, U)).join(" "),
            I = (P, U) => {
                const F = U.loose ? p[h.TILDELOOSE] : p[h.TILDE];
                return P.replace(F, (L, G, M, _, A) => {
                    o("tilde", P, L, G, M, _, A);
                    let y;
                    return O(G) ? y = "" : O(M) ? y = `>=${G}.0.0 <${+G+1}.0.0-0` : O(_) ? y = `>=${G}.${M}.0 <${G}.${+M+1}.0-0` : A ? (o("replaceTilde pr", A), y = `>=${G}.${M}.${_}-${A} <${G}.${+M+1}.0-0`) : y = `>=${G}.${M}.${_} <${G}.${+M+1}.0-0`, o("tilde return", y), y
                })
            },
            B = (P, U) => P.trim().split(/\s+/).map(F => b(F, U)).join(" "),
            b = (P, U) => {
                o("caret", P, U);
                const F = U.loose ? p[h.CARETLOOSE] : p[h.CARET],
                    L = U.includePrerelease ? "-0" : "";
                return P.replace(F, (G, M, _, A, y) => {
                    o("caret", P, G, M, _, A, y);
                    let k;
                    return O(M) ? k = "" : O(_) ? k = `>=${M}.0.0${L} <${+M+1}.0.0-0` : O(A) ? M === "0" ? k = `>=${M}.${_}.0${L} <${M}.${+_+1}.0-0` : k = `>=${M}.${_}.0${L} <${+M+1}.0.0-0` : y ? (o("replaceCaret pr", y), M === "0" ? _ === "0" ? k = `>=${M}.${_}.${A}-${y} <${M}.${_}.${+A+1}-0` : k = `>=${M}.${_}.${A}-${y} <${M}.${+_+1}.0-0` : k = `>=${M}.${_}.${A}-${y} <${+M+1}.0.0-0`) : (o("no pr"), M === "0" ? _ === "0" ? k = `>=${M}.${_}.${A}${L} <${M}.${_}.${+A+1}-0` : k = `>=${M}.${_}.${A}${L} <${M}.${+_+1}.0-0` : k = `>=${M}.${_}.${A} <${+M+1}.0.0-0`), o("caret return", k), k
                })
            },
            f = (P, U) => (o("replaceXRanges", P, U), P.split(/\s+/).map(F => d(F, U)).join(" ")),
            d = (P, U) => {
                P = P.trim();
                const F = U.loose ? p[h.XRANGELOOSE] : p[h.XRANGE];
                return P.replace(F, (L, G, M, _, A, y) => {
                    o("xRange", P, L, G, M, _, A, y);
                    const k = O(M),
                        R = k || O(_),
                        D = R || O(A),
                        H = D;
                    return G === "=" && H && (G = ""), y = U.includePrerelease ? "-0" : "", k ? G === ">" || G === "<" ? L = "<0.0.0-0" : L = "*" : G && H ? (R && (_ = 0), A = 0, G === ">" ? (G = ">=", R ? (M = +M + 1, _ = 0, A = 0) : (_ = +_ + 1, A = 0)) : G === "<=" && (G = "<", R ? M = +M + 1 : _ = +_ + 1), G === "<" && (y = "-0"), L = `${G+M}.${_}.${A}${y}`) : R ? L = `>=${M}.0.0${y} <${+M+1}.0.0-0` : D && (L = `>=${M}.${_}.0${y} <${M}.${+_+1}.0-0`), o("xRange return", L), L
                })
            },
            g = (P, U) => (o("replaceStars", P, U), P.trim().replace(p[h.STAR], "")),
            E = (P, U) => (o("replaceGTE0", P, U), P.trim().replace(p[U.includePrerelease ? h.GTE0PRE : h.GTE0], "")),
            T = P => (U, F, L, G, M, _, A, y, k, R, D, H, q) => (O(L) ? F = "" : O(G) ? F = `>=${L}.0.0${P?"-0":""}` : O(M) ? F = `>=${L}.${G}.0${P?"-0":""}` : _ ? F = `>=${F}` : F = `>=${F}${P?"-0":""}`, O(k) ? y = "" : O(R) ? y = `<${+k+1}.0.0-0` : O(D) ? y = `<${k}.${+R+1}.0-0` : H ? y = `<=${k}.${R}.${D}-${H}` : P ? y = `<${k}.${R}.${+D+1}-0` : y = `<=${y}`, `${F} ${y}`.trim()),
            N = (P, U, F) => {
                for (let L = 0; L < P.length; L++)
                    if (!P[L].test(U)) return !1;
                if (U.prerelease.length && !F.includePrerelease) {
                    for (let L = 0; L < P.length; L++)
                        if (o(P[L].semver), P[L].semver !== a.ANY && P[L].semver.prerelease.length > 0) {
                            const G = P[L].semver;
                            if (G.major === U.major && G.minor === U.minor && G.patch === U.patch) return !0
                        } return !1
                }
                return !0
            };
        return range
    }
    const Range = requireRange(),
        satisfies = (i, r, n) => {
            try {
                r = new Range(r, n)
            } catch {
                return !1
            }
            return r.test(i)
        };
    var satisfies_1 = satisfies;

    function buf2hex(i) {
        return [...i].map(r => r.toString(16).padStart(2, "0")).join("")
    }

    function contains(i, r) {
        for (let n = 0; n < i.length; n += 1)
            if (i[n] === r) return !0;
        return !1
    }
    class ValidationError$1 extends Error {
        constructor(r = "") {
            super(r), this.name = "ValidationError"
        }
    }
    const baseSize = 45,
        baseSizeSquared = 2025,
        chunkSize = 2,
        encodedChunkSize = 3,
        byteSize = 256,
        encoding = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
    let decoding;

    function decode$2(i) {
        if (i == null) throw new Error("utf8StringArg is null or undefined.");
        if (i.length === 0) return [];
        const r = i.length % encodedChunkSize;
        if (r === 1) throw new Error("utf8StringArg has incorrect length.");
        if (decoding === void 0) {
            decoding = {};
            for (let p = 0; p < encoding.length; p += 1) decoding[encoding[p]] = p
        }
        const n = new Array(i.length);
        for (let p = 0; p < i.length; p += 1) {
            const h = decoding[i[p]];
            if (h === void 0) throw new Error("invalid character at position ".concat(p).concat("."));
            n[p] = h
        }
        const s = Math.trunc(n.length / encodedChunkSize),
            a = new Uint8Array(s * chunkSize + (r === chunkSize ? 1 : 0));
        let o = 0;
        const c = s * encodedChunkSize;
        for (let p = 0; p < c;) {
            let h = n[p];
            p += 1, h += baseSize * n[p], p += 1, h += baseSizeSquared * n[p], p += 1, a[o] = Math.trunc(h / byteSize), o += 1, a[o] = h % byteSize, o += 1
        }
        return r === 0 || (a[a.length - 1] = n[n.length - 2] + baseSize * n[n.length - 1]), a
    }

    function encode$1(i) {
        let r = "";
        const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            s = new Uint8Array(i),
            {
                byteLength: a
            } = s,
            o = a % 3,
            c = a - o;
        let p, h, u, l, v;
        for (let w = 0; w < c; w += 3) v = s[w] << 16 | s[w + 1] << 8 | s[w + 2], p = (v & 16515072) >> 18, h = (v & 258048) >> 12, u = (v & 4032) >> 6, l = v & 63, r += n[p] + n[h] + n[u] + n[l];
        return o === 1 ? (v = s[c], p = (v & 252) >> 2, h = (v & 3) << 4, r += `${n[p]+n[h]}==`) : o === 2 && (v = s[c] << 8 | s[c + 1], p = (v & 64512) >> 10, h = (v & 1008) >> 4, u = (v & 15) << 2, r += `${n[p]+n[h]+n[u]}=`), r
    }
    const POW_2_24 = 5960464477539063e-23,
        POW_2_32 = 4294967296,
        POW_2_53 = 9007199254740992;

    function encode(i) {
        let r = new ArrayBuffer(256),
            n = new DataView(r),
            s, a = 0;

        function o(x) {
            let I = r.byteLength;
            const B = a + x;
            for (; I < B;) I <<= 1;
            if (I !== r.byteLength) {
                const b = n;
                r = new ArrayBuffer(I), n = new DataView(r);
                const f = a + 3 >> 2;
                for (let d = 0; d < f; d += 1) n.setUint32(d << 2, b.getUint32(d << 2))
            }
            return s = x, n
        }

        function c() {
            a += s
        }

        function p(x) {
            o(8).setFloat64(a, x), c()
        }

        function h(x) {
            o(1).setUint8(a, x), c()
        }

        function u(x) {
            const I = o(x.length);
            for (let B = 0; B < x.length; B += 1) I.setUint8(a + B, x[B]);
            c()
        }

        function l(x) {
            o(2).setUint16(a, x), c()
        }

        function v(x) {
            o(4).setUint32(a, x), c()
        }

        function w(x) {
            const I = x % POW_2_32,
                B = (x - I) / POW_2_32,
                b = o(8);
            b.setUint32(a, B), b.setUint32(a + 4, I), c()
        }

        function m(x, I) {
            I < 24 ? h(x << 5 | I) : I < 256 ? (h(x << 5 | 24), h(I)) : I < 65536 ? (h(x << 5 | 25), l(I)) : I < 4294967296 ? (h(x << 5 | 26), v(I)) : (h(x << 5 | 27), w(I))
        }

        function S(x) {
            if (x === !1) {
                h(244);
                return
            }
            if (x === !0) {
                h(245);
                return
            }
            if (x === null) {
                h(246);
                return
            }
            if (x === void 0) {
                h(247);
                return
            }
            let I;
            const B = [];
            switch (typeof x) {
                case "number":
                    if (Math.floor(x) === x) {
                        if (x >= 0 && x <= POW_2_53) {
                            m(0, x);
                            break
                        }
                        if (-POW_2_53 <= x && x < 0) {
                            m(1, -(x + 1));
                            break
                        }
                    }
                    h(251), p(x);
                    break;
                case "string":
                    for (let b = 0; b < x.length; b += 1) {
                        let f = x.charCodeAt(b);
                        f < 128 ? B.push(f) : f < 2048 ? (B.push(192 | f >> 6), B.push(128 | f & 63)) : f < 55296 ? (B.push(224 | f >> 12), B.push(128 | f >> 6 & 63), B.push(128 | f & 63)) : (f = (f & 1023) << 10, f |= x.charCodeAt(b += 1) & 1023, f += 65536, B.push(240 | f >> 18), B.push(128 | f >> 12 & 63), B.push(128 | f >> 6 & 63), B.push(128 | f & 63))
                    }
                    m(3, B.length), u(B);
                    break;
                default:
                    if (Array.isArray(x)) {
                        I = x.length, m(4, I);
                        for (let b = 0; b < I; b += 1) S(x[b])
                    } else if (x instanceof Uint8Array) m(2, x.length), u(x);
                    else {
                        const b = Object.keys(x);
                        I = b.length, m(5, I);
                        for (let f = 0; f < I; f += 1) {
                            const d = b[f];
                            S(d), S(x[d])
                        }
                    }
            }
        }
        if (S(i), "slice" in r) return r.slice(0, a);
        const C = new ArrayBuffer(a),
            O = new DataView(C);
        for (let x = 0; x < a; x += 1) O.setUint8(x, n.getUint8(x));
        return C
    }

    function decode$1(i, r = s => s, n = () => {}) {
        const s = new DataView(i);
        let a = 0;

        function o(b, f) {
            return a += b, f
        }

        function c(b) {
            return o(b, new Uint8Array(i, a, b))
        }

        function p() {
            return o(1, s.getUint8(a))
        }

        function h() {
            return o(2, s.getUint16(a))
        }

        function u() {
            return o(4, s.getUint32(a))
        }

        function l() {
            return u() * POW_2_32 + u()
        }

        function v() {
            const b = new ArrayBuffer(4),
                f = new DataView(b),
                d = h(),
                g = d & 32768;
            let E = d & 31744;
            const T = d & 1023;
            if (E === 31744) E = 261120;
            else if (E !== 0) E += 114688;
            else if (T !== 0) return (g ? -1 : 1) * T * POW_2_24;
            return f.setUint32(0, g << 16 | E << 13 | T << 13), f.getFloat32(0)
        }

        function w() {
            return o(4, s.getFloat32(a))
        }

        function m() {
            return o(8, s.getFloat64(a))
        }

        function S() {
            return s.getUint8(a) !== 255 ? !1 : (a += 1, !0)
        }

        function C(b) {
            if (b < 24) return b;
            if (b === 24) return p();
            if (b === 25) return h();
            if (b === 26) return u();
            if (b === 27) return l();
            if (b === 31) return -1;
            throw new Error("invalid length encoding")
        }

        function O(b) {
            const f = p();
            if (f === 255) return -1;
            const d = C(f & 31);
            if (d < 0 || f >> 5 !== b) throw new Error("invalid indefinite length element");
            return d
        }

        function x(b, f) {
            for (let d = 0, g = f; d < g; d += 1) {
                let E = p();
                E & 128 && (E < 224 ? (E = (E & 31) << 6 | p() & 63, g -= 1) : E < 240 ? (E = (E & 15) << 12 | (p() & 63) << 6 | p() & 63, g -= 2) : (E = (E & 15) << 18 | (p() & 63) << 12 | (p() & 63) << 6 | p() & 63, g -= 3)), E < 65536 ? b.push(E) : (E -= 65536, b.push(55296 | E >> 10), b.push(56320 | E & 1023))
            }
        }

        function I() {
            const b = p(),
                f = b >> 5,
                d = b & 31;
            let g, E;
            if (f === 7) switch (d) {
                case 25:
                    return v();
                case 26:
                    return w();
                case 27:
                    return m()
            }
            if (E = C(d), E < 0 && (f < 2 || f > 6)) throw new Error("invalid length");
            const T = [];
            let N;
            const P = {};
            switch (f) {
                case 0:
                    return E;
                case 1:
                    return -1 - E;
                case 2:
                    if (E < 0) {
                        const U = [];
                        let F = 0;
                        for (;
                            (E = O(f)) >= 0;) F += E, U.push(c(E));
                        const L = new Uint8Array(F);
                        let G = 0;
                        for (g = 0; g < U.length; g += 1) L.set(U[g], G), G += U[g].length;
                        return L
                    }
                    return c(E);
                case 3:
                    if (E < 0)
                        for (;
                            (E = O(f)) >= 0;) x(T, E);
                    else x(T, E);
                    return String.fromCharCode.apply(null, T);
                case 4:
                    if (E < 0)
                        for (N = []; !S();) N.push(I());
                    else
                        for (N = new Array(E), g = 0; g < E; g += 1) N[g] = I();
                    return N;
                case 5:
                    for (g = 0; g < E || E < 0 && !S(); g += 1) {
                        const U = I();
                        P[U] = I()
                    }
                    return P;
                case 6:
                    return r(I(), E);
                case 7:
                    switch (E) {
                        case 20:
                            return !1;
                        case 21:
                            return !0;
                        case 22:
                            return null;
                        case 23:
                            return;
                        default:
                            return n(E)
                    }
            }
            return null
        }
        const B = I();
        if (a !== i.byteLength) throw new Error("remaining bytes");
        return B
    }
    const ALGO_ECDSA_256 = -7,
        ALGO_RSA_PSS_256 = -37,
        COSE_KEY_KEYTYPE = 1,
        COSE_HEADER_KID = 4;

    function decode(i) {
        const r = decode$1(new Uint8Array(i).buffer);
        if (r === null || !Array.isArray(r) || r.length !== 4) throw new Error("invalid sign1 structure");
        let n = r[0];
        if (n === null) throw new Error("invalid sign1 structure");
        let s = {};
        if (n.length > 0 && (s = decode$1(new Uint8Array(n).buffer), (s === null || s.length === 0) && (n = new Uint8Array)), s[COSE_KEY_KEYTYPE] !== ALGO_ECDSA_256 && s[COSE_KEY_KEYTYPE] !== ALGO_RSA_PSS_256) throw new Error("invalid sign1 algo, expected ECDSA SHA-256 or RSASSA-PSS SHA-256");
        let a = s[COSE_HEADER_KID];
        if (!a) {
            if (r[1] === null && typeof r[1] != "object") throw new Error("invalid sign1 structure");
            a = r[1][COSE_HEADER_KID]
        }
        if (!a) throw new Error("sign1 message missing KID");
        if (r[2] === null || r[3] === null) throw new Error("invalid sign1 structure");
        return {
            protected: n,
            unprotected: r[1],
            params: {
                kty: s[COSE_KEY_KEYTYPE],
                kid: a
            },
            content: r[2],
            signature: r[3]
        }
    }

    function verifyWithKey(i, r, n, s) {
        return new Promise((a, o) => {
            if (!s || s.length === 0) {
                o(new ValidationError$1("MISSING_KEY"));
                return
            }
            const c = s[0];
            let p;
            c.kty === "EC" ? p = {
                name: "ECDSA",
                namedCurve: c.crv
            } : p = {
                name: "RSA-PSS",
                hash: {
                    name: "SHA-256"
                }
            }, window.crypto.subtle.importKey("jwk", c, p, !1, ["verify"]).then(h => {
                window.crypto.subtle.verify(n, h, r, i).then(u => {
                    if (u || s.length === 1) {
                        a({
                            valid: u,
                            publicKey: c
                        });
                        return
                    }
                    verifyWithKey(i, r, n, s.slice(1)).then(l => {
                        a(l)
                    }).catch(l => {
                        o(l)
                    })
                }).catch(u => {
                    if (s.length === 1) {
                        console.warn(u), o(new ValidationError$1("VERIFY_ERROR"));
                        return
                    }
                    verifyWithKey(i, r, n, s.slice(1)).then(l => {
                        a(l)
                    }).catch(l => {
                        o(l)
                    })
                })
            }).catch(h => {
                if (s.length === 1) {
                    console.warn(h), o(new ValidationError$1("INVALID_KEY"));
                    return
                }
                verifyWithKey(i, r, n, s.slice(1)).then(u => {
                    a(u)
                }).catch(u => {
                    o(u)
                })
            })
        })
    }

    function verify(i, r) {
        let n;
        try {
            n = encode(["Signature1", i.protected, new Uint8Array(0), i.content])
        } catch (a) {
            return Promise.reject(a)
        }
        let s;
        return i.params.kty === ALGO_ECDSA_256 ? s = {
            name: "ECDSA",
            hash: {
                name: "SHA-256"
            }
        } : s = {
            name: "RSA-PSS",
            saltLength: 32
        }, verifyWithKey(n, i.signature, s, r)
    }

    function sha256(i) {
        return new Promise((r, n) => {
            if (i == null) {
                r(null);
                return
            }
            let s = i;
            typeof i == "string" && (s = new window.TextEncoder().encode(i)), window.crypto.subtle.digest("SHA-256", s).then(a => {
                if (a.byteLength !== 32) {
                    n(new Error("Invalid SHA-256 digest length"));
                    return
                }
                r(encode$1(a.slice(0, 16)))
            }).catch(n)
        })
    }
    class ValidationResult {
        constructor(r, n, s, a = null) {
            this.valid = r, this.content = n, this.hash = s, this.reason = a
        }
    }
    const DGC_CERTIFICATE_EXTENSION_TEST_V0 = "1.3.6.1.4.1.0.1847.2021.1.1",
        DGC_CERTIFICATE_EXTENSION_VACCINATION_V0 = "1.3.6.1.4.1.0.1847.2021.1.2",
        DGC_CERTIFICATE_EXTENSION_RECOVERY_V0 = "1.3.6.1.4.1.0.1847.2021.1.3",
        DGC_CERTIFICATE_EXTENSION_TEST_V1 = "1.3.6.1.4.1.1847.2021.1.1",
        DGC_CERTIFICATE_EXTENSION_VACCINATION_V1 = "1.3.6.1.4.1.1847.2021.1.2",
        DGC_CERTIFICATE_EXTENSION_RECOVERY_V1 = "1.3.6.1.4.1.1847.2021.1.3";
    dayjs.extend(utc);
    const uaDobDateFormat$2 = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec$2(i, r, n) {
        const s = i,
            a = "t" in (s || {}) && Array.isArray(s.t) && s.t.length > 0,
            o = "v" in (s || {}) && Array.isArray(s.v) && s.v.length > 0,
            c = "r" in (s || {}) && Array.isArray(s.r) && s.r.length > 0;
        if (s && s.dob) {
            const u = s.dob.indexOf("T");
            u >= 0 && (s.dob = s.dob.substr(0, u));
            const l = s.dob.match(uaDobDateFormat$2);
            l !== null && l.length === 4 && (s.dob = `${l[3]}-${l[2]}-${l[1]}`)
        }
        if (o) {
            for (let u = 0; u < s.v.length; u += 1) {
                const l = s.v[u];
                if (l.dt) {
                    const v = l.dt.indexOf("T");
                    v >= 0 && (l.dt = l.dt.substr(0, v))
                }
            }
            "t" in s && delete s.t, "r" in s && delete s.r
        }
        if (c) {
            for (let u = 0; u < s.r.length; u += 1) {
                const l = s.r[u];
                if (l.fr) {
                    const v = l.fr.indexOf("T");
                    v >= 0 && (l.fr = l.fr.substr(0, v))
                }
                if (l.df) {
                    const v = l.df.indexOf("T");
                    v >= 0 && (l.df = l.df.substr(0, v))
                }
                if (l.du) {
                    const v = l.du.indexOf("T");
                    v >= 0 && (l.du = l.du.substr(0, v))
                }
            }
            "t" in s && delete s.t, "v" in s && delete s.v
        }
        a && ("r" in s && delete s.r, "v" in s && delete s.v);
        const p = dayjs.utc();
        if (a && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (o && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (c && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (o)
            for (let u = 0; u < s.v.length; u += 1) {
                const l = s.v[u],
                    v = dayjs.utc(l.dt);
                if (!v.isValid() || v.isAfter(p)) return new ValidationResult(!1, s, r, "DT_IN_FUTURE")
            }
        if (a)
            for (let u = 0; u < s.t.length; u += 1) {
                const l = s.t[u],
                    v = dayjs.utc(l.sc);
                if (!v.isValid() || v.isAfter(p)) return new ValidationResult(!1, s, r, "SC_IN_FUTURE");
                if (l.dr) {
                    const w = dayjs.utc(l.dr);
                    if (!w.isValid() || w.isAfter(p)) return new ValidationResult(!1, s, r, "DR_IN_FUTURE")
                }
            }
        if (c)
            for (let u = 0; u < s.r.length; u += 1) {
                const l = s.r[u],
                    v = dayjs.utc(l.fr);
                if (!v.isValid() || v.isAfter(p)) return new ValidationResult(!1, s, r, "FR_IN_FUTURE");
                if (!dayjs.utc(l.df).isValid()) return new ValidationResult(!1, s, r, "INVALID_DF");
                if (!dayjs.utc(l.du).isValid()) return new ValidationResult(!1, s, r, "INVALID_DU")
            }
        return s.dob ? dayjs.utc(s.dob).isValid() ? new ValidationResult(!0, s, r) : new ValidationResult(!1, s, r, "INVALID_DOB") : new ValidationResult(!1, s, r, "MISSING_DOB")
    }
    dayjs.extend(utc);
    const uaDobDateFormat$1 = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec$1(i, r, n) {
        const s = i,
            a = dayjs.utc(),
            o = "t" in (s || {}) && Array.isArray(s.t) && s.t.length > 0,
            c = "v" in (s || {}) && Array.isArray(s.v) && s.v.length > 0,
            p = "r" in (s || {}) && Array.isArray(s.r) && s.r.length > 0;
        if (s && s.dob) {
            const u = s.dob.match(uaDobDateFormat$1);
            u !== null && u.length === 4 && (s.dob = `${u[3]}-${u[2]}-${u[1]}`)
        }
        if (o && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (c && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (p && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (c)
            for (let u = 0; u < s.v.length; u += 1) {
                const l = s.v[u],
                    v = dayjs.utc(l.dt);
                if (!v.isValid() || v.isAfter(a)) return new ValidationResult(!1, s, r, "DT_IN_FUTURE")
            }
        if (o)
            for (let u = 0; u < s.t.length; u += 1) {
                const l = s.t[u],
                    v = dayjs.utc(l.sc);
                if (!v.isValid() || v.isAfter(a)) return new ValidationResult(!1, s, r, "SC_IN_FUTURE")
            }
        if (p)
            for (let u = 0; u < s.r.length; u += 1) {
                const l = s.r[u],
                    v = dayjs.utc(l.fr);
                if (!v.isValid() || v.isAfter(a)) return new ValidationResult(!1, s, r, "FR_IN_FUTURE");
                if (!dayjs.utc(l.df).isValid()) return new ValidationResult(!1, s, r, "INVALID_DF");
                if (!dayjs.utc(l.du).isValid()) return new ValidationResult(!1, s, r, "INVALID_DU")
            }
        return s.dob ? dayjs.utc(s.dob).isValid() ? new ValidationResult(!0, s, r) : new ValidationResult(!1, s, r, "INVALID_DOB") : new ValidationResult(!1, s, r, "MISSING_DOB")
    }
    dayjs.extend(utc);
    const uaDobDateFormat = /^(\d{2})\.(\d{2})\.(\d{4})\.?$/;

    function validateSpec(i, r, n) {
        const s = i,
            a = dayjs.utc(),
            o = "t" in (s || {}) && Array.isArray(s.t) && s.t.length > 0,
            c = "v" in (s || {}) && Array.isArray(s.v) && s.v.length > 0,
            p = "r" in (s || {}) && Array.isArray(s.r) && s.r.length > 0;
        if (s && s.dob) {
            const h = s.dob.match(uaDobDateFormat);
            h !== null && h.length === 4 && (s.dob = `${h[3]}-${h[2]}-${h[1]}`)
        }
        if (o && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_TEST_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (c && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_VACCINATION_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (p && !(!n.extensions || n.extensions.length === 0 || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V0) || contains(n.extensions, DGC_CERTIFICATE_EXTENSION_RECOVERY_V1))) return new ValidationResult(!1, s, r, "INVALID_CERT_OID");
        if (c)
            for (let h = 0; h < s.v.length; h += 1) {
                const u = s.v[h],
                    l = dayjs.utc(u.dt);
                if (!l.isValid() || l.isAfter(a)) return new ValidationResult(!1, s, r, "DT_IN_FUTURE")
            }
        if (o)
            for (let h = 0; h < s.t.length; h += 1) {
                const u = s.t[h],
                    l = dayjs.utc(u.sc);
                if (!l.isValid() || l.isAfter(a)) return new ValidationResult(!1, s, r, "SC_IN_FUTURE")
            }
        if (p)
            for (let h = 0; h < s.r.length; h += 1) {
                const u = s.r[h],
                    l = dayjs.utc(u.fr);
                if (!l.isValid() || l.isAfter(a)) return new ValidationResult(!1, s, r, "FR_IN_FUTURE");
                if (!dayjs.utc(u.df).isValid()) return new ValidationResult(!1, s, r, "INVALID_DF");
                if (!dayjs.utc(u.du).isValid()) return new ValidationResult(!1, s, r, "INVALID_DU")
            }
        return s.dob && !dayjs.utc(s.dob).isValid() ? new ValidationResult(!1, s, r, "INVALID_DOB") : new ValidationResult(!0, s, r)
    }
    const CWT_KEY_ISS = 1,
        CWT_KEY_EXP = 4,
        CWT_KEY_IAT = 6,
        CWT_KEY_HCERT = -260,
        CWT_SUBKEY_HCERT_EU_DGCv1 = 1;
    dayjs.extend(utc);

    function dataValidation(i, r) {
        if (!r) return new ValidationResult(!1, i.certificate, i.hash, "MISSING_PUBKEY");
        const n = dayjs.utc().unix();
        return n > i.exp ? new ValidationResult(!1, i.certificate, i.hash, "CERT_EXPIRED") : n < i.iat ? new ValidationResult(!1, i.certificate, i.hash, "CERT_ISSUED_BEFORE_IAT") : i.iat < r.nbf ? new ValidationResult(!1, i.certificate, i.hash, "CERT_ISSUED_AFTER_NBF") : i.iat > r.exp ? new ValidationResult(!1, i.certificate, i.hash, "CERT_ISSUED_AFTER_EXP") : satisfies_1(i.certificate.ver, ">=1.0.0 <1.2.0") ? validateSpec$2(i.certificate, i.hash, r) : satisfies_1(i.certificate.ver, "1.2.x") ? validateSpec$1(i.certificate, i.hash, r) : satisfies_1(i.certificate.ver, "1.3.x") ? validateSpec(i.certificate, i.hash, r) : (console.warn(`Unsupported certificate version: ${i.certificate.v}`), new ValidationResult(!1, i.certificate, i.hash, "UNSUPPORTED_VERSION"))
    }

    function validate$1(i, r) {
        return new Promise((n, s) => {
            i || s(new ValidationError$1("EMPTY_CERTIFICATE"));
            let a = i;
            const o = a.indexOf(":");
            if (o >= 0 && a.substr(0, 2) === "HC") {
                if (a.substr(0, o + 1) !== "HC1:") {
                    s(new ValidationError$1("INVALID_PREFIX"));
                    return
                }
                a = a.substr(o + 1)
            }
            let c;
            try {
                c = decode$2(a)
            } catch {
                s(new ValidationError$1("INVALID_BASE45"));
                return
            }
            let p;
            if (c[0] === 120) try {
                if (p = inflate_1(c), !p || p.byteLength === 0) {
                    s(new ValidationError$1("INVALID_ZLIB_COMPRESSION"));
                    return
                }
            } catch (u) {
                console.warn(u), s(new ValidationError$1("INVALID_ZLIB_COMPRESSION"));
                return
            } else p = c;
            let h;
            try {
                h = decode(p)
            } catch (u) {
                console.warn(u), s(new ValidationError$1("INVALID_COSE"));
                return
            }
            r(buf2hex(h.params.kid)).then(u => {
                verify(h, u).then(l => {
                    if (!l.valid) {
                        s(new ValidationError$1("INVALID_SIGNATURE"));
                        return
                    }
                    let v;
                    try {
                        v = decode$1(new Uint8Array(h.content).buffer)
                    } catch (O) {
                        console.warn(O), s(new ValidationError$1("INVALID_CBOR"));
                        return
                    }
                    if (v === null || !(CWT_KEY_HCERT in v) || !(CWT_SUBKEY_HCERT_EU_DGCv1 in v[CWT_KEY_HCERT])) {
                        s(new ValidationError$1("NOT_HCERT"));
                        return
                    }
                    const w = v[CWT_KEY_HCERT][CWT_SUBKEY_HCERT_EU_DGCv1];
                    let m = null,
                        S = null;
                    "r" in (w || {}) && Array.isArray(w.r) && w.r.length > 0 ? (m = w.r[0].ci, S = w.r[0].co) : "v" in (w || {}) && Array.isArray(w.v) && w.v.length > 0 ? (m = w.v[0].ci, S = w.v[0].co) : "t" in (w || {}) && Array.isArray(w.t) && w.t.length > 0 && (m = w.t[0].ci, S = w.t[0].co);
                    let C = null;
                    h.params.kty === ALGO_ECDSA_256 ? C = h.signature.slice(0, h.signature.byteLength / 2) : C = h.signature;
                    try {
                        Promise.all([sha256(m), sha256(S + m), sha256(C)]).then(O => {
                            n(dataValidation({
                                iss: v[CWT_KEY_ISS],
                                iat: v[CWT_KEY_IAT],
                                exp: v[CWT_KEY_EXP],
                                certificate: w,
                                hash: {
                                    uci: O[0],
                                    countryCodeUci: O[1],
                                    signature: O[2],
                                    kid: encode$1(h.params.kid),
                                    country: S
                                }
                            }, l.publicKey))
                        }).catch(O => {
                            s(O)
                        })
                    } catch (O) {
                        s(O)
                    }
                }).catch(l => {
                    s(new ValidationError$1(l.message))
                })
            }).catch(u => {
                s(u)
            })
        })
    }
    const baseUrl = window.baseUrl || "/",
        lang = window.language || "lv",
        verifyKeyCacheTime = 6 * 60 * 60,
        rulesCacheTime = 60 * 60;
    e.WORKER_PATH = baseUrl + "qr-scanner-worker.min.js", pdf_1.GlobalWorkerOptions.workerSrc = baseUrl + "pdf.worker.min.js", dayjs.extend(utc);
    const localStorageEx = {
            get: function(i) {
                const r = window.localStorage.getItem(i);
                if (r !== null) {
                    let n = {
                        payload: null
                    };
                    try {
                        n = JSON.parse(lzString.exports.decompressFromUTF16(r))
                    } catch {
                        return null
                    }
                    return n.payload != null && n.expiry != null && new Date > Date.parse(n.expiry) ? (window.localStorage.removeItem(i), null) : n.payload
                }
                return null
            },
            set: function(i, r, n) {
                if (r === null) {
                    window.localStorage.removeItem(i);
                    return
                }
                const s = new Date;
                s.setSeconds(s.getSeconds() + n), window.localStorage.setItem(i, lzString.exports.compressToUTF16(JSON.stringify({
                    payload: r,
                    expiry: s
                })))
            }
        },
        codeProcessing = {};
    var verificationKeys = localStorageEx.get("verificationKeys") || {},
        devliceList = null,
        rules = localStorageEx.get("rules") || null;
    localStorageEx.get("valueset");
    var selectedRole = null,
        selectedCamera = null,
        qrScanner = null;

    function loadRules() {
        return new Promise((i, r) => {
            if (rules === null) {
                $.ajax({
                    url: baseUrl + "verify/rules.json",
                    type: "GET"
                }).done(n => {
                    rules = n, localStorageEx.set("rules", rules, rulesCacheTime), i(rules)
                }).fail(() => {
                    r(new Error("can not load rules"))
                });
                return
            }
            i(rules)
        })
    }

    function verifyRevoked(i) {
        return new Promise((r, n) => {
            $.ajax({
                url: baseUrl + "verify/revoked",
                type: "POST",
                dataType: "json",
                contentType: "application/json",
                data: JSON.stringify(i)
            }).done(s => {
                r((s || {}).revoked || !1)
            }).fail(() => {
                n(new Error("can not verify certificate revocation status"))
            })
        })
    }

    function isEmpty(i) {
        for (var r in i)
            if (i.hasOwnProperty(r)) return !1;
        return !0
    }

    function preloadKeys() {
        return new Promise(i => {
            if (isEmpty(verificationKeys)) {
                $.ajax({
                    url: baseUrl + "verify/keys",
                    type: "GET"
                }).done(r => {
                    verificationKeys = r, localStorageEx.set("verificationKeys", verificationKeys, verifyKeyCacheTime), i()
                }).fail(() => {
                    console.warn("key preload failed")
                });
                return
            }
            i()
        })
    }

    function getActiveRoles() {
        return new Promise((i, r) => {
            loadRules().then(n => {
                i(getRoles(n, lang))
            }).catch(n => {
                r(n)
            })
        })
    }

    function fillValues(i, r) {
        if (i.nodeType === 3)
            for (let n in r) {
                const s = i.data.replace(new RegExp("{{" + n + "}}", "g"), r[n]);
                s != i.data && (i.data = s)
            } else if (i.nodeType === 1)
                for (let n = 0; n < i.childNodes.length; n++) fillValues(i.childNodes[n], r)
    }

    function templateRepeat(i, r) {
        const n = i.cloneNode(!0);
        return n.id = "", n.style.display = "block", r.parentNode.insertBefore(n, r.nextSibling), n
    }

    function renderRoleList(i, r, n) {
        return new Promise((s, a) => {
            getActiveRoles().then(o => {
                for (var c = o.length - 1; c >= 0; c -= 1) {
                    const p = templateRepeat(i, r);
                    fillValues(p, {
                        roleName: o[c].businessDescription
                    }), p.dataset.code = o[c].code, p.dataset.displayname = o[c].businessDescription, n && p.addEventListener("click", n)
                }
                s()
            }).catch(o => {
                a(o)
            })
        })
    }

    function selectRole(i) {
        selectedRole = i
    }

    function keyProvider(i) {
        return new Promise((r, n) => {
            if (!(i in verificationKeys)) {
                $.ajax({
                    url: baseUrl + "verify/key?kid=" + i,
                    type: "GET"
                }).done(s => {
                    verificationKeys[i] = s, localStorageEx.set("verificationKeys", verificationKeys, verifyKeyCacheTime), r(s)
                }).fail(s => {
                    if (s.status === 404) {
                        n(new ValidationError("UNKNOWN_SIGNING_KEY"));
                        return
                    }
                    n(new Error("error while requesting validation key: " + s.statusText))
                });
                return
            }
            r(verificationKeys[i])
        })
    }
    class ValidationError extends Error {
        constructor(r) {
            super(r), this.name = "ValidationError"
        }
    }

    function validate(i) {
        return new Promise((r, n) => {
            if (i in codeProcessing) {
                n(new Error("ALREADY_IN_PROGRESS"));
                return
            }
            codeProcessing[i] = !0, validate$1(i, keyProvider).then(s => {
                if (!s.valid) {
                    s.reason === "CERT_EXPIRED" ? r({
                        valid: !1,
                        reason: s.reason
                    }) : r({
                        valid: !1,
                        reason: "INVALID_CODE"
                    }), delete codeProcessing[i];
                    return
                }
                verifyRevoked(s.hash).then(a => {
                    if (a) {
                        r({
                            valid: !1,
                            reason: "INVALID_BUSINESS",
                            reasonDetails: "CERTIFICATE_CANCELED",
                            reasonDescription: "Sertifik\u0101ts ir anul\u0113ts",
                            content: s.content
                        }), delete codeProcessing[i];
                        return
                    }
                    loadRules().then(o => {
                        try {
                            const c = validate$2(s.content, [selectedRole], o, lang);
                            r({
                                valid: c.valid,
                                reason: c.valid ? null : "INVALID_BUSINESS",
                                reasonDetails: c.valid ? null : c.reason,
                                reasonDescription: c.valid ? null : c.reasonBusinessDescription,
                                content: s.content
                            })
                        } catch (c) {
                            n(c)
                        }
                        delete codeProcessing[i]
                    }).catch(o => {
                        n(o), delete codeProcessing[i]
                    })
                }).catch(a => {
                    n(a), delete codeProcessing[i]
                })
            }).catch(s => {
                if ((s || {}).name === "ValidationError") {
                    r({
                        valid: !1,
                        reason: s.message === "UNKNOWN_SIGNING_KEY" ? "UNKNOWN_SIGNING_KEY" : "NOT_HCERT"
                    }), delete codeProcessing[i];
                    return
                }
                n(s), delete codeProcessing[i]
            })
        })
    }

    function fillCertificateDetails(i, r) {
        i.querySelector(".data .person-name").innerText = ((r.nam.gn || "") + " " + (r.nam.fn || "")).trim();
        let n = r.dob ? dayjs.utc(r.dob) : null;
        !r.dob || n === null || !n.isValid() ? n = "-" : r.dob.length === 4 ? n = n.format("YYYY.") : r.dob.length === 7 ? n = n.format("MM.YYYY.") : n = n.format("DD.MM.YYYY."), i.querySelector(".data .person-birth").innerText = n, i.querySelector(".data .certificate-type-v").style.display = "v" in r && r.v.length > 0 ? "block" : "none", i.querySelector(".data .certificate-type-r").style.display = "r" in r && r.r.length > 0 ? "block" : "none", i.querySelector(".data .certificate-type-t").style.display = "t" in r && r.t.length > 0 ? "block" : "none"
    }

    function getDeviceCameras() {
        return new Promise((i, r) => {
            if (devliceList !== null) {
                i(devliceList, selectCamera);
                return
            }
            e.listCameras(!0).then(n => {
                if (devliceList !== null) {
                    i(devliceList, selectCamera);
                    return
                }
                devliceList = [];
                const s = {};
                let a = !1;
                if (n && n.length) {
                    for (let o = 0; o < n.length; o += 1) n[o].id in s || (n[o].label.toLowerCase().indexOf("back") >= 0 ? devliceList.splice(0, 0, n[o]) : devliceList.push(n[o]), s[n[o].id] = !0), n[o].id === selectedCamera && (a = !0);
                    (!a || selectedCamera === null) && (selectedCamera = devliceList[0].id), i(devliceList, selectedCamera)
                }
            }).catch(n => {
                r(n)
            })
        })
    }

    function selectCamera(i) {
        selectedCamera !== i && (selectedCamera = i, qrScanner !== null && qrScanner.setCamera(i))
    }

    function getCamera() {
        return selectedCamera
    }

    function stopCamera() {
        return new Promise(i => {
            if (qrScanner === null) {
                i();
                return
            }
            qrScanner.hasFlash().then(r => {
                r && qrScanner.isFlashOn() ? qrScanner.turnFlashOff().then(() => {
                    qrScanner.stop(), i()
                }).catch(() => {
                    qrScanner.stop(), i()
                }) : (qrScanner.stop(), i())
            }).catch(() => {
                qrScanner.stop(), i()
            })
        })
    }

    function turnFlashOn(i) {
        qrScanner !== null && qrScanner.hasFlash().then(r => {
            r && qrScanner.turnFlashOn().then(() => {
                document.getElementById(i).querySelector(".flash-off").style.display = "none", document.getElementById(i).querySelector(".flash-on").style.display = "block"
            }).catch(() => {})
        }).catch(() => {})
    }

    function turnFlashOff(i) {
        qrScanner !== null && qrScanner.hasFlash().then(r => {
            r && qrScanner.turnFlashOff().then(() => {
                document.getElementById(i).querySelector(".flash-on").style.display = "none", document.getElementById(i).querySelector(".flash-off").style.display = "block"
            }).catch(() => {})
        }).catch(() => {})
    }

    function initCameraSelector(i, r, n) {
        return new Promise((s, a) => {
            getDeviceCameras().then(o => {
                if (o && o.length) {
                    const c = i.getElementsByClassName("template")[0];
                    if (i.querySelectorAll(".bx--dropdown-link").length > 1) return;
                    for (let p = o.length - 1; p >= 0; p -= 1) {
                        const h = templateRepeat(c, c);
                        h.classList.remove("template"), fillValues(h, {
                            cameraName: o[p].label
                        });
                        const u = h.getElementsByClassName("bx--dropdown-link");
                        selectedCamera === o[p].id && (i.dataset.value = o[p].id, document.getElementById(r).innerText = o[p].label, h.classList.add("bx--dropdown--selected"), u.length > 0 && u[0].setAttribute("aria-checked", !0)), h.dataset.value = o[p].id, h.dataset.title = o[p].label, u.length > 0 ? u[0].addEventListener("click", n) : h.addEventListener("click", n)
                    }
                }
                s()
            }).catch(o => {
                a(o)
            })
        })
    }

    function initCamera(i, r, n) {
        return document.getElementById(i).querySelector(".flash-on").style.display = "none", document.getElementById(i).querySelector(".flash-off").style.display = "none", new Promise((s, a) => {
            if (qrScanner !== null) {
                qrScanner.start().then(() => {
                    qrScanner.hasFlash().then(c => {
                        c && (qrScanner.isFlashOn() ? document.getElementById(i).querySelector(".flash-on").style.display = "block" : document.getElementById(i).querySelector(".flash-off").style.display = "block"), s()
                    }).catch(() => {
                        s()
                    })
                }).catch(c => {
                    a(c)
                });
                return
            }
            const o = document.getElementById(i).querySelector("video");
            qrScanner = new e(o, r, c => {
                c === "No QR code found" || c === "Scanner error: RangeError: Array size is not a small enough positive integer." || n(c)
            }), qrScanner.setCamera(getCamera()).then(() => {
                qrScanner.start().then(() => {
                    qrScanner.hasFlash().then(c => {
                        c && (qrScanner.isFlashOn() ? document.getElementById(i).querySelector(".flash-on").style.display = "block" : document.getElementById(i).querySelector(".flash-off").style.display = "block"), s()
                    }).catch(() => {
                        s()
                    })
                }).catch(c => {
                    a(c)
                })
            }).catch(c => {
                a(c)
            })
        })
    }

    function getPdfToImage(i) {
        return new Promise((r, n) => {
            const s = new FileReader;
            s.onload = a => {
                const o = new Uint8Array(a.target.result);
                let c = pdf_1.getDocument(o);
                c.promise.then(p => {
                    p.getPage(1).then(h => {
                        let u = document.createElement("CANVAS");
                        const l = h.getViewport({
                            scale: 2
                        });
                        u.height = l.height, u.width = l.width, h.render({
                            canvasContext: u.getContext("2d"),
                            viewport: l
                        }).promise.then(() => {
                            const v = u.toDataURL("image/png");
                            c.destroy(), c = null, u.remove(), u = null, r(v)
                        }).catch(v => {
                            n(v)
                        })
                    })
                })
            }, s.readAsArrayBuffer(i)
        })
    }

    function getImageToCanvas(i, r, n) {
        return new Promise((s, a) => {
            const o = window.URL || window.webkitURL;
            let c = new Image;
            c.onload = () => {
                let p = document.createElement("CANVAS");
                const h = n || 0;
                p.width = c.width * (r || 1) + h * 2, p.height = c.height * (r || 1) + h * 2;
                const u = p.getContext("2d");
                h > 0 && (u.fillStyle = "white", u.fillRect(0, 0, p.width, p.height)), u.drawImage(c, h, h, p.width - h, p.height - h);
                const l = p.toDataURL("image/png");
                p.remove(), p = null, c.remove(), c = null, s(l)
            }, c.onerror = p => {
                a(p)
            }, c.src = o.createObjectURL(i)
        })
    }

    function scanFileInternal(i, r, n, s) {
        e.scanImage(r).then(a => {
            n(a)
        }).catch(a => {
            s(a)
        })
    }

    function scanFile(i, r, n, s) {
        if (!!r) {
            if (r.type === "application/pdf") {
                getPdfToImage(r).then(a => {
                    scanFileInternal(i, a, n, s)
                }).catch(a => {
                    s(a)
                });
                return
            }
            scanFileInternal(i, r, n, a => {
                if (a == "No QR code found") {
                    (function o(c, p) {
                        if (c >= 7)
                            if (p === 0) c = 2, p = 15;
                            else {
                                s(a);
                                return
                            } getImageToCanvas(r, c, 20).then(h => {
                            scanFileInternal(i, h, n, u => {
                                if (u == "No QR code found") {
                                    o(c + 1, p * (c + 1));
                                    return
                                }
                                s(u)
                            })
                        }).catch(() => {
                            s(a)
                        })
                    })(2, 0);
                    return
                }
                s(a)
            })
        }
    }
    const createWorker = () => new Worker(URL.createObjectURL(new Blob([`class x{constructor(a,b){this.width=b;this.height=a.length/b;this.data=a}static createEmpty(a,b){return new x(new Uint8ClampedArray(a*b),a)}get(a,b){return 0>a||a>=this.width||0>b||b>=this.height?!1:!!this.data[b*this.width+a]}set(a,b,c){this.data[b*this.width+a]=c?1:0}setRegion(a,b,c,d,e){for(let f=b;f<b+d;f++)for(let g=a;g<a+c;g++)this.set(g,f,!!e)}}
class A{constructor(a,b,c){this.width=a;a*=b;if(c&&c.length!==a)throw Error("Wrong buffer size");this.data=c||new Uint8ClampedArray(a)}get(a,b){return this.data[b*this.width+a]}set(a,b,c){this.data[b*this.width+a]=c}}
class ba{constructor(a){this.bitOffset=this.byteOffset=0;this.bytes=a}readBits(a){if(1>a||32<a||a>this.available())throw Error("Cannot read "+a.toString()+" bits");var b=0;if(0<this.bitOffset){b=8-this.bitOffset;var c=a<b?a:b;b-=c;b=(this.bytes[this.byteOffset]&255>>8-c<<b)>>b;a-=c;this.bitOffset+=c;8===this.bitOffset&&(this.bitOffset=0,this.byteOffset++)}if(0<a){for(;8<=a;)b=b<<8|this.bytes[this.byteOffset]&255,this.byteOffset++,a-=8;0<a&&(c=8-a,b=b<<a|(this.bytes[this.byteOffset]&255>>c<<c)>>c,
this.bitOffset+=a)}return b}available(){return 8*(this.bytes.length-this.byteOffset)-this.bitOffset}}var B,C=B||(B={});C.Numeric="numeric";C.Alphanumeric="alphanumeric";C.Byte="byte";C.Kanji="kanji";C.ECI="eci";C.StructuredAppend="structuredappend";var D,E=D||(D={});E[E.Terminator=0]="Terminator";E[E.Numeric=1]="Numeric";E[E.Alphanumeric=2]="Alphanumeric";E[E.Byte=4]="Byte";E[E.Kanji=8]="Kanji";E[E.ECI=7]="ECI";E[E.StructuredAppend=3]="StructuredAppend";let F="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".split("");
function ca(a,b){let c=[],d="";b=a.readBits([8,16,16][b]);for(let e=0;e<b;e++){let f=a.readBits(8);c.push(f)}try{d+=decodeURIComponent(c.map(e=>\`%\${("0"+e.toString(16)).substr(-2)}\`).join(""))}catch(e){}return{bytes:c,text:d}}
function da(a,b){a=new ba(a);let c=9>=b?0:26>=b?1:2;for(b={text:"",bytes:[],chunks:[],version:b};4<=a.available();){var d=a.readBits(4);if(d===D.Terminator)return b;if(d===D.ECI)0===a.readBits(1)?b.chunks.push({type:B.ECI,assignmentNumber:a.readBits(7)}):0===a.readBits(1)?b.chunks.push({type:B.ECI,assignmentNumber:a.readBits(14)}):0===a.readBits(1)?b.chunks.push({type:B.ECI,assignmentNumber:a.readBits(21)}):b.chunks.push({type:B.ECI,assignmentNumber:-1});else if(d===D.Numeric){var e=a,f=[];d="";for(var g=
e.readBits([10,12,14][c]);3<=g;){var h=e.readBits(10);if(1E3<=h)throw Error("Invalid numeric value above 999");var k=Math.floor(h/100),m=Math.floor(h/10)%10;h%=10;f.push(48+k,48+m,48+h);d+=k.toString()+m.toString()+h.toString();g-=3}if(2===g){g=e.readBits(7);if(100<=g)throw Error("Invalid numeric value above 99");e=Math.floor(g/10);g%=10;f.push(48+e,48+g);d+=e.toString()+g.toString()}else if(1===g){e=e.readBits(4);if(10<=e)throw Error("Invalid numeric value above 9");f.push(48+e);d+=e.toString()}b.text+=
d;b.bytes.push(...f);b.chunks.push({type:B.Numeric,text:d})}else if(d===D.Alphanumeric){e=a;f=[];d="";for(g=e.readBits([9,11,13][c]);2<=g;)m=e.readBits(11),k=Math.floor(m/45),m%=45,f.push(F[k].charCodeAt(0),F[m].charCodeAt(0)),d+=F[k]+F[m],g-=2;1===g&&(e=e.readBits(6),f.push(F[e].charCodeAt(0)),d+=F[e]);b.text+=d;b.bytes.push(...f);b.chunks.push({type:B.Alphanumeric,text:d})}else if(d===D.Byte)d=ca(a,c),b.text+=d.text,b.bytes.push(...d.bytes),b.chunks.push({type:B.Byte,bytes:d.bytes,text:d.text});
else if(d===D.Kanji){f=a;d=[];e=f.readBits([8,10,12][c]);for(g=0;g<e;g++)k=f.readBits(13),k=Math.floor(k/192)<<8|k%192,k=7936>k?k+33088:k+49472,d.push(k>>8,k&255);f=(new TextDecoder("shift-jis")).decode(Uint8Array.from(d));b.text+=f;b.bytes.push(...d);b.chunks.push({type:B.Kanji,bytes:d,text:f})}else d===D.StructuredAppend&&b.chunks.push({type:B.StructuredAppend,currentSequence:a.readBits(4),totalSequence:a.readBits(4),parity:a.readBits(8)})}if(0===a.available()||0===a.readBits(a.available()))return b}
class G{constructor(a,b){if(0===b.length)throw Error("No coefficients.");this.field=a;let c=b.length;if(1<c&&0===b[0]){let d=1;for(;d<c&&0===b[d];)d++;if(d===c)this.coefficients=a.zero.coefficients;else for(this.coefficients=new Uint8ClampedArray(c-d),a=0;a<this.coefficients.length;a++)this.coefficients[a]=b[d+a]}else this.coefficients=b}degree(){return this.coefficients.length-1}isZero(){return 0===this.coefficients[0]}getCoefficient(a){return this.coefficients[this.coefficients.length-1-a]}addOrSubtract(a){if(this.isZero())return a;
if(a.isZero())return this;let b=this.coefficients;a=a.coefficients;b.length>a.length&&([b,a]=[a,b]);let c=new Uint8ClampedArray(a.length),d=a.length-b.length;for(var e=0;e<d;e++)c[e]=a[e];for(e=d;e<a.length;e++)c[e]=b[e-d]^a[e];return new G(this.field,c)}multiply(a){if(0===a)return this.field.zero;if(1===a)return this;let b=this.coefficients.length,c=new Uint8ClampedArray(b);for(let d=0;d<b;d++)c[d]=this.field.multiply(this.coefficients[d],a);return new G(this.field,c)}multiplyPoly(a){if(this.isZero()||
a.isZero())return this.field.zero;let b=this.coefficients,c=b.length;a=a.coefficients;let d=a.length,e=new Uint8ClampedArray(c+d-1);for(let f=0;f<c;f++){let g=b[f];for(let h=0;h<d;h++)e[f+h]=H(e[f+h],this.field.multiply(g,a[h]))}return new G(this.field,e)}multiplyByMonomial(a,b){if(0>a)throw Error("Invalid degree less than 0");if(0===b)return this.field.zero;let c=this.coefficients.length;a=new Uint8ClampedArray(c+a);for(let d=0;d<c;d++)a[d]=this.field.multiply(this.coefficients[d],b);return new G(this.field,
a)}evaluateAt(a){let b=0;if(0===a)return this.getCoefficient(0);let c=this.coefficients.length;if(1===a)return this.coefficients.forEach(d=>{b^=d}),b;b=this.coefficients[0];for(let d=1;d<c;d++)b=H(this.field.multiply(a,b),this.coefficients[d]);return b}}function H(a,b){return a^b}
class ea{constructor(a,b,c){this.primitive=a;this.size=b;this.generatorBase=c;this.expTable=Array(this.size);this.logTable=Array(this.size);a=1;for(b=0;b<this.size;b++)this.expTable[b]=a,a*=2,a>=this.size&&(a=(a^this.primitive)&this.size-1);for(a=0;a<this.size-1;a++)this.logTable[this.expTable[a]]=a;this.zero=new G(this,Uint8ClampedArray.from([0]));this.one=new G(this,Uint8ClampedArray.from([1]))}multiply(a,b){return 0===a||0===b?0:this.expTable[(this.logTable[a]+this.logTable[b])%(this.size-1)]}inverse(a){if(0===
a)throw Error("Can't invert 0");return this.expTable[this.size-this.logTable[a]-1]}buildMonomial(a,b){if(0>a)throw Error("Invalid monomial degree less than 0");if(0===b)return this.zero;a=new Uint8ClampedArray(a+1);a[0]=b;return new G(this,a)}log(a){if(0===a)throw Error("Can't take log(0)");return this.logTable[a]}exp(a){return this.expTable[a]}}
function fa(a,b,c,d){b.degree()<c.degree()&&([b,c]=[c,b]);let e=a.zero;for(var f=a.one;c.degree()>=d/2;){var g=b;let h=e;b=c;e=f;if(b.isZero())return null;c=g;f=a.zero;g=b.getCoefficient(b.degree());for(g=a.inverse(g);c.degree()>=b.degree()&&!c.isZero();){let k=c.degree()-b.degree(),m=a.multiply(c.getCoefficient(c.degree()),g);f=f.addOrSubtract(a.buildMonomial(k,m));c=c.addOrSubtract(b.multiplyByMonomial(k,m))}f=f.multiplyPoly(e).addOrSubtract(h);if(c.degree()>=b.degree())return null}d=f.getCoefficient(0);
if(0===d)return null;a=a.inverse(d);return[f.multiply(a),c.multiply(a)]}
function ha(a,b){let c=new Uint8ClampedArray(a.length);c.set(a);a=new ea(285,256,0);var d=new G(a,c),e=new Uint8ClampedArray(b),f=!1;for(var g=0;g<b;g++){var h=d.evaluateAt(a.exp(g+a.generatorBase));e[e.length-1-g]=h;0!==h&&(f=!0)}if(!f)return c;d=new G(a,e);d=fa(a,a.buildMonomial(b,1),d,b);if(null===d)return null;b=d[0];g=b.degree();if(1===g)b=[b.getCoefficient(1)];else{e=Array(g);f=0;for(h=1;h<a.size&&f<g;h++)0===b.evaluateAt(h)&&(e[f]=a.inverse(h),f++);b=f!==g?null:e}if(null==b)return null;e=d[1];
f=b.length;d=Array(f);for(g=0;g<f;g++){h=a.inverse(b[g]);let k=1;for(let m=0;m<f;m++)g!==m&&(k=a.multiply(k,H(1,a.multiply(b[m],h))));d[g]=a.multiply(e.evaluateAt(h),a.inverse(k));0!==a.generatorBase&&(d[g]=a.multiply(d[g],h))}for(e=0;e<b.length;e++){f=c.length-1-a.log(b[e]);if(0>f)return null;c[f]^=d[e]}return c}
let I=[{infoBits:null,versionNumber:1,alignmentPatternCenters:[],errorCorrectionLevels:[{ecCodewordsPerBlock:7,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:19}]},{ecCodewordsPerBlock:10,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:16}]},{ecCodewordsPerBlock:13,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:13}]},{ecCodewordsPerBlock:17,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:9}]}]},{infoBits:null,versionNumber:2,alignmentPatternCenters:[6,18],errorCorrectionLevels:[{ecCodewordsPerBlock:10,ecBlocks:[{numBlocks:1,
dataCodewordsPerBlock:34}]},{ecCodewordsPerBlock:16,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:28}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:22}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:16}]}]},{infoBits:null,versionNumber:3,alignmentPatternCenters:[6,22],errorCorrectionLevels:[{ecCodewordsPerBlock:15,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:55}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:44}]},{ecCodewordsPerBlock:18,
ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:17}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:13}]}]},{infoBits:null,versionNumber:4,alignmentPatternCenters:[6,26],errorCorrectionLevels:[{ecCodewordsPerBlock:20,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:80}]},{ecCodewordsPerBlock:18,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:32}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:24}]},{ecCodewordsPerBlock:16,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:9}]}]},
{infoBits:null,versionNumber:5,alignmentPatternCenters:[6,30],errorCorrectionLevels:[{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:108}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:43}]},{ecCodewordsPerBlock:18,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:15},{numBlocks:2,dataCodewordsPerBlock:16}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:11},{numBlocks:2,dataCodewordsPerBlock:12}]}]},{infoBits:null,versionNumber:6,alignmentPatternCenters:[6,
34],errorCorrectionLevels:[{ecCodewordsPerBlock:18,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:68}]},{ecCodewordsPerBlock:16,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:27}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:19}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:15}]}]},{infoBits:31892,versionNumber:7,alignmentPatternCenters:[6,22,38],errorCorrectionLevels:[{ecCodewordsPerBlock:20,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:78}]},{ecCodewordsPerBlock:18,
ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:31}]},{ecCodewordsPerBlock:18,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:14},{numBlocks:4,dataCodewordsPerBlock:15}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:13},{numBlocks:1,dataCodewordsPerBlock:14}]}]},{infoBits:34236,versionNumber:8,alignmentPatternCenters:[6,24,42],errorCorrectionLevels:[{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:97}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:38},
{numBlocks:2,dataCodewordsPerBlock:39}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:18},{numBlocks:2,dataCodewordsPerBlock:19}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:14},{numBlocks:2,dataCodewordsPerBlock:15}]}]},{infoBits:39577,versionNumber:9,alignmentPatternCenters:[6,26,46],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:36},
{numBlocks:2,dataCodewordsPerBlock:37}]},{ecCodewordsPerBlock:20,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:16},{numBlocks:4,dataCodewordsPerBlock:17}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:12},{numBlocks:4,dataCodewordsPerBlock:13}]}]},{infoBits:42195,versionNumber:10,alignmentPatternCenters:[6,28,50],errorCorrectionLevels:[{ecCodewordsPerBlock:18,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:68},{numBlocks:2,dataCodewordsPerBlock:69}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:4,
dataCodewordsPerBlock:43},{numBlocks:1,dataCodewordsPerBlock:44}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:19},{numBlocks:2,dataCodewordsPerBlock:20}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:15},{numBlocks:2,dataCodewordsPerBlock:16}]}]},{infoBits:48118,versionNumber:11,alignmentPatternCenters:[6,30,54],errorCorrectionLevels:[{ecCodewordsPerBlock:20,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:81}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:1,
dataCodewordsPerBlock:50},{numBlocks:4,dataCodewordsPerBlock:51}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:22},{numBlocks:4,dataCodewordsPerBlock:23}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:12},{numBlocks:8,dataCodewordsPerBlock:13}]}]},{infoBits:51042,versionNumber:12,alignmentPatternCenters:[6,32,58],errorCorrectionLevels:[{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:92},{numBlocks:2,dataCodewordsPerBlock:93}]},
{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:36},{numBlocks:2,dataCodewordsPerBlock:37}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:20},{numBlocks:6,dataCodewordsPerBlock:21}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:7,dataCodewordsPerBlock:14},{numBlocks:4,dataCodewordsPerBlock:15}]}]},{infoBits:55367,versionNumber:13,alignmentPatternCenters:[6,34,62],errorCorrectionLevels:[{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:107}]},
{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:37},{numBlocks:1,dataCodewordsPerBlock:38}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:20},{numBlocks:4,dataCodewordsPerBlock:21}]},{ecCodewordsPerBlock:22,ecBlocks:[{numBlocks:12,dataCodewordsPerBlock:11},{numBlocks:4,dataCodewordsPerBlock:12}]}]},{infoBits:58893,versionNumber:14,alignmentPatternCenters:[6,26,46,66],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:115},
{numBlocks:1,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:40},{numBlocks:5,dataCodewordsPerBlock:41}]},{ecCodewordsPerBlock:20,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:16},{numBlocks:5,dataCodewordsPerBlock:17}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:12},{numBlocks:5,dataCodewordsPerBlock:13}]}]},{infoBits:63784,versionNumber:15,alignmentPatternCenters:[6,26,48,70],errorCorrectionLevels:[{ecCodewordsPerBlock:22,
ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:87},{numBlocks:1,dataCodewordsPerBlock:88}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:41},{numBlocks:5,dataCodewordsPerBlock:42}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:24},{numBlocks:7,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:12},{numBlocks:7,dataCodewordsPerBlock:13}]}]},{infoBits:68472,versionNumber:16,alignmentPatternCenters:[6,26,50,
74],errorCorrectionLevels:[{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:98},{numBlocks:1,dataCodewordsPerBlock:99}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:7,dataCodewordsPerBlock:45},{numBlocks:3,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:15,dataCodewordsPerBlock:19},{numBlocks:2,dataCodewordsPerBlock:20}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:15},{numBlocks:13,dataCodewordsPerBlock:16}]}]},{infoBits:70749,
versionNumber:17,alignmentPatternCenters:[6,30,54,78],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:107},{numBlocks:5,dataCodewordsPerBlock:108}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:10,dataCodewordsPerBlock:46},{numBlocks:1,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:22},{numBlocks:15,dataCodewordsPerBlock:23}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:14},{numBlocks:17,
dataCodewordsPerBlock:15}]}]},{infoBits:76311,versionNumber:18,alignmentPatternCenters:[6,30,56,82],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:120},{numBlocks:1,dataCodewordsPerBlock:121}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:9,dataCodewordsPerBlock:43},{numBlocks:4,dataCodewordsPerBlock:44}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:22},{numBlocks:1,dataCodewordsPerBlock:23}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:2,
dataCodewordsPerBlock:14},{numBlocks:19,dataCodewordsPerBlock:15}]}]},{infoBits:79154,versionNumber:19,alignmentPatternCenters:[6,30,58,86],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:113},{numBlocks:4,dataCodewordsPerBlock:114}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:44},{numBlocks:11,dataCodewordsPerBlock:45}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:21},{numBlocks:4,dataCodewordsPerBlock:22}]},
{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:9,dataCodewordsPerBlock:13},{numBlocks:16,dataCodewordsPerBlock:14}]}]},{infoBits:84390,versionNumber:20,alignmentPatternCenters:[6,34,62,90],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:107},{numBlocks:5,dataCodewordsPerBlock:108}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:41},{numBlocks:13,dataCodewordsPerBlock:42}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:15,dataCodewordsPerBlock:24},
{numBlocks:5,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:15,dataCodewordsPerBlock:15},{numBlocks:10,dataCodewordsPerBlock:16}]}]},{infoBits:87683,versionNumber:21,alignmentPatternCenters:[6,28,50,72,94],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:116},{numBlocks:4,dataCodewordsPerBlock:117}]},{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:42}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:22},
{numBlocks:6,dataCodewordsPerBlock:23}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:19,dataCodewordsPerBlock:16},{numBlocks:6,dataCodewordsPerBlock:17}]}]},{infoBits:92361,versionNumber:22,alignmentPatternCenters:[6,26,50,74,98],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:111},{numBlocks:7,dataCodewordsPerBlock:112}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:7,dataCodewordsPerBlock:24},
{numBlocks:16,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:24,ecBlocks:[{numBlocks:34,dataCodewordsPerBlock:13}]}]},{infoBits:96236,versionNumber:23,alignmentPatternCenters:[6,30,54,74,102],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:121},{numBlocks:5,dataCodewordsPerBlock:122}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:47},{numBlocks:14,dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:24},
{numBlocks:14,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:16,dataCodewordsPerBlock:15},{numBlocks:14,dataCodewordsPerBlock:16}]}]},{infoBits:102084,versionNumber:24,alignmentPatternCenters:[6,28,54,80,106],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:117},{numBlocks:4,dataCodewordsPerBlock:118}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:45},{numBlocks:14,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:30,
ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:24},{numBlocks:16,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:30,dataCodewordsPerBlock:16},{numBlocks:2,dataCodewordsPerBlock:17}]}]},{infoBits:102881,versionNumber:25,alignmentPatternCenters:[6,32,58,84,110],errorCorrectionLevels:[{ecCodewordsPerBlock:26,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:106},{numBlocks:4,dataCodewordsPerBlock:107}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:47},{numBlocks:13,
dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:7,dataCodewordsPerBlock:24},{numBlocks:22,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:22,dataCodewordsPerBlock:15},{numBlocks:13,dataCodewordsPerBlock:16}]}]},{infoBits:110507,versionNumber:26,alignmentPatternCenters:[6,30,58,86,114],errorCorrectionLevels:[{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:10,dataCodewordsPerBlock:114},{numBlocks:2,dataCodewordsPerBlock:115}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:19,
dataCodewordsPerBlock:46},{numBlocks:4,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:28,dataCodewordsPerBlock:22},{numBlocks:6,dataCodewordsPerBlock:23}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:33,dataCodewordsPerBlock:16},{numBlocks:4,dataCodewordsPerBlock:17}]}]},{infoBits:110734,versionNumber:27,alignmentPatternCenters:[6,34,62,90,118],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:122},{numBlocks:4,dataCodewordsPerBlock:123}]},
{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:22,dataCodewordsPerBlock:45},{numBlocks:3,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:8,dataCodewordsPerBlock:23},{numBlocks:26,dataCodewordsPerBlock:24}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:12,dataCodewordsPerBlock:15},{numBlocks:28,dataCodewordsPerBlock:16}]}]},{infoBits:117786,versionNumber:28,alignmentPatternCenters:[6,26,50,74,98,122],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:117},
{numBlocks:10,dataCodewordsPerBlock:118}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:3,dataCodewordsPerBlock:45},{numBlocks:23,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:4,dataCodewordsPerBlock:24},{numBlocks:31,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:15},{numBlocks:31,dataCodewordsPerBlock:16}]}]},{infoBits:119615,versionNumber:29,alignmentPatternCenters:[6,30,54,78,102,126],errorCorrectionLevels:[{ecCodewordsPerBlock:30,
ecBlocks:[{numBlocks:7,dataCodewordsPerBlock:116},{numBlocks:7,dataCodewordsPerBlock:117}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:21,dataCodewordsPerBlock:45},{numBlocks:7,dataCodewordsPerBlock:46}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:1,dataCodewordsPerBlock:23},{numBlocks:37,dataCodewordsPerBlock:24}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:19,dataCodewordsPerBlock:15},{numBlocks:26,dataCodewordsPerBlock:16}]}]},{infoBits:126325,versionNumber:30,alignmentPatternCenters:[6,
26,52,78,104,130],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:5,dataCodewordsPerBlock:115},{numBlocks:10,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:19,dataCodewordsPerBlock:47},{numBlocks:10,dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:15,dataCodewordsPerBlock:24},{numBlocks:25,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:23,dataCodewordsPerBlock:15},{numBlocks:25,dataCodewordsPerBlock:16}]}]},
{infoBits:127568,versionNumber:31,alignmentPatternCenters:[6,30,56,82,108,134],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:13,dataCodewordsPerBlock:115},{numBlocks:3,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:46},{numBlocks:29,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:42,dataCodewordsPerBlock:24},{numBlocks:1,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:23,dataCodewordsPerBlock:15},
{numBlocks:28,dataCodewordsPerBlock:16}]}]},{infoBits:133589,versionNumber:32,alignmentPatternCenters:[6,34,60,86,112,138],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:115}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:10,dataCodewordsPerBlock:46},{numBlocks:23,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:10,dataCodewordsPerBlock:24},{numBlocks:35,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:19,
dataCodewordsPerBlock:15},{numBlocks:35,dataCodewordsPerBlock:16}]}]},{infoBits:136944,versionNumber:33,alignmentPatternCenters:[6,30,58,86,114,142],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:115},{numBlocks:1,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:14,dataCodewordsPerBlock:46},{numBlocks:21,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:29,dataCodewordsPerBlock:24},{numBlocks:19,dataCodewordsPerBlock:25}]},
{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:11,dataCodewordsPerBlock:15},{numBlocks:46,dataCodewordsPerBlock:16}]}]},{infoBits:141498,versionNumber:34,alignmentPatternCenters:[6,34,62,90,118,146],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:13,dataCodewordsPerBlock:115},{numBlocks:6,dataCodewordsPerBlock:116}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:14,dataCodewordsPerBlock:46},{numBlocks:23,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:44,
dataCodewordsPerBlock:24},{numBlocks:7,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:59,dataCodewordsPerBlock:16},{numBlocks:1,dataCodewordsPerBlock:17}]}]},{infoBits:145311,versionNumber:35,alignmentPatternCenters:[6,30,54,78,102,126,150],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:12,dataCodewordsPerBlock:121},{numBlocks:7,dataCodewordsPerBlock:122}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:12,dataCodewordsPerBlock:47},{numBlocks:26,dataCodewordsPerBlock:48}]},
{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:39,dataCodewordsPerBlock:24},{numBlocks:14,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:22,dataCodewordsPerBlock:15},{numBlocks:41,dataCodewordsPerBlock:16}]}]},{infoBits:150283,versionNumber:36,alignmentPatternCenters:[6,24,50,76,102,128,154],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:6,dataCodewordsPerBlock:121},{numBlocks:14,dataCodewordsPerBlock:122}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:6,
dataCodewordsPerBlock:47},{numBlocks:34,dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:46,dataCodewordsPerBlock:24},{numBlocks:10,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:2,dataCodewordsPerBlock:15},{numBlocks:64,dataCodewordsPerBlock:16}]}]},{infoBits:152622,versionNumber:37,alignmentPatternCenters:[6,28,54,80,106,132,158],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:17,dataCodewordsPerBlock:122},{numBlocks:4,dataCodewordsPerBlock:123}]},
{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:29,dataCodewordsPerBlock:46},{numBlocks:14,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:49,dataCodewordsPerBlock:24},{numBlocks:10,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:24,dataCodewordsPerBlock:15},{numBlocks:46,dataCodewordsPerBlock:16}]}]},{infoBits:158308,versionNumber:38,alignmentPatternCenters:[6,32,58,84,110,136,162],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:4,
dataCodewordsPerBlock:122},{numBlocks:18,dataCodewordsPerBlock:123}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:13,dataCodewordsPerBlock:46},{numBlocks:32,dataCodewordsPerBlock:47}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:48,dataCodewordsPerBlock:24},{numBlocks:14,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:42,dataCodewordsPerBlock:15},{numBlocks:32,dataCodewordsPerBlock:16}]}]},{infoBits:161089,versionNumber:39,alignmentPatternCenters:[6,26,54,82,110,138,166],
errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:20,dataCodewordsPerBlock:117},{numBlocks:4,dataCodewordsPerBlock:118}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:40,dataCodewordsPerBlock:47},{numBlocks:7,dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:43,dataCodewordsPerBlock:24},{numBlocks:22,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:10,dataCodewordsPerBlock:15},{numBlocks:67,dataCodewordsPerBlock:16}]}]},{infoBits:167017,
versionNumber:40,alignmentPatternCenters:[6,30,58,86,114,142,170],errorCorrectionLevels:[{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:19,dataCodewordsPerBlock:118},{numBlocks:6,dataCodewordsPerBlock:119}]},{ecCodewordsPerBlock:28,ecBlocks:[{numBlocks:18,dataCodewordsPerBlock:47},{numBlocks:31,dataCodewordsPerBlock:48}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:34,dataCodewordsPerBlock:24},{numBlocks:34,dataCodewordsPerBlock:25}]},{ecCodewordsPerBlock:30,ecBlocks:[{numBlocks:20,dataCodewordsPerBlock:15},
{numBlocks:61,dataCodewordsPerBlock:16}]}]}];function J(a,b){a^=b;for(b=0;a;)b++,a&=a-1;return b}function K(a,b){return b<<1|a}
let ia=[{bits:21522,formatInfo:{errorCorrectionLevel:1,dataMask:0}},{bits:20773,formatInfo:{errorCorrectionLevel:1,dataMask:1}},{bits:24188,formatInfo:{errorCorrectionLevel:1,dataMask:2}},{bits:23371,formatInfo:{errorCorrectionLevel:1,dataMask:3}},{bits:17913,formatInfo:{errorCorrectionLevel:1,dataMask:4}},{bits:16590,formatInfo:{errorCorrectionLevel:1,dataMask:5}},{bits:20375,formatInfo:{errorCorrectionLevel:1,dataMask:6}},{bits:19104,formatInfo:{errorCorrectionLevel:1,dataMask:7}},{bits:30660,formatInfo:{errorCorrectionLevel:0,
dataMask:0}},{bits:29427,formatInfo:{errorCorrectionLevel:0,dataMask:1}},{bits:32170,formatInfo:{errorCorrectionLevel:0,dataMask:2}},{bits:30877,formatInfo:{errorCorrectionLevel:0,dataMask:3}},{bits:26159,formatInfo:{errorCorrectionLevel:0,dataMask:4}},{bits:25368,formatInfo:{errorCorrectionLevel:0,dataMask:5}},{bits:27713,formatInfo:{errorCorrectionLevel:0,dataMask:6}},{bits:26998,formatInfo:{errorCorrectionLevel:0,dataMask:7}},{bits:5769,formatInfo:{errorCorrectionLevel:3,dataMask:0}},{bits:5054,
formatInfo:{errorCorrectionLevel:3,dataMask:1}},{bits:7399,formatInfo:{errorCorrectionLevel:3,dataMask:2}},{bits:6608,formatInfo:{errorCorrectionLevel:3,dataMask:3}},{bits:1890,formatInfo:{errorCorrectionLevel:3,dataMask:4}},{bits:597,formatInfo:{errorCorrectionLevel:3,dataMask:5}},{bits:3340,formatInfo:{errorCorrectionLevel:3,dataMask:6}},{bits:2107,formatInfo:{errorCorrectionLevel:3,dataMask:7}},{bits:13663,formatInfo:{errorCorrectionLevel:2,dataMask:0}},{bits:12392,formatInfo:{errorCorrectionLevel:2,
dataMask:1}},{bits:16177,formatInfo:{errorCorrectionLevel:2,dataMask:2}},{bits:14854,formatInfo:{errorCorrectionLevel:2,dataMask:3}},{bits:9396,formatInfo:{errorCorrectionLevel:2,dataMask:4}},{bits:8579,formatInfo:{errorCorrectionLevel:2,dataMask:5}},{bits:11994,formatInfo:{errorCorrectionLevel:2,dataMask:6}},{bits:11245,formatInfo:{errorCorrectionLevel:2,dataMask:7}}],ja=[a=>0===(a.y+a.x)%2,a=>0===a.y%2,a=>0===a.x%3,a=>0===(a.y+a.x)%3,a=>0===(Math.floor(a.y/2)+Math.floor(a.x/3))%2,a=>0===a.x*a.y%
2+a.x*a.y%3,a=>0===(a.y*a.x%2+a.y*a.x%3)%2,a=>0===((a.y+a.x)%2+a.y*a.x%3)%2];
function ka(a,b,c){c=ja[c.dataMask];let d=a.height;var e=17+4*b.versionNumber;let f=x.createEmpty(e,e);f.setRegion(0,0,9,9,!0);f.setRegion(e-8,0,8,9,!0);f.setRegion(0,e-8,9,8,!0);for(var g of b.alignmentPatternCenters)for(var h of b.alignmentPatternCenters)6===g&&6===h||6===g&&h===e-7||g===e-7&&6===h||f.setRegion(g-2,h-2,5,5,!0);f.setRegion(6,9,1,e-17,!0);f.setRegion(9,6,e-17,1,!0);6<b.versionNumber&&(f.setRegion(e-11,0,3,6,!0),f.setRegion(0,e-11,6,3,!0));b=[];h=g=0;e=!0;for(let k=d-1;0<k;k-=2){6===
k&&k--;for(let m=0;m<d;m++){let l=e?d-1-m:m;for(let n=0;2>n;n++){let q=k-n;if(!f.get(q,l)){h++;let r=a.get(q,l);c({y:l,x:q})&&(r=!r);g=g<<1|r;8===h&&(b.push(g),g=h=0)}}}e=!e}return b}
function la(a){var b=a.height,c=Math.floor((b-17)/4);if(6>=c)return I[c-1];c=0;for(var d=5;0<=d;d--)for(var e=b-9;e>=b-11;e--)c=K(a.get(e,d),c);d=0;for(e=5;0<=e;e--)for(let g=b-9;g>=b-11;g--)d=K(a.get(e,g),d);a=Infinity;let f;for(let g of I){if(g.infoBits===c||g.infoBits===d)return g;b=J(c,g.infoBits);b<a&&(f=g,a=b);b=J(d,g.infoBits);b<a&&(f=g,a=b)}if(3>=a)return f}
function ma(a){let b=0;for(var c=0;8>=c;c++)6!==c&&(b=K(a.get(c,8),b));for(c=7;0<=c;c--)6!==c&&(b=K(a.get(8,c),b));var d=a.height;c=0;for(var e=d-1;e>=d-7;e--)c=K(a.get(8,e),c);for(e=d-8;e<d;e++)c=K(a.get(e,8),c);a=Infinity;d=null;for(let {bits:f,formatInfo:g}of ia){if(f===b||f===c)return g;e=J(b,f);e<a&&(d=g,a=e);b!==c&&(e=J(c,f),e<a&&(d=g,a=e))}return 3>=a?d:null}
function na(a,b,c){let d=b.errorCorrectionLevels[c],e=[],f=0;d.ecBlocks.forEach(h=>{for(let k=0;k<h.numBlocks;k++)e.push({numDataCodewords:h.dataCodewordsPerBlock,codewords:[]}),f+=h.dataCodewordsPerBlock+d.ecCodewordsPerBlock});if(a.length<f)return null;a=a.slice(0,f);b=d.ecBlocks[0].dataCodewordsPerBlock;for(c=0;c<b;c++)for(var g of e)g.codewords.push(a.shift());if(1<d.ecBlocks.length)for(g=d.ecBlocks[0].numBlocks,b=d.ecBlocks[1].numBlocks,c=0;c<b;c++)e[g+c].codewords.push(a.shift());for(;0<a.length;)for(let h of e)h.codewords.push(a.shift());
return e}function L(a){let b=la(a);if(!b)return null;var c=ma(a);if(!c)return null;a=ka(a,b,c);var d=na(a,b,c.errorCorrectionLevel);if(!d)return null;c=d.reduce((e,f)=>e+f.numDataCodewords,0);c=new Uint8ClampedArray(c);a=0;for(let e of d){d=ha(e.codewords,e.codewords.length-e.numDataCodewords);if(!d)return null;for(let f=0;f<e.numDataCodewords;f++)c[a++]=d[f]}try{return da(c,b.versionNumber)}catch(e){return null}}
function M(a,b,c,d){var e=a.x-b.x+c.x-d.x;let f=a.y-b.y+c.y-d.y;if(0===e&&0===f)return{a11:b.x-a.x,a12:b.y-a.y,a13:0,a21:c.x-b.x,a22:c.y-b.y,a23:0,a31:a.x,a32:a.y,a33:1};let g=b.x-c.x;var h=d.x-c.x;let k=b.y-c.y,m=d.y-c.y;c=g*m-h*k;h=(e*m-h*f)/c;e=(g*f-e*k)/c;return{a11:b.x-a.x+h*b.x,a12:b.y-a.y+h*b.y,a13:h,a21:d.x-a.x+e*d.x,a22:d.y-a.y+e*d.y,a23:e,a31:a.x,a32:a.y,a33:1}}
function oa(a,b,c,d){a=M(a,b,c,d);return{a11:a.a22*a.a33-a.a23*a.a32,a12:a.a13*a.a32-a.a12*a.a33,a13:a.a12*a.a23-a.a13*a.a22,a21:a.a23*a.a31-a.a21*a.a33,a22:a.a11*a.a33-a.a13*a.a31,a23:a.a13*a.a21-a.a11*a.a23,a31:a.a21*a.a32-a.a22*a.a31,a32:a.a12*a.a31-a.a11*a.a32,a33:a.a11*a.a22-a.a12*a.a21}}
function pa(a,b){var c=oa({x:3.5,y:3.5},{x:b.dimension-3.5,y:3.5},{x:b.dimension-6.5,y:b.dimension-6.5},{x:3.5,y:b.dimension-3.5}),d=M(b.topLeft,b.topRight,b.alignmentPattern,b.bottomLeft),e=d.a11*c.a11+d.a21*c.a12+d.a31*c.a13,f=d.a12*c.a11+d.a22*c.a12+d.a32*c.a13,g=d.a13*c.a11+d.a23*c.a12+d.a33*c.a13,h=d.a11*c.a21+d.a21*c.a22+d.a31*c.a23,k=d.a12*c.a21+d.a22*c.a22+d.a32*c.a23,m=d.a13*c.a21+d.a23*c.a22+d.a33*c.a23,l=d.a11*c.a31+d.a21*c.a32+d.a31*c.a33,n=d.a12*c.a31+d.a22*c.a32+d.a32*c.a33,q=d.a13*
c.a31+d.a23*c.a32+d.a33*c.a33;c=x.createEmpty(b.dimension,b.dimension);d=(r,u)=>{const p=g*r+m*u+q;return{x:(e*r+h*u+l)/p,y:(f*r+k*u+n)/p}};for(let r=0;r<b.dimension;r++)for(let u=0;u<b.dimension;u++){let p=d(u+.5,r+.5);c.set(u,r,a.get(Math.floor(p.x),Math.floor(p.y)))}return{matrix:c,mappingFunction:d}}let N=(a,b)=>Math.sqrt(Math.pow(b.x-a.x,2)+Math.pow(b.y-a.y,2));function O(a){return a.reduce((b,c)=>b+c)}
function qa(a,b,c){let d=N(a,b),e=N(b,c),f=N(a,c),g,h,k;e>=d&&e>=f?[g,h,k]=[b,a,c]:f>=e&&f>=d?[g,h,k]=[a,b,c]:[g,h,k]=[a,c,b];0>(k.x-h.x)*(g.y-h.y)-(k.y-h.y)*(g.x-h.x)&&([g,k]=[k,g]);return{bottomLeft:g,topLeft:h,topRight:k}}
function ra(a,b,c,d){d=(O(P(a,c,d,5))/7+O(P(a,b,d,5))/7+O(P(c,a,d,5))/7+O(P(b,a,d,5))/7)/4;if(1>d)throw Error("Invalid module size");b=Math.round(N(a,b)/d);a=Math.round(N(a,c)/d);a=Math.floor((b+a)/2)+7;switch(a%4){case 0:a++;break;case 2:a--}return{dimension:a,moduleSize:d}}
function Q(a,b,c,d){let e=[{x:Math.floor(a.x),y:Math.floor(a.y)}];var f=Math.abs(b.y-a.y)>Math.abs(b.x-a.x);if(f){var g=Math.floor(a.y);var h=Math.floor(a.x);a=Math.floor(b.y);b=Math.floor(b.x)}else g=Math.floor(a.x),h=Math.floor(a.y),a=Math.floor(b.x),b=Math.floor(b.y);let k=Math.abs(a-g),m=Math.abs(b-h),l=Math.floor(-k/2),n=g<a?1:-1,q=h<b?1:-1,r=!0;for(let u=g,p=h;u!==a+n;u+=n){g=f?p:u;h=f?u:p;if(c.get(g,h)!==r&&(r=!r,e.push({x:g,y:h}),e.length===d+1))break;l+=m;if(0<l){if(p===b)break;p+=q;l-=k}}c=
[];for(f=0;f<d;f++)e[f]&&e[f+1]?c.push(N(e[f],e[f+1])):c.push(0);return c}function P(a,b,c,d){let e=b.y-a.y,f=b.x-a.x;b=Q(a,b,c,Math.ceil(d/2));a=Q(a,{x:a.x-f,y:a.y-e},c,Math.ceil(d/2));c=b.shift()+a.shift()-1;return a.concat(c).concat(...b)}function R(a,b){let c=O(a)/O(b),d=0;b.forEach((e,f)=>{d+=Math.pow(a[f]-e*c,2)});return{averageSize:c,error:d}}
function S(a,b,c){try{let d=P(a,{x:-1,y:a.y},c,b.length),e=P(a,{x:a.x,y:-1},c,b.length),f=P(a,{x:Math.max(0,a.x-a.y)-1,y:Math.max(0,a.y-a.x)-1},c,b.length),g=P(a,{x:Math.min(c.width,a.x+a.y)+1,y:Math.min(c.height,a.y+a.x)+1},c,b.length),h=R(d,b),k=R(e,b),m=R(f,b),l=R(g,b),n=(h.averageSize+k.averageSize+m.averageSize+l.averageSize)/4;return Math.sqrt(h.error*h.error+k.error*k.error+m.error*m.error+l.error*l.error)+(Math.pow(h.averageSize-n,2)+Math.pow(k.averageSize-n,2)+Math.pow(m.averageSize-n,2)+
Math.pow(l.averageSize-n,2))/n}catch(d){return Infinity}}function T(a,b){for(var c=Math.round(b.x);a.get(c,Math.round(b.y));)c--;for(var d=Math.round(b.x);a.get(d,Math.round(b.y));)d++;c=(c+d)/2;for(d=Math.round(b.y);a.get(Math.round(c),d);)d--;for(b=Math.round(b.y);a.get(Math.round(c),b);)b++;return{x:c,y:(d+b)/2}}
function sa(a){var b=[],c=[];let d=[];var e=[];for(let p=0;p<=a.height;p++){var f=0,g=!1;let t=[0,0,0,0,0];for(let v=-1;v<=a.width;v++){var h=a.get(v,p);if(h===g)f++;else{t=[t[1],t[2],t[3],t[4],f];f=1;g=h;var k=O(t)/7;k=Math.abs(t[0]-k)<k&&Math.abs(t[1]-k)<k&&Math.abs(t[2]-3*k)<3*k&&Math.abs(t[3]-k)<k&&Math.abs(t[4]-k)<k&&!h;var m=O(t.slice(-3))/3;h=Math.abs(t[2]-m)<m&&Math.abs(t[3]-m)<m&&Math.abs(t[4]-m)<m&&h;if(k){let z=v-t[3]-t[4],y=z-t[2];k={startX:y,endX:z,y:p};m=c.filter(w=>y>=w.bottom.startX&&
y<=w.bottom.endX||z>=w.bottom.startX&&y<=w.bottom.endX||y<=w.bottom.startX&&z>=w.bottom.endX&&1.5>t[2]/(w.bottom.endX-w.bottom.startX)&&.5<t[2]/(w.bottom.endX-w.bottom.startX));0<m.length?m[0].bottom=k:c.push({top:k,bottom:k})}if(h){let z=v-t[4],y=z-t[3];h={startX:y,y:p,endX:z};k=e.filter(w=>y>=w.bottom.startX&&y<=w.bottom.endX||z>=w.bottom.startX&&y<=w.bottom.endX||y<=w.bottom.startX&&z>=w.bottom.endX&&1.5>t[2]/(w.bottom.endX-w.bottom.startX)&&.5<t[2]/(w.bottom.endX-w.bottom.startX));0<k.length?
k[0].bottom=h:e.push({top:h,bottom:h})}}}b.push(...c.filter(v=>v.bottom.y!==p&&2<=v.bottom.y-v.top.y));c=c.filter(v=>v.bottom.y===p);d.push(...e.filter(v=>v.bottom.y!==p));e=e.filter(v=>v.bottom.y===p)}b.push(...c.filter(p=>2<=p.bottom.y-p.top.y));d.push(...e);c=[];for(var l of b)2>l.bottom.y-l.top.y||(b=(l.top.startX+l.top.endX+l.bottom.startX+l.bottom.endX)/4,e=(l.top.y+l.bottom.y+1)/2,a.get(Math.round(b),Math.round(e))&&(f=[l.top.endX-l.top.startX,l.bottom.endX-l.bottom.startX,l.bottom.y-l.top.y+
1],f=O(f)/f.length,g=S({x:Math.round(b),y:Math.round(e)},[1,1,3,1,1],a),c.push({score:g,x:b,y:e,size:f})));if(3>c.length)return null;c.sort((p,t)=>p.score-t.score);l=[];for(b=0;b<Math.min(c.length,5);++b){e=c[b];f=[];for(var n of c)n!==e&&f.push(Object.assign(Object.assign({},n),{score:n.score+Math.pow(n.size-e.size,2)/e.size}));f.sort((p,t)=>p.score-t.score);l.push({points:[e,f[0],f[1]],score:e.score+f[0].score+f[1].score})}l.sort((p,t)=>p.score-t.score);let {topRight:q,topLeft:r,bottomLeft:u}=qa(...l[0].points);
l=U(a,d,q,r,u);n=[];l&&n.push({alignmentPattern:{x:l.alignmentPattern.x,y:l.alignmentPattern.y},bottomLeft:{x:u.x,y:u.y},dimension:l.dimension,topLeft:{x:r.x,y:r.y},topRight:{x:q.x,y:q.y}});l=T(a,q);b=T(a,r);c=T(a,u);(a=U(a,d,l,b,c))&&n.push({alignmentPattern:{x:a.alignmentPattern.x,y:a.alignmentPattern.y},bottomLeft:{x:c.x,y:c.y},topLeft:{x:b.x,y:b.y},topRight:{x:l.x,y:l.y},dimension:a.dimension});return 0===n.length?null:n}
function U(a,b,c,d,e){let f,g;try{({dimension:f,moduleSize:g}=ra(d,c,e,a))}catch(l){return null}var h=c.x-d.x+e.x,k=c.y-d.y+e.y;c=(N(d,e)+N(d,c))/2/g;e=1-3/c;let m={x:d.x+e*(h-d.x),y:d.y+e*(k-d.y)};b=b.map(l=>{const n=(l.top.startX+l.top.endX+l.bottom.startX+l.bottom.endX)/4;l=(l.top.y+l.bottom.y+1)/2;if(a.get(Math.floor(n),Math.floor(l))){var q=S({x:Math.floor(n),y:Math.floor(l)},[1,1,1],a)+N({x:n,y:l},m);return{x:n,y:l,score:q}}}).filter(l=>!!l).sort((l,n)=>l.score-n.score);return{alignmentPattern:15<=
c&&b.length?b[0]:m,dimension:f}}
function V(a){var b=sa(a);if(!b)return null;for(let e of b){b=pa(a,e);var c=b.matrix;if(null==c)c=null;else{var d=L(c);if(d)c=d;else{for(d=0;d<c.width;d++)for(let f=d+1;f<c.height;f++)c.get(d,f)!==c.get(f,d)&&(c.set(d,f,!c.get(d,f)),c.set(f,d,!c.get(f,d)));c=L(c)}}if(c)return{binaryData:c.bytes,data:c.text,chunks:c.chunks,version:c.version,location:{topRightCorner:b.mappingFunction(e.dimension,0),topLeftCorner:b.mappingFunction(0,0),bottomRightCorner:b.mappingFunction(e.dimension,e.dimension),bottomLeftCorner:b.mappingFunction(0,
e.dimension),topRightFinderPattern:e.topRight,topLeftFinderPattern:e.topLeft,bottomLeftFinderPattern:e.bottomLeft,bottomRightAlignmentPattern:e.alignmentPattern},matrix:b.matrix}}return null}let ta={inversionAttempts:"attemptBoth",greyScaleWeights:{red:.2126,green:.7152,blue:.0722,useIntegerApproximation:!1},canOverwriteImage:!0};function W(a,b){Object.keys(b).forEach(c=>{a[c]=b[c]})}
function X(a,b,c,d={}){let e=Object.create(null);W(e,ta);W(e,d);d="onlyInvert"===e.inversionAttempts||"invertFirst"===e.inversionAttempts;var f="attemptBoth"===e.inversionAttempts||d;var g=e.greyScaleWeights,h=e.canOverwriteImage,k=b*c;if(a.length!==4*k)throw Error("Malformed data passed to binarizer.");var m=0;if(h){var l=new Uint8ClampedArray(a.buffer,m,k);m+=k}l=new A(b,c,l);if(g.useIntegerApproximation)for(var n=0;n<c;n++)for(var q=0;q<b;q++){var r=4*(n*b+q);l.set(q,n,g.red*a[r]+g.green*a[r+1]+
g.blue*a[r+2]+128>>8)}else for(n=0;n<c;n++)for(q=0;q<b;q++)r=4*(n*b+q),l.set(q,n,g.red*a[r]+g.green*a[r+1]+g.blue*a[r+2]);g=Math.ceil(b/8);n=Math.ceil(c/8);q=g*n;if(h){var u=new Uint8ClampedArray(a.buffer,m,q);m+=q}u=new A(g,n,u);for(q=0;q<n;q++)for(r=0;r<g;r++){var p=Infinity,t=0;for(var v=0;8>v;v++)for(let w=0;8>w;w++){let aa=l.get(8*r+w,8*q+v);p=Math.min(p,aa);t=Math.max(t,aa)}v=(p+t)/2;v=Math.min(255,1.11*v);24>=t-p&&(v=p/2,0<q&&0<r&&(t=(u.get(r,q-1)+2*u.get(r-1,q)+u.get(r-1,q-1))/4,p<t&&(v=t)));
u.set(r,q,v)}h?(q=new Uint8ClampedArray(a.buffer,m,k),m+=k,q=new x(q,b)):q=x.createEmpty(b,c);r=null;f&&(h?(a=new Uint8ClampedArray(a.buffer,m,k),r=new x(a,b)):r=x.createEmpty(b,c));for(b=0;b<n;b++)for(a=0;a<g;a++){c=g-3;c=2>a?2:a>c?c:a;h=n-3;h=2>b?2:b>h?h:b;k=0;for(m=-2;2>=m;m++)for(p=-2;2>=p;p++)k+=u.get(c+m,h+p);c=k/25;for(h=0;8>h;h++)for(k=0;8>k;k++)m=8*a+h,p=8*b+k,t=l.get(m,p),q.set(m,p,t<=c),f&&r.set(m,p,!(t<=c))}f=f?{binarized:q,inverted:r}:{binarized:q};let {binarized:z,inverted:y}=f;(f=V(d?
y:z))||"attemptBoth"!==e.inversionAttempts&&"invertFirst"!==e.inversionAttempts||(f=V(d?z:y));return f}X.default=X;let Y="dontInvert",Z={red:77,green:150,blue:29,useIntegerApproximation:!0};
self.onmessage=a=>{let b=a.data.id,c=a.data.data;switch(a.data.type){case "decode":(a=X(c.data,c.width,c.height,{inversionAttempts:Y,greyScaleWeights:Z}))?self.postMessage({id:b,type:"qrResult",data:a.data,cornerPoints:[a.location.topLeftCorner,a.location.topRightCorner,a.location.bottomRightCorner,a.location.bottomLeftCorner]}):self.postMessage({id:b,type:"qrResult",data:null});break;case "grayscaleWeights":Z.red=c.red;Z.green=c.green;Z.blue=c.blue;Z.useIntegerApproximation=c.useIntegerApproximation;
break;case "inversionMode":switch(c){case "original":Y="dontInvert";break;case "invert":Y="onlyInvert";break;case "both":Y="attemptBoth";break;default:throw Error("Invalid inversion mode");}break;case "close":self.close()}}
`]), {
            type: "application/javascript"
        })),
        qrScannerWorker_min = Object.freeze(Object.defineProperty({
            __proto__: null,
            createWorker
        }, Symbol.toStringTag, {
            value: "Module"
        }));
    return exports.fillCertificateDetails = fillCertificateDetails, exports.getDeviceCameras = getDeviceCameras, exports.initCamera = initCamera, exports.initCameraSelector = initCameraSelector, exports.preloadKeys = preloadKeys, exports.renderRoleList = renderRoleList, exports.scanFile = scanFile, exports.selectCamera = selectCamera, exports.selectRole = selectRole, exports.stopCamera = stopCamera, exports.turnFlashOff = turnFlashOff, exports.turnFlashOn = turnFlashOn, exports.validate = validate, Object.defineProperties(exports, {
        __esModule: {
            value: !0
        },
        [Symbol.toStringTag]: {
            value: "Module"
        }
    }), exports
}({});